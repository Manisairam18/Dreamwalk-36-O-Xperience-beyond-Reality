/*! For license information please see bundle.b068a4afce69089b.js.LICENSE.txt */
(() => {
    var e = {
            498: function(e, t) {
                ! function(e) {
                    "use strict";
                    class t {
                        constructor(e) {
                            this.controller_ = e
                        }
                        get element() {
                            return this.controller_.view.element
                        }
                        get disabled() {
                            return this.controller_.viewProps.get("disabled")
                        }
                        set disabled(e) {
                            this.controller_.viewProps.set("disabled", e)
                        }
                        get hidden() {
                            return this.controller_.viewProps.get("hidden")
                        }
                        set hidden(e) {
                            this.controller_.viewProps.set("hidden", e)
                        }
                        dispose() {
                            this.controller_.viewProps.set("disposed", !0)
                        }
                    }
                    class n {
                        constructor(e) {
                            this.target = e
                        }
                    }
                    class i extends n {
                        constructor(e, t, n, i) {
                            super(e), this.value = t, this.presetKey = n, this.last = null == i || i
                        }
                    }
                    class r extends n {
                        constructor(e, t, n) {
                            super(e), this.value = t, this.presetKey = n
                        }
                    }
                    class s extends n {
                        constructor(e, t) {
                            super(e), this.expanded = t
                        }
                    }
                    class a extends n {
                        constructor(e, t) {
                            super(e), this.index = t
                        }
                    }

                    function o(e) {
                        return null == e
                    }

                    function l(e, t) {
                        if (e.length !== t.length) return !1;
                        for (let n = 0; n < e.length; n++)
                            if (e[n] !== t[n]) return !1;
                        return !0
                    }
                    const c = {
                        alreadydisposed: () => "View has been already disposed",
                        invalidparams: e => `Invalid parameters for '${e.name}'`,
                        nomatchingcontroller: e => `No matching controller for '${e.key}'`,
                        nomatchingview: e => `No matching view for '${JSON.stringify(e.params)}'`,
                        notbindable: () => "Value is not bindable",
                        propertynotfound: e => `Property '${e.name}' not found`,
                        shouldneverhappen: () => "This error should never happen"
                    };
                    class h {
                        constructor(e) {
                            var t;
                            this.message = null !== (t = c[e.type](e.context)) && void 0 !== t ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type
                        }
                        static alreadyDisposed() {
                            return new h({
                                type: "alreadydisposed"
                            })
                        }
                        static notBindable() {
                            return new h({
                                type: "notbindable"
                            })
                        }
                        static propertyNotFound(e) {
                            return new h({
                                type: "propertynotfound",
                                context: {
                                    name: e
                                }
                            })
                        }
                        static shouldNeverHappen() {
                            return new h({
                                type: "shouldneverhappen"
                            })
                        }
                    }
                    class u {
                        constructor(e, t, n) {
                            this.obj_ = e, this.key_ = t, this.presetKey_ = null != n ? n : t
                        }
                        static isBindable(e) {
                            return null !== e && "object" == typeof e
                        }
                        get key() {
                            return this.key_
                        }
                        get presetKey() {
                            return this.presetKey_
                        }
                        read() {
                            return this.obj_[this.key_]
                        }
                        write(e) {
                            this.obj_[this.key_] = e
                        }
                        writeProperty(e, t) {
                            const n = this.read();
                            if (!u.isBindable(n)) throw h.notBindable();
                            if (!(e in n)) throw h.propertyNotFound(e);
                            n[e] = t
                        }
                    }
                    class d extends t {
                        get label() {
                            return this.controller_.props.get("label")
                        }
                        set label(e) {
                            this.controller_.props.set("label", e)
                        }
                        get title() {
                            var e;
                            return null !== (e = this.controller_.valueController.props.get("title")) && void 0 !== e ? e : ""
                        }
                        set title(e) {
                            this.controller_.valueController.props.set("title", e)
                        }
                        on(e, t) {
                            const i = t.bind(this);
                            return this.controller_.valueController.emitter.on(e, (() => {
                                i(new n(this))
                            })), this
                        }
                    }
                    class p {
                        constructor() {
                            this.observers_ = {}
                        }
                        on(e, t) {
                            let n = this.observers_[e];
                            return n || (n = this.observers_[e] = []), n.push({
                                handler: t
                            }), this
                        }
                        off(e, t) {
                            const n = this.observers_[e];
                            return n && (this.observers_[e] = n.filter((e => e.handler !== t))), this
                        }
                        emit(e, t) {
                            const n = this.observers_[e];
                            n && n.forEach((e => {
                                e.handler(t)
                            }))
                        }
                    }
                    const f = "tp";

                    function m(e) {
                        return (t, n) => [f, "-", e, "v", t ? `_${t}` : "", n ? `-${n}` : ""].join("")
                    }

                    function g(e) {
                        return e.rawValue
                    }

                    function v(e, t) {
                        var n, i;
                        e.emitter.on("change", (n = g, i = t, e => i(n(e)))), t(e.rawValue)
                    }

                    function x(e, t, n) {
                        v(e.value(t), n)
                    }

                    function w(e, t) {
                        return n => {
                            ! function(e, t, n) {
                                n ? e.classList.add(t) : e.classList.remove(t)
                            }(e, t, n)
                        }
                    }

                    function b(e, t) {
                        v(e, (e => {
                            t.textContent = null != e ? e : ""
                        }))
                    }
                    const _ = m("btn");
                    class y {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(_()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("button");
                            n.classList.add(_("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
                            const i = e.createElement("div");
                            i.classList.add(_("t")), b(t.props.value("title"), i), this.buttonElement.appendChild(i)
                        }
                    }
                    class A {
                        constructor(e, t) {
                            this.emitter = new p, this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new y(e, {
                                props: this.props,
                                viewProps: this.viewProps
                            }), this.view.buttonElement.addEventListener("click", this.onClick_)
                        }
                        onClick_() {
                            this.emitter.emit("click", {
                                sender: this
                            })
                        }
                    }
                    class M {
                        constructor(e, t) {
                            var n;
                            this.constraint_ = null == t ? void 0 : t.constraint, this.equals_ = null !== (n = null == t ? void 0 : t.equals) && void 0 !== n ? n : (e, t) => e === t, this.emitter = new p, this.rawValue_ = e
                        }
                        get constraint() {
                            return this.constraint_
                        }
                        get rawValue() {
                            return this.rawValue_
                        }
                        set rawValue(e) {
                            this.setRawValue(e, {
                                forceEmit: !1,
                                last: !0
                            })
                        }
                        setRawValue(e, t) {
                            const n = null != t ? t : {
                                    forceEmit: !1,
                                    last: !0
                                },
                                i = this.constraint_ ? this.constraint_.constrain(e) : e;
                            (!this.equals_(this.rawValue_, i) || n.forceEmit) && (this.emitter.emit("beforechange", {
                                sender: this
                            }), this.rawValue_ = i, this.emitter.emit("change", {
                                options: n,
                                rawValue: i,
                                sender: this
                            }))
                        }
                    }
                    class S {
                        constructor(e) {
                            this.emitter = new p, this.value_ = e
                        }
                        get rawValue() {
                            return this.value_
                        }
                        set rawValue(e) {
                            this.setRawValue(e, {
                                forceEmit: !1,
                                last: !0
                            })
                        }
                        setRawValue(e, t) {
                            const n = null != t ? t : {
                                forceEmit: !1,
                                last: !0
                            };
                            (this.value_ !== e || n.forceEmit) && (this.emitter.emit("beforechange", {
                                sender: this
                            }), this.value_ = e, this.emitter.emit("change", {
                                options: n,
                                rawValue: this.value_,
                                sender: this
                            }))
                        }
                    }

                    function E(e, t) {
                        const n = null == t ? void 0 : t.constraint,
                            i = null == t ? void 0 : t.equals;
                        return n || i ? new M(e, t) : new S(e)
                    }
                    class T {
                        constructor(e) {
                            this.emitter = new p, this.valMap_ = e;
                            for (const e in this.valMap_) this.valMap_[e].emitter.on("change", (() => {
                                this.emitter.emit("change", {
                                    key: e,
                                    sender: this
                                })
                            }))
                        }
                        static createCore(e) {
                            return Object.keys(e).reduce(((t, n) => Object.assign(t, {
                                [n]: E(e[n])
                            })), {})
                        }
                        static fromObject(e) {
                            const t = this.createCore(e);
                            return new T(t)
                        }
                        get(e) {
                            return this.valMap_[e].rawValue
                        }
                        set(e, t) {
                            this.valMap_[e].rawValue = t
                        }
                        value(e) {
                            return this.valMap_[e]
                        }
                    }

                    function C(e) {
                        return t => n => {
                            if (!t && void 0 === n) return {
                                succeeded: !1,
                                value: void 0
                            };
                            if (t && void 0 === n) return {
                                succeeded: !0,
                                value: void 0
                            };
                            const i = e(n);
                            return void 0 !== i ? {
                                succeeded: !0,
                                value: i
                            } : {
                                succeeded: !1,
                                value: void 0
                            }
                        }
                    }

                    function D(e) {
                        return {
                            custom: t => C(t)(e),
                            boolean: C((e => "boolean" == typeof e ? e : void 0))(e),
                            number: C((e => "number" == typeof e ? e : void 0))(e),
                            string: C((e => "string" == typeof e ? e : void 0))(e),
                            function: C((e => "function" == typeof e ? e : void 0))(e),
                            constant: t => C((e => e === t ? t : void 0))(e),
                            raw: C((e => e))(e),
                            object: t => C((e => {
                                if (null !== (n = e) && "object" == typeof n) return function(e, t) {
                                    return Object.keys(t).reduce(((n, i) => {
                                        if (void 0 === n) return;
                                        const r = (0, t[i])(e[i]);
                                        return r.succeeded ? Object.assign(Object.assign({}, n), {
                                            [i]: r.value
                                        }) : void 0
                                    }), {})
                                }(e, t);
                                var n
                            }))(e),
                            array: t => C((e => {
                                if (Array.isArray(e)) return n = t, e.reduce(((e, t) => {
                                    if (void 0 === e) return;
                                    const i = n(t);
                                    return i.succeeded && void 0 !== i.value ? [...e, i.value] : void 0
                                }), []);
                                var n
                            }))(e)
                        }
                    }
                    const P = {
                        optional: D(!0),
                        required: D(!1)
                    };

                    function R(e, t) {
                        const n = P.required.object(t)(e);
                        return n.succeeded ? n.value : void 0
                    }
                    const L = m(""),
                        I = {
                            veryfirst: "vfst",
                            first: "fst",
                            last: "lst",
                            verylast: "vlst"
                        };
                    class B {
                        constructor(e) {
                            this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
                            const t = this.view.element;
                            this.blade.value("positions").emitter.on("change", (() => {
                                ["veryfirst", "first", "last", "verylast"].forEach((e => {
                                    t.classList.remove(L(void 0, I[e]))
                                })), this.blade.get("positions").forEach((e => {
                                    t.classList.add(L(void 0, I[e]))
                                }))
                            })), this.viewProps.handleDispose((() => {
                                ! function(e) {
                                    e && e.parentElement && e.parentElement.removeChild(e)
                                }(t)
                            }))
                        }
                        get parent() {
                            return this.parent_
                        }
                    }
                    const O = "http://www.w3.org/2000/svg";

                    function k(e) {
                        e.offsetHeight
                    }

                    function N(e) {
                        return void 0 !== e.ontouchstart
                    }

                    function F() {
                        return new Function("return this")().document
                    }
                    const U = {
                        check: '<path d="M2 8l4 4l8 -8"/>',
                        dropdown: '<path d="M5 7h6l-3 3 z"/>',
                        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
                    };

                    function z(e, t) {
                        const n = e.createElementNS(O, "svg");
                        return n.innerHTML = U[t], n
                    }

                    function V(e, t, n) {
                        e.insertBefore(t, e.children[n])
                    }

                    function H(e) {
                        e.parentElement && e.parentElement.removeChild(e)
                    }

                    function G(e) {
                        for (; e.children.length > 0;) e.removeChild(e.children[0])
                    }

                    function W(e) {
                        return e.relatedTarget ? e.relatedTarget : "explicitOriginalTarget" in e ? e.explicitOriginalTarget : null
                    }
                    const j = m("lbl");
                    class Y {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(j()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("div");
                            n.classList.add(j("l")), x(t.props, "label", (t => {
                                o(t) ? this.element.classList.add(j(void 0, "nol")) : (this.element.classList.remove(j(void 0, "nol")), function(e) {
                                    for (; e.childNodes.length > 0;) e.removeChild(e.childNodes[0])
                                }(n), n.appendChild(function(e, t) {
                                    const n = e.createDocumentFragment();
                                    return t.split("\n").map((t => e.createTextNode(t))).forEach(((t, i) => {
                                        i > 0 && n.appendChild(e.createElement("br")), n.appendChild(t)
                                    })), n
                                }(e, t)))
                            })), this.element.appendChild(n), this.labelElement = n;
                            const i = e.createElement("div");
                            i.classList.add(j("v")), this.element.appendChild(i), this.valueElement = i
                        }
                    }
                    class X extends B {
                        constructor(e, t) {
                            const n = t.valueController.viewProps;
                            super(Object.assign(Object.assign({}, t), {
                                view: new Y(e, {
                                    props: t.props,
                                    viewProps: n
                                }),
                                viewProps: n
                            })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
                        }
                    }
                    const Q = {
                        id: "button",
                        type: "blade",
                        accept(e) {
                            const t = P,
                                n = R(e, {
                                    title: t.required.string,
                                    view: t.required.constant("button"),
                                    label: t.optional.string
                                });
                            return n ? {
                                params: n
                            } : null
                        },
                        controller: e => new X(e.document, {
                            blade: e.blade,
                            props: T.fromObject({
                                label: e.params.label
                            }),
                            valueController: new A(e.document, {
                                props: T.fromObject({
                                    title: e.params.title
                                }),
                                viewProps: e.viewProps
                            })
                        }),
                        api: e => e.controller instanceof X && e.controller.valueController instanceof A ? new d(e.controller) : null
                    };
                    class q extends B {
                        constructor(e) {
                            super(e), this.value = e.value
                        }
                    }

                    function K() {
                        return new T({
                            positions: E([], {
                                equals: l
                            })
                        })
                    }
                    class Z extends T {
                        constructor(e) {
                            super(e)
                        }
                        static create(e) {
                            const t = {
                                    completed: !0,
                                    expanded: e,
                                    expandedHeight: null,
                                    shouldFixHeight: !1,
                                    temporaryExpanded: null
                                },
                                n = T.createCore(t);
                            return new Z(n)
                        }
                        get styleExpanded() {
                            var e;
                            return null !== (e = this.get("temporaryExpanded")) && void 0 !== e ? e : this.get("expanded")
                        }
                        get styleHeight() {
                            if (!this.styleExpanded) return "0";
                            const e = this.get("expandedHeight");
                            return this.get("shouldFixHeight") && !o(e) ? `${e}px` : "auto"
                        }
                        bindExpandedClass(e, t) {
                            const n = () => {
                                this.styleExpanded ? e.classList.add(t) : e.classList.remove(t)
                            };
                            x(this, "expanded", n), x(this, "temporaryExpanded", n)
                        }
                        cleanUpTransition() {
                            this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
                        }
                    }

                    function J(e, t) {
                        t.style.height = e.styleHeight
                    }

                    function $(e, t) {
                        e.value("expanded").emitter.on("beforechange", (() => {
                            e.set("completed", !1), o(e.get("expandedHeight")) && e.set("expandedHeight", function(e, t) {
                                let n = 0;
                                return function(e, t) {
                                    const n = e.style.transition;
                                    e.style.transition = "none", t(), e.style.transition = n
                                }(t, (() => {
                                    e.set("expandedHeight", null), e.set("temporaryExpanded", !0), k(t), n = t.clientHeight, e.set("temporaryExpanded", null), k(t)
                                })), n
                            }(e, t)), e.set("shouldFixHeight", !0), k(t)
                        })), e.emitter.on("change", (() => {
                            J(e, t)
                        })), J(e, t), t.addEventListener("transitionend", (t => {
                            "height" === t.propertyName && e.cleanUpTransition()
                        }))
                    }
                    class ee extends t {
                        constructor(e, t) {
                            super(e), this.rackApi_ = t
                        }
                    }
                    class te {
                        constructor(e) {
                            this.emitter = new p, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e
                        }
                        get items() {
                            return this.items_
                        }
                        allItems() {
                            return Array.from(this.cache_)
                        }
                        find(e) {
                            for (const t of this.allItems())
                                if (e(t)) return t;
                            return null
                        }
                        includes(e) {
                            return this.cache_.has(e)
                        }
                        add(e, t) {
                            if (this.includes(e)) throw h.shouldNeverHappen();
                            const n = void 0 !== t ? t : this.items_.length;
                            this.items_.splice(n, 0, e), this.cache_.add(e);
                            const i = this.extract_(e);
                            i && (i.emitter.on("add", this.onSubListAdd_), i.emitter.on("remove", this.onSubListRemove_), i.allItems().forEach((e => {
                                this.cache_.add(e)
                            }))), this.emitter.emit("add", {
                                index: n,
                                item: e,
                                root: this,
                                target: this
                            })
                        }
                        remove(e) {
                            const t = this.items_.indexOf(e);
                            if (t < 0) return;
                            this.items_.splice(t, 1), this.cache_.delete(e);
                            const n = this.extract_(e);
                            n && (n.emitter.off("add", this.onSubListAdd_), n.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
                                index: t,
                                item: e,
                                root: this,
                                target: this
                            })
                        }
                        onSubListAdd_(e) {
                            this.cache_.add(e.item), this.emitter.emit("add", {
                                index: e.index,
                                item: e.item,
                                root: this,
                                target: e.target
                            })
                        }
                        onSubListRemove_(e) {
                            this.cache_.delete(e.item), this.emitter.emit("remove", {
                                index: e.index,
                                item: e.item,
                                root: this,
                                target: e.target
                            })
                        }
                    }
                    class ne extends t {
                        constructor(e) {
                            super(e), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new p, this.controller_.binding.emitter.on("change", this.onBindingChange_)
                        }
                        get label() {
                            return this.controller_.props.get("label")
                        }
                        set label(e) {
                            this.controller_.props.set("label", e)
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                        refresh() {
                            this.controller_.binding.read()
                        }
                        onBindingChange_(e) {
                            const t = e.sender.target.read();
                            this.emitter_.emit("change", {
                                event: new i(this, t, this.controller_.binding.target.presetKey, e.options.last)
                            })
                        }
                    }
                    class ie extends X {
                        constructor(e, t) {
                            super(e, t), this.binding = t.binding
                        }
                    }
                    class re extends t {
                        constructor(e) {
                            super(e), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new p, this.controller_.binding.emitter.on("update", this.onBindingUpdate_)
                        }
                        get label() {
                            return this.controller_.props.get("label")
                        }
                        set label(e) {
                            this.controller_.props.set("label", e)
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                        refresh() {
                            this.controller_.binding.read()
                        }
                        onBindingUpdate_(e) {
                            const t = e.sender.target.read();
                            this.emitter_.emit("update", {
                                event: new r(this, t, this.controller_.binding.target.presetKey)
                            })
                        }
                    }
                    class se extends X {
                        constructor(e, t) {
                            super(e, t), this.binding = t.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose((() => {
                                this.binding.dispose()
                            }))
                        }
                    }

                    function ae(e) {
                        return e instanceof ce ? e.apiSet_ : e instanceof ee ? e.rackApi_.apiSet_ : null
                    }

                    function oe(e, t) {
                        const n = e.find((e => e.controller_ === t));
                        if (!n) throw h.shouldNeverHappen();
                        return n
                    }

                    function le(e, t, n) {
                        if (!u.isBindable(e)) throw h.notBindable();
                        return new u(e, t, n)
                    }
                    class ce extends t {
                        constructor(e, t) {
                            super(e), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new p, this.apiSet_ = new te(ae), this.pool_ = t;
                            const n = this.controller_.rack;
                            n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), n.emitter.on("inputchange", this.onRackInputChange_), n.emitter.on("monitorupdate", this.onRackMonitorUpdate_), n.children.forEach((e => {
                                this.setUpApi_(e)
                            }))
                        }
                        get children() {
                            return this.controller_.rack.children.map((e => oe(this.apiSet_, e)))
                        }
                        addInput(e, t, n) {
                            const i = null != n ? n : {},
                                r = this.controller_.view.element.ownerDocument,
                                s = this.pool_.createInput(r, le(e, t, i.presetKey), i),
                                a = new ne(s);
                            return this.add(a, i.index)
                        }
                        addMonitor(e, t, n) {
                            const i = null != n ? n : {},
                                r = this.controller_.view.element.ownerDocument,
                                s = this.pool_.createMonitor(r, le(e, t), i),
                                a = new re(s);
                            return this.add(a, i.index)
                        }
                        addFolder(e) {
                            return function(e, t) {
                                return e.addBlade(Object.assign(Object.assign({}, t), {
                                    view: "folder"
                                }))
                            }(this, e)
                        }
                        addButton(e) {
                            return function(e, t) {
                                return e.addBlade(Object.assign(Object.assign({}, t), {
                                    view: "button"
                                }))
                            }(this, e)
                        }
                        addSeparator(e) {
                            return function(e, t) {
                                const n = null != t ? t : {};
                                return e.addBlade(Object.assign(Object.assign({}, n), {
                                    view: "separator"
                                }))
                            }(this, e)
                        }
                        addTab(e) {
                            return function(e, t) {
                                return e.addBlade(Object.assign(Object.assign({}, t), {
                                    view: "tab"
                                }))
                            }(this, e)
                        }
                        add(e, t) {
                            this.controller_.rack.add(e.controller_, t);
                            const n = this.apiSet_.find((t => t.controller_ === e.controller_));
                            return n && this.apiSet_.remove(n), this.apiSet_.add(e), e
                        }
                        remove(e) {
                            this.controller_.rack.remove(e.controller_)
                        }
                        addBlade(e) {
                            const t = this.controller_.view.element.ownerDocument,
                                n = this.pool_.createBlade(t, e),
                                i = this.pool_.createBladeApi(n);
                            return this.add(i, e.index)
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                        setUpApi_(e) {
                            this.apiSet_.find((t => t.controller_ === e)) || this.apiSet_.add(this.pool_.createBladeApi(e))
                        }
                        onRackAdd_(e) {
                            this.setUpApi_(e.bladeController)
                        }
                        onRackRemove_(e) {
                            if (e.isRoot) {
                                const t = oe(this.apiSet_, e.bladeController);
                                this.apiSet_.remove(t)
                            }
                        }
                        onRackInputChange_(e) {
                            const t = e.bladeController;
                            if (t instanceof ie) {
                                const n = oe(this.apiSet_, t),
                                    r = t.binding;
                                this.emitter_.emit("change", {
                                    event: new i(n, r.target.read(), r.target.presetKey, e.options.last)
                                })
                            } else if (t instanceof q) {
                                const n = oe(this.apiSet_, t);
                                this.emitter_.emit("change", {
                                    event: new i(n, t.value.rawValue, void 0, e.options.last)
                                })
                            }
                        }
                        onRackMonitorUpdate_(e) {
                            if (!(e.bladeController instanceof se)) throw h.shouldNeverHappen();
                            const t = oe(this.apiSet_, e.bladeController),
                                n = e.bladeController.binding;
                            this.emitter_.emit("update", {
                                event: new r(t, n.target.read(), n.target.presetKey)
                            })
                        }
                    }
                    class he extends ee {
                        constructor(e, t) {
                            super(e, new ce(e.rackController, t)), this.emitter_ = new p, this.controller_.foldable.value("expanded").emitter.on("change", (e => {
                                this.emitter_.emit("fold", {
                                    event: new s(this, e.sender.rawValue)
                                })
                            })), this.rackApi_.on("change", (e => {
                                this.emitter_.emit("change", {
                                    event: e
                                })
                            })), this.rackApi_.on("update", (e => {
                                this.emitter_.emit("update", {
                                    event: e
                                })
                            }))
                        }
                        get expanded() {
                            return this.controller_.foldable.get("expanded")
                        }
                        set expanded(e) {
                            this.controller_.foldable.set("expanded", e)
                        }
                        get title() {
                            return this.controller_.props.get("title")
                        }
                        set title(e) {
                            this.controller_.props.set("title", e)
                        }
                        get children() {
                            return this.rackApi_.children
                        }
                        addInput(e, t, n) {
                            return this.rackApi_.addInput(e, t, n)
                        }
                        addMonitor(e, t, n) {
                            return this.rackApi_.addMonitor(e, t, n)
                        }
                        addFolder(e) {
                            return this.rackApi_.addFolder(e)
                        }
                        addButton(e) {
                            return this.rackApi_.addButton(e)
                        }
                        addSeparator(e) {
                            return this.rackApi_.addSeparator(e)
                        }
                        addTab(e) {
                            return this.rackApi_.addTab(e)
                        }
                        add(e, t) {
                            return this.rackApi_.add(e, t)
                        }
                        remove(e) {
                            this.rackApi_.remove(e)
                        }
                        addBlade(e) {
                            return this.rackApi_.addBlade(e)
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                    }
                    class ue extends B {
                        constructor(e) {
                            super({
                                blade: e.blade,
                                view: e.view,
                                viewProps: e.rackController.viewProps
                            }), this.rackController = e.rackController
                        }
                    }
                    class de {
                        constructor(e, t) {
                            const n = m(t.viewName);
                            this.element = e.createElement("div"), this.element.classList.add(n()), t.viewProps.bindClassModifiers(this.element)
                        }
                    }

                    function pe(e) {
                        return e instanceof ge ? e.rack : e instanceof ue ? e.rackController.rack : null
                    }

                    function fe(e) {
                        const t = pe(e);
                        return t ? t.bcSet_ : null
                    }
                    class me {
                        constructor(e) {
                            var t;
                            this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new p, this.blade_ = null != e ? e : null, null === (t = this.blade_) || void 0 === t || t.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new te(fe), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_)
                        }
                        get children() {
                            return this.bcSet_.items
                        }
                        add(e, t) {
                            e.parent && e.parent.remove(e), e.parent_ = this, this.bcSet_.add(e, t)
                        }
                        remove(e) {
                            e.parent_ = null, this.bcSet_.remove(e)
                        }
                        find(e) {
                            return this.bcSet_.allItems().filter((t => t instanceof e))
                        }
                        onSetAdd_(e) {
                            this.updatePositions_();
                            const t = e.target === e.root;
                            if (this.emitter.emit("add", {
                                    bladeController: e.item,
                                    index: e.index,
                                    isRoot: t,
                                    sender: this
                                }), !t) return;
                            const n = e.item;
                            if (n.viewProps.emitter.on("change", this.onChildViewPropsChange_), n.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n.viewProps.handleDispose(this.onChildDispose_), n instanceof ie) n.binding.emitter.on("change", this.onChildInputChange_);
                            else if (n instanceof se) n.binding.emitter.on("update", this.onChildMonitorUpdate_);
                            else if (n instanceof q) n.value.emitter.on("change", this.onChildValueChange_);
                            else {
                                const e = pe(n);
                                if (e) {
                                    const t = e.emitter;
                                    t.on("layout", this.onDescendantLayout_), t.on("inputchange", this.onDescendantInputChange_), t.on("monitorupdate", this.onDescendantMonitorUpdate_)
                                }
                            }
                        }
                        onSetRemove_(e) {
                            this.updatePositions_();
                            const t = e.target === e.root;
                            if (this.emitter.emit("remove", {
                                    bladeController: e.item,
                                    isRoot: t,
                                    sender: this
                                }), !t) return;
                            const n = e.item;
                            if (n instanceof ie) n.binding.emitter.off("change", this.onChildInputChange_);
                            else if (n instanceof se) n.binding.emitter.off("update", this.onChildMonitorUpdate_);
                            else if (n instanceof q) n.value.emitter.off("change", this.onChildValueChange_);
                            else {
                                const e = pe(n);
                                if (e) {
                                    const t = e.emitter;
                                    t.off("layout", this.onDescendantLayout_), t.off("inputchange", this.onDescendantInputChange_), t.off("monitorupdate", this.onDescendantMonitorUpdate_)
                                }
                            }
                        }
                        updatePositions_() {
                            const e = this.bcSet_.items.filter((e => !e.viewProps.get("hidden"))),
                                t = e[0],
                                n = e[e.length - 1];
                            this.bcSet_.items.forEach((e => {
                                const i = [];
                                e === t && (i.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || i.push("veryfirst")), e === n && (i.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || i.push("verylast")), e.blade.set("positions", i)
                            }))
                        }
                        onChildPositionsChange_() {
                            this.updatePositions_(), this.emitter.emit("layout", {
                                sender: this
                            })
                        }
                        onChildViewPropsChange_(e) {
                            this.updatePositions_(), this.emitter.emit("layout", {
                                sender: this
                            })
                        }
                        onChildDispose_() {
                            this.bcSet_.items.filter((e => e.viewProps.get("disposed"))).forEach((e => {
                                this.bcSet_.remove(e)
                            }))
                        }
                        onChildInputChange_(e) {
                            const t = function(e, t) {
                                for (let n = 0; n < e.length; n++) {
                                    const i = e[n];
                                    if (i instanceof ie && i.binding === t) return i
                                }
                                return null
                            }(this.find(ie), e.sender);
                            if (!t) throw h.shouldNeverHappen();
                            this.emitter.emit("inputchange", {
                                bladeController: t,
                                options: e.options,
                                sender: this
                            })
                        }
                        onChildMonitorUpdate_(e) {
                            const t = function(e, t) {
                                for (let n = 0; n < e.length; n++) {
                                    const i = e[n];
                                    if (i instanceof se && i.binding === t) return i
                                }
                                return null
                            }(this.find(se), e.sender);
                            if (!t) throw h.shouldNeverHappen();
                            this.emitter.emit("monitorupdate", {
                                bladeController: t,
                                sender: this
                            })
                        }
                        onChildValueChange_(e) {
                            const t = function(e, t) {
                                for (let n = 0; n < e.length; n++) {
                                    const i = e[n];
                                    if (i instanceof q && i.value === t) return i
                                }
                                return null
                            }(this.find(q), e.sender);
                            if (!t) throw h.shouldNeverHappen();
                            this.emitter.emit("inputchange", {
                                bladeController: t,
                                options: e.options,
                                sender: this
                            })
                        }
                        onDescendantLayout_(e) {
                            this.updatePositions_(), this.emitter.emit("layout", {
                                sender: this
                            })
                        }
                        onDescendantInputChange_(e) {
                            this.emitter.emit("inputchange", {
                                bladeController: e.bladeController,
                                options: e.options,
                                sender: this
                            })
                        }
                        onDescendantMonitorUpdate_(e) {
                            this.emitter.emit("monitorupdate", {
                                bladeController: e.bladeController,
                                sender: this
                            })
                        }
                        onBladePositionsChange_() {
                            this.updatePositions_()
                        }
                    }
                    class ge extends B {
                        constructor(e, t) {
                            super(Object.assign(Object.assign({}, t), {
                                view: new de(e, {
                                    viewName: "brk",
                                    viewProps: t.viewProps
                                })
                            })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
                            const n = new me(t.root ? void 0 : t.blade);
                            n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), this.rack = n, this.viewProps.handleDispose((() => {
                                for (let e = this.rack.children.length - 1; e >= 0; e--) this.rack.children[e].viewProps.set("disposed", !0)
                            }))
                        }
                        onRackAdd_(e) {
                            e.isRoot && V(this.view.element, e.bladeController.view.element, e.index)
                        }
                        onRackRemove_(e) {
                            e.isRoot && H(e.bladeController.view.element)
                        }
                    }
                    const ve = m("cnt");
                    class xe {
                        constructor(e, t) {
                            var n;
                            this.className_ = m(null !== (n = t.viewName) && void 0 !== n ? n : "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), ve()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), x(this.foldable_, "completed", w(this.element, this.className_(void 0, "cpl")));
                            const i = e.createElement("button");
                            i.classList.add(this.className_("b")), x(t.props, "title", (e => {
                                o(e) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
                            })), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
                            const r = e.createElement("div");
                            r.classList.add(this.className_("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r;
                            const s = e.createElement("div");
                            s.classList.add(this.className_("m")), this.buttonElement.appendChild(s);
                            const a = t.containerElement;
                            a.classList.add(this.className_("c")), this.element.appendChild(a), this.containerElement = a
                        }
                    }
                    class we extends ue {
                        constructor(e, t) {
                            var n;
                            const i = Z.create(null === (n = t.expanded) || void 0 === n || n),
                                r = new ge(e, {
                                    blade: t.blade,
                                    root: t.root,
                                    viewProps: t.viewProps
                                });
                            super(Object.assign(Object.assign({}, t), {
                                rackController: r,
                                view: new xe(e, {
                                    containerElement: r.view.element,
                                    foldable: i,
                                    props: t.props,
                                    viewName: t.root ? "rot" : void 0,
                                    viewProps: t.viewProps
                                })
                            })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = i, $(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", (() => {
                                this.foldable.cleanUpTransition()
                            })), this.rackController.rack.emitter.on("remove", (() => {
                                this.foldable.cleanUpTransition()
                            })), this.view.buttonElement.addEventListener("click", this.onTitleClick_)
                        }
                        get document() {
                            return this.view.element.ownerDocument
                        }
                        onTitleClick_() {
                            this.foldable.set("expanded", !this.foldable.get("expanded"))
                        }
                    }
                    const be = {
                        id: "folder",
                        type: "blade",
                        accept(e) {
                            const t = P,
                                n = R(e, {
                                    title: t.required.string,
                                    view: t.required.constant("folder"),
                                    expanded: t.optional.boolean
                                });
                            return n ? {
                                params: n
                            } : null
                        },
                        controller: e => new we(e.document, {
                            blade: e.blade,
                            expanded: e.params.expanded,
                            props: T.fromObject({
                                title: e.params.title
                            }),
                            viewProps: e.viewProps
                        }),
                        api: e => e.controller instanceof we ? new he(e.controller, e.pool) : null
                    };
                    class _e extends q {
                        constructor(e, t) {
                            const n = t.valueController.viewProps;
                            super(Object.assign(Object.assign({}, t), {
                                value: t.valueController.value,
                                view: new Y(e, {
                                    props: t.props,
                                    viewProps: n
                                }),
                                viewProps: n
                            })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
                        }
                    }
                    class ye extends t {}
                    const Ae = m("spr");
                    class Me {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(Ae()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("hr");
                            n.classList.add(Ae("r")), this.element.appendChild(n)
                        }
                    }
                    class Se extends B {
                        constructor(e, t) {
                            super(Object.assign(Object.assign({}, t), {
                                view: new Me(e, {
                                    viewProps: t.viewProps
                                })
                            }))
                        }
                    }
                    const Ee = {
                            id: "separator",
                            type: "blade",
                            accept(e) {
                                const t = R(e, {
                                    view: P.required.constant("separator")
                                });
                                return t ? {
                                    params: t
                                } : null
                            },
                            controller: e => new Se(e.document, {
                                blade: e.blade,
                                viewProps: e.viewProps
                            }),
                            api: e => e.controller instanceof Se ? new ye(e.controller) : null
                        },
                        Te = m("");

                    function Ce(e, t) {
                        return w(e, Te(void 0, t))
                    }
                    class De extends T {
                        constructor(e) {
                            super(e)
                        }
                        static create(e) {
                            var t, n;
                            const i = null != e ? e : {},
                                r = {
                                    disabled: null !== (t = i.disabled) && void 0 !== t && t,
                                    disposed: !1,
                                    hidden: null !== (n = i.hidden) && void 0 !== n && n
                                },
                                s = T.createCore(r);
                            return new De(s)
                        }
                        bindClassModifiers(e) {
                            x(this, "disabled", Ce(e, "disabled")), x(this, "hidden", Ce(e, "hidden"))
                        }
                        bindDisabled(e) {
                            x(this, "disabled", (t => {
                                e.disabled = t
                            }))
                        }
                        bindTabIndex(e) {
                            x(this, "disabled", (t => {
                                e.tabIndex = t ? -1 : 0
                            }))
                        }
                        handleDispose(e) {
                            this.value("disposed").emitter.on("change", (t => {
                                t && e()
                            }))
                        }
                    }
                    const Pe = m("tbi");
                    class Re {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(Pe()), t.viewProps.bindClassModifiers(this.element), x(t.props, "selected", (e => {
                                e ? this.element.classList.add(Pe(void 0, "sel")) : this.element.classList.remove(Pe(void 0, "sel"))
                            }));
                            const n = e.createElement("button");
                            n.classList.add(Pe("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
                            const i = e.createElement("div");
                            i.classList.add(Pe("t")), b(t.props.value("title"), i), this.buttonElement.appendChild(i), this.titleElement = i
                        }
                    }
                    class Le {
                        constructor(e, t) {
                            this.emitter = new p, this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new Re(e, {
                                props: t.props,
                                viewProps: t.viewProps
                            }), this.view.buttonElement.addEventListener("click", this.onClick_)
                        }
                        onClick_() {
                            this.emitter.emit("click", {
                                sender: this
                            })
                        }
                    }
                    class Ie {
                        constructor(e, t) {
                            this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Le(e, {
                                props: t.itemProps,
                                viewProps: De.create()
                            }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new ge(e, {
                                blade: K(),
                                viewProps: De.create()
                            }), this.props = t.props, x(this.props, "selected", (e => {
                                this.itemController.props.set("selected", e), this.contentController.viewProps.set("hidden", !e)
                            }))
                        }
                        get itemController() {
                            return this.ic_
                        }
                        get contentController() {
                            return this.cc_
                        }
                        onItemClick_() {
                            this.props.set("selected", !0)
                        }
                    }
                    class Be {
                        constructor(e, t) {
                            this.controller_ = e, this.rackApi_ = t
                        }
                        get title() {
                            var e;
                            return null !== (e = this.controller_.itemController.props.get("title")) && void 0 !== e ? e : ""
                        }
                        set title(e) {
                            this.controller_.itemController.props.set("title", e)
                        }
                        get selected() {
                            return this.controller_.props.get("selected")
                        }
                        set selected(e) {
                            this.controller_.props.set("selected", e)
                        }
                        get children() {
                            return this.rackApi_.children
                        }
                        addButton(e) {
                            return this.rackApi_.addButton(e)
                        }
                        addFolder(e) {
                            return this.rackApi_.addFolder(e)
                        }
                        addSeparator(e) {
                            return this.rackApi_.addSeparator(e)
                        }
                        addTab(e) {
                            return this.rackApi_.addTab(e)
                        }
                        add(e, t) {
                            this.rackApi_.add(e, t)
                        }
                        remove(e) {
                            this.rackApi_.remove(e)
                        }
                        addInput(e, t, n) {
                            return this.rackApi_.addInput(e, t, n)
                        }
                        addMonitor(e, t, n) {
                            return this.rackApi_.addMonitor(e, t, n)
                        }
                        addBlade(e) {
                            return this.rackApi_.addBlade(e)
                        }
                    }
                    class Oe extends ee {
                        constructor(e, t) {
                            super(e, new ce(e.rackController, t)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new p, this.pageApiMap_ = new Map, this.rackApi_.on("change", (e => {
                                this.emitter_.emit("change", {
                                    event: e
                                })
                            })), this.rackApi_.on("update", (e => {
                                this.emitter_.emit("update", {
                                    event: e
                                })
                            })), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((e => {
                                this.setUpPageApi_(e)
                            }))
                        }
                        get pages() {
                            return this.controller_.pageSet.items.map((e => {
                                const t = this.pageApiMap_.get(e);
                                if (!t) throw h.shouldNeverHappen();
                                return t
                            }))
                        }
                        addPage(e) {
                            const t = this.controller_.view.element.ownerDocument,
                                n = new Ie(t, {
                                    itemProps: T.fromObject({
                                        selected: !1,
                                        title: e.title
                                    }),
                                    props: T.fromObject({
                                        selected: !1
                                    })
                                });
                            this.controller_.add(n, e.index);
                            const i = this.pageApiMap_.get(n);
                            if (!i) throw h.shouldNeverHappen();
                            return i
                        }
                        removePage(e) {
                            this.controller_.remove(e)
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                        setUpPageApi_(e) {
                            const t = this.rackApi_.apiSet_.find((t => t.controller_ === e.contentController));
                            if (!t) throw h.shouldNeverHappen();
                            const n = new Be(e, t);
                            this.pageApiMap_.set(e, n)
                        }
                        onPageAdd_(e) {
                            this.setUpPageApi_(e.item)
                        }
                        onPageRemove_(e) {
                            if (!this.pageApiMap_.get(e.item)) throw h.shouldNeverHappen();
                            this.pageApiMap_.delete(e.item)
                        }
                        onSelect_(e) {
                            this.emitter_.emit("select", {
                                event: new a(this, e.rawValue)
                            })
                        }
                    }
                    class ke {
                        constructor() {
                            this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = E(!0), this.selectedIndex = E(-1), this.items_ = []
                        }
                        add(e, t) {
                            const n = null != t ? t : this.items_.length;
                            this.items_.splice(n, 0, e), e.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_()
                        }
                        remove(e) {
                            const t = this.items_.indexOf(e);
                            t < 0 || (this.items_.splice(t, 1), e.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_())
                        }
                        keepSelection_() {
                            if (0 === this.items_.length) return this.selectedIndex.rawValue = -1, void(this.empty.rawValue = !0);
                            const e = this.items_.findIndex((e => e.rawValue));
                            e < 0 ? (this.items_.forEach(((e, t) => {
                                e.rawValue = 0 === t
                            })), this.selectedIndex.rawValue = 0) : (this.items_.forEach(((t, n) => {
                                t.rawValue = n === e
                            })), this.selectedIndex.rawValue = e), this.empty.rawValue = !1
                        }
                        onItemSelectedChange_(e) {
                            if (e.rawValue) {
                                const t = this.items_.findIndex((t => t === e.sender));
                                this.items_.forEach(((e, n) => {
                                    e.rawValue = n === t
                                })), this.selectedIndex.rawValue = t
                            } else this.keepSelection_()
                        }
                    }
                    const Ne = m("tab");
                    class Fe {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(Ne(), ve()), t.viewProps.bindClassModifiers(this.element), v(t.empty, w(this.element, Ne(void 0, "nop")));
                            const n = e.createElement("div");
                            n.classList.add(Ne("i")), this.element.appendChild(n), this.itemsElement = n;
                            const i = t.contentsElement;
                            i.classList.add(Ne("c")), this.element.appendChild(i), this.contentsElement = i
                        }
                    }
                    class Ue extends ue {
                        constructor(e, t) {
                            const n = new ge(e, {
                                    blade: t.blade,
                                    viewProps: t.viewProps
                                }),
                                i = new ke;
                            super({
                                blade: t.blade,
                                rackController: n,
                                view: new Fe(e, {
                                    contentsElement: n.view.element,
                                    empty: i.empty,
                                    viewProps: t.viewProps
                                })
                            }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new te((() => null)), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = i
                        }
                        get pageSet() {
                            return this.pageSet_
                        }
                        add(e, t) {
                            this.pageSet_.add(e, t)
                        }
                        remove(e) {
                            this.pageSet_.remove(this.pageSet_.items[e])
                        }
                        onPageAdd_(e) {
                            const t = e.item;
                            V(this.view.itemsElement, t.itemController.view.element, e.index), this.rackController.rack.add(t.contentController, e.index), this.tab.add(t.props.value("selected"))
                        }
                        onPageRemove_(e) {
                            const t = e.item;
                            H(t.itemController.view.element), this.rackController.rack.remove(t.contentController), this.tab.remove(t.props.value("selected"))
                        }
                    }
                    const ze = {
                        id: "tab",
                        type: "blade",
                        accept(e) {
                            const t = P,
                                n = R(e, {
                                    pages: t.required.array(t.required.object({
                                        title: t.required.string
                                    })),
                                    view: t.required.constant("tab")
                                });
                            return n && 0 !== n.pages.length ? {
                                params: n
                            } : null
                        },
                        controller(e) {
                            const t = new Ue(e.document, {
                                blade: e.blade,
                                viewProps: e.viewProps
                            });
                            return e.params.pages.forEach((n => {
                                const i = new Ie(e.document, {
                                    itemProps: T.fromObject({
                                        selected: !1,
                                        title: n.title
                                    }),
                                    props: T.fromObject({
                                        selected: !1
                                    })
                                });
                                t.add(i)
                            })), t
                        },
                        api: e => e.controller instanceof Ue ? new Oe(e.controller, e.pool) : null
                    };
                    class Ve {
                        constructor() {
                            this.disabled = !1, this.emitter = new p
                        }
                        dispose() {}
                        tick() {
                            this.disabled || this.emitter.emit("tick", {
                                sender: this
                            })
                        }
                    }
                    class He {
                        constructor(e, t) {
                            this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new p, this.interval_ = t, this.setTimer_()
                        }
                        get disabled() {
                            return this.disabled_
                        }
                        set disabled(e) {
                            this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_()
                        }
                        dispose() {
                            this.clearTimer_()
                        }
                        clearTimer_() {
                            if (null === this.timerId_) return;
                            const e = this.doc_.defaultView;
                            e && e.clearInterval(this.timerId_), this.timerId_ = null
                        }
                        setTimer_() {
                            if (this.clearTimer_(), this.interval_ <= 0) return;
                            const e = this.doc_.defaultView;
                            e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_))
                        }
                        onTick_() {
                            this.disabled_ || this.emitter.emit("tick", {
                                sender: this
                            })
                        }
                    }
                    class Ge {
                        constructor(e) {
                            this.constraints = e
                        }
                        constrain(e) {
                            return this.constraints.reduce(((e, t) => t.constrain(e)), e)
                        }
                    }

                    function We(e, t) {
                        if (e instanceof t) return e;
                        if (e instanceof Ge) {
                            const n = e.constraints.reduce(((e, n) => e || (n instanceof t ? n : null)), null);
                            if (n) return n
                        }
                        return null
                    }
                    class je {
                        constructor(e) {
                            this.options = e
                        }
                        constrain(e) {
                            const t = this.options;
                            return 0 === t.length || t.filter((t => t.value === e)).length > 0 ? e : t[0].value
                        }
                    }
                    class Ye {
                        constructor(e) {
                            this.maxValue = e.max, this.minValue = e.min
                        }
                        constrain(e) {
                            let t = e;
                            return o(this.minValue) || (t = Math.max(t, this.minValue)), o(this.maxValue) || (t = Math.min(t, this.maxValue)), t
                        }
                    }
                    class Xe {
                        constructor(e, t = 0) {
                            this.step = e, this.origin = t
                        }
                        constrain(e) {
                            const t = this.origin % this.step;
                            return t + Math.round((e - t) / this.step) * this.step
                        }
                    }
                    const Qe = m("lst");
                    class qe {
                        constructor(e, t) {
                            this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(Qe()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("select");
                            n.classList.add(Qe("s")), x(this.props_, "options", (t => {
                                G(n), t.forEach(((t, i) => {
                                    const r = e.createElement("option");
                                    r.dataset.index = String(i), r.textContent = t.text, r.value = String(t.value), n.appendChild(r)
                                }))
                            })), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.selectElement = n;
                            const i = e.createElement("div");
                            i.classList.add(Qe("m")), i.appendChild(z(e, "dropdown")), this.element.appendChild(i), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, this.update_()
                        }
                        update_() {
                            this.selectElement.value = String(this.value_.rawValue)
                        }
                        onValueChange_() {
                            this.update_()
                        }
                    }
                    class Ke {
                        constructor(e, t) {
                            this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new qe(e, {
                                props: this.props,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view.selectElement.addEventListener("change", this.onSelectChange_)
                        }
                        onSelectChange_(e) {
                            const t = e.currentTarget.selectedOptions.item(0);
                            if (!t) return;
                            const n = Number(t.dataset.index);
                            this.value.rawValue = this.props.get("options")[n].value
                        }
                    }
                    const Ze = m("pop");
                    class Je {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(Ze()), t.viewProps.bindClassModifiers(this.element), v(t.shows, w(this.element, Ze(void 0, "v")))
                        }
                    }
                    class $e {
                        constructor(e, t) {
                            this.shows = E(!1), this.viewProps = t.viewProps, this.view = new Je(e, {
                                shows: this.shows,
                                viewProps: this.viewProps
                            })
                        }
                    }
                    const et = m("txt");
                    class tt {
                        constructor(e, t) {
                            this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(et()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
                            const n = e.createElement("input");
                            n.classList.add(et("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh()
                        }
                        refresh() {
                            const e = this.props_.get("formatter");
                            this.inputElement.value = e(this.value_.rawValue)
                        }
                        onChange_() {
                            this.refresh()
                        }
                    }
                    class nt {
                        constructor(e, t) {
                            this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new tt(e, {
                                props: t.props,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view.inputElement.addEventListener("change", this.onInputChange_)
                        }
                        onInputChange_(e) {
                            const t = e.currentTarget.value,
                                n = this.parser_(t);
                            o(n) || (this.value.rawValue = n), this.view.refresh()
                        }
                    }

                    function it(e) {
                        return "false" !== e && !!e
                    }

                    function rt(e) {
                        return function(e) {
                            return String(e)
                        }(e)
                    }
                    class st {
                        constructor(e) {
                            this.text = e
                        }
                        evaluate() {
                            return Number(this.text)
                        }
                        toString() {
                            return this.text
                        }
                    }
                    const at = {
                        "**": (e, t) => Math.pow(e, t),
                        "*": (e, t) => e * t,
                        "/": (e, t) => e / t,
                        "%": (e, t) => e % t,
                        "+": (e, t) => e + t,
                        "-": (e, t) => e - t,
                        "<<": (e, t) => e << t,
                        ">>": (e, t) => e >> t,
                        ">>>": (e, t) => e >>> t,
                        "&": (e, t) => e & t,
                        "^": (e, t) => e ^ t,
                        "|": (e, t) => e | t
                    };
                    class ot {
                        constructor(e, t, n) {
                            this.left = t, this.operator = e, this.right = n
                        }
                        evaluate() {
                            const e = at[this.operator];
                            if (!e) throw new Error(`unexpected binary operator: '${this.operator}`);
                            return e(this.left.evaluate(), this.right.evaluate())
                        }
                        toString() {
                            return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
                        }
                    }
                    const lt = {
                        "+": e => e,
                        "-": e => -e,
                        "~": e => ~e
                    };
                    class ct {
                        constructor(e, t) {
                            this.operator = e, this.expression = t
                        }
                        evaluate() {
                            const e = lt[this.operator];
                            if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
                            return e(this.expression.evaluate())
                        }
                        toString() {
                            return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
                        }
                    }

                    function ht(e) {
                        return (t, n) => {
                            for (let i = 0; i < e.length; i++) {
                                const r = e[i](t, n);
                                if ("" !== r) return r
                            }
                            return ""
                        }
                    }

                    function ut(e, t) {
                        var n;
                        const i = e.substr(t).match(/^\s+/);
                        return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                    }

                    function dt(e, t) {
                        var n;
                        const i = e.substr(t).match(/^[0-9]+/);
                        return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                    }

                    function pt(e, t) {
                        const n = e.substr(t, 1);
                        if (t += 1, "e" !== n.toLowerCase()) return "";
                        const i = function(e, t) {
                            const n = dt(e, t);
                            if ("" !== n) return n;
                            const i = e.substr(t, 1);
                            if ("-" !== i && "+" !== i) return "";
                            const r = dt(e, t += 1);
                            return "" === r ? "" : i + r
                        }(e, t);
                        return "" === i ? "" : n + i
                    }

                    function ft(e, t) {
                        const n = e.substr(t, 1);
                        if ("0" === n) return n;
                        const i = function(e, t) {
                            const n = e.substr(t, 1);
                            return n.match(/^[1-9]$/) ? n : ""
                        }(e, t);
                        return t += i.length, "" === i ? "" : i + dt(e, t)
                    }
                    const mt = ht([function(e, t) {
                        const n = ft(e, t);
                        if (t += n.length, "" === n) return "";
                        const i = e.substr(t, 1);
                        if (t += i.length, "." !== i) return "";
                        const r = dt(e, t);
                        return n + i + r + pt(e, t += r.length)
                    }, function(e, t) {
                        const n = e.substr(t, 1);
                        if (t += n.length, "." !== n) return "";
                        const i = dt(e, t);
                        return t += i.length, "" === i ? "" : n + i + pt(e, t)
                    }, function(e, t) {
                        const n = ft(e, t);
                        return t += n.length, "" === n ? "" : n + pt(e, t)
                    }]);
                    const gt = ht([function(e, t) {
                            const n = e.substr(t, 2);
                            if (t += n.length, "0b" !== n.toLowerCase()) return "";
                            const i = function(e, t) {
                                var n;
                                const i = e.substr(t).match(/^[01]+/);
                                return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                            }(e, t);
                            return "" === i ? "" : n + i
                        }, function(e, t) {
                            const n = e.substr(t, 2);
                            if (t += n.length, "0o" !== n.toLowerCase()) return "";
                            const i = function(e, t) {
                                var n;
                                const i = e.substr(t).match(/^[0-7]+/);
                                return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                            }(e, t);
                            return "" === i ? "" : n + i
                        }, function(e, t) {
                            const n = e.substr(t, 2);
                            if (t += n.length, "0x" !== n.toLowerCase()) return "";
                            const i = function(e, t) {
                                var n;
                                const i = e.substr(t).match(/^[0-9a-f]+/i);
                                return null !== (n = i && i[0]) && void 0 !== n ? n : ""
                            }(e, t);
                            return "" === i ? "" : n + i
                        }]),
                        vt = ht([gt, mt]);

                    function xt(e, t) {
                        var n;
                        return null !== (n = function(e, t) {
                            const n = vt(e, t);
                            return t += n.length, "" === n ? null : {
                                evaluable: new st(n),
                                cursor: t
                            }
                        }(e, t)) && void 0 !== n ? n : function(e, t) {
                            const n = e.substr(t, 1);
                            if (t += n.length, "(" !== n) return null;
                            const i = _t(e, t);
                            if (!i) return null;
                            t = i.cursor, t += ut(e, t).length;
                            const r = e.substr(t, 1);
                            return t += r.length, ")" !== r ? null : {
                                evaluable: i.evaluable,
                                cursor: t
                            }
                        }(e, t)
                    }

                    function wt(e, t, n) {
                        n += ut(t, n).length;
                        const i = e.filter((e => t.startsWith(e, n)))[0];
                        return i ? (n += i.length, {
                            cursor: n += ut(t, n).length,
                            operator: i
                        }) : null
                    }
                    const bt = [
                        ["**"],
                        ["*", "/", "%"],
                        ["+", "-"],
                        ["<<", ">>>", ">>"],
                        ["&"],
                        ["^"],
                        ["|"]
                    ].reduce(((e, t) => function(e, t) {
                        return (n, i) => {
                            const r = e(n, i);
                            if (!r) return null;
                            i = r.cursor;
                            let s = r.evaluable;
                            for (;;) {
                                const r = wt(t, n, i);
                                if (!r) break;
                                i = r.cursor;
                                const a = e(n, i);
                                if (!a) return null;
                                i = a.cursor, s = new ot(r.operator, s, a.evaluable)
                            }
                            return s ? {
                                cursor: i,
                                evaluable: s
                            } : null
                        }
                    }(e, t)), (function e(t, n) {
                        const i = xt(t, n);
                        if (i) return i;
                        const r = t.substr(n, 1);
                        if (n += r.length, "+" !== r && "-" !== r && "~" !== r) return null;
                        const s = e(t, n);
                        return s ? {
                            cursor: n = s.cursor,
                            evaluable: new ct(r, s.evaluable)
                        } : null
                    }));

                    function _t(e, t) {
                        return t += ut(e, t).length, bt(e, t)
                    }

                    function yt(e) {
                        var t;
                        const n = function(e) {
                            const t = _t(e, 0);
                            return t ? t.cursor + ut(e, t.cursor).length !== e.length ? null : t.evaluable : null
                        }(e);
                        return null !== (t = null == n ? void 0 : n.evaluate()) && void 0 !== t ? t : null
                    }

                    function At(e) {
                        if ("number" == typeof e) return e;
                        if ("string" == typeof e) {
                            const t = yt(e);
                            if (!o(t)) return t
                        }
                        return 0
                    }

                    function Mt(e) {
                        return String(e)
                    }

                    function St(e) {
                        return t => t.toFixed(Math.max(Math.min(e, 20), 0))
                    }
                    const Et = St(0);

                    function Tt(e) {
                        return Et(e) + "%"
                    }

                    function Ct(e) {
                        return String(e)
                    }

                    function Dt(e) {
                        return e
                    }

                    function Pt(e, t) {
                        for (; e.length < t;) e.push(void 0)
                    }

                    function Rt(e) {
                        const t = [];
                        return Pt(t, e), E(t)
                    }

                    function Lt(e) {
                        const t = e.indexOf(void 0);
                        return t < 0 ? e : e.slice(0, t)
                    }

                    function It({
                        primary: e,
                        secondary: t,
                        forward: n,
                        backward: i
                    }) {
                        let r = !1;

                        function s(e) {
                            r || (r = !0, e(), r = !1)
                        }
                        e.emitter.on("change", (i => {
                            s((() => {
                                t.setRawValue(n(e, t), i.options)
                            }))
                        })), t.emitter.on("change", (r => {
                            s((() => {
                                e.setRawValue(i(e, t), r.options)
                            })), s((() => {
                                t.setRawValue(n(e, t), r.options)
                            }))
                        })), s((() => {
                            t.setRawValue(n(e, t), {
                                forceEmit: !1,
                                last: !0
                            })
                        }))
                    }

                    function Bt(e, t) {
                        const n = e * (t.altKey ? .1 : 1) * (t.shiftKey ? 10 : 1);
                        return t.upKey ? +n : t.downKey ? -n : 0
                    }

                    function Ot(e) {
                        return {
                            altKey: e.altKey,
                            downKey: "ArrowDown" === e.key,
                            shiftKey: e.shiftKey,
                            upKey: "ArrowUp" === e.key
                        }
                    }

                    function kt(e) {
                        return {
                            altKey: e.altKey,
                            downKey: "ArrowLeft" === e.key,
                            shiftKey: e.shiftKey,
                            upKey: "ArrowRight" === e.key
                        }
                    }

                    function Nt(e) {
                        return function(e) {
                            return "ArrowUp" === e || "ArrowDown" === e
                        }(e) || "ArrowLeft" === e || "ArrowRight" === e
                    }

                    function Ft(e, t) {
                        var n, i;
                        const r = t.ownerDocument.defaultView,
                            s = t.getBoundingClientRect();
                        return {
                            x: e.pageX - ((null !== (n = r && r.scrollX) && void 0 !== n ? n : 0) + s.left),
                            y: e.pageY - ((null !== (i = r && r.scrollY) && void 0 !== i ? i : 0) + s.top)
                        }
                    }
                    class Ut {
                        constructor(e) {
                            this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new p, e.addEventListener("touchstart", this.onTouchStart_, {
                                passive: !1
                            }), e.addEventListener("touchmove", this.onTouchMove_, {
                                passive: !0
                            }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_)
                        }
                        computePosition_(e) {
                            const t = this.elem_.getBoundingClientRect();
                            return {
                                bounds: {
                                    width: t.width,
                                    height: t.height
                                },
                                point: e ? {
                                    x: e.x,
                                    y: e.y
                                } : null
                            }
                        }
                        onMouseDown_(e) {
                            var t;
                            e.preventDefault(), null === (t = e.currentTarget) || void 0 === t || t.focus();
                            const n = this.elem_.ownerDocument;
                            n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
                                altKey: e.altKey,
                                data: this.computePosition_(Ft(e, this.elem_)),
                                sender: this,
                                shiftKey: e.shiftKey
                            })
                        }
                        onDocumentMouseMove_(e) {
                            this.emitter.emit("move", {
                                altKey: e.altKey,
                                data: this.computePosition_(Ft(e, this.elem_)),
                                sender: this,
                                shiftKey: e.shiftKey
                            })
                        }
                        onDocumentMouseUp_(e) {
                            const t = this.elem_.ownerDocument;
                            t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
                                altKey: e.altKey,
                                data: this.computePosition_(Ft(e, this.elem_)),
                                sender: this,
                                shiftKey: e.shiftKey
                            })
                        }
                        onTouchStart_(e) {
                            e.preventDefault();
                            const t = e.targetTouches.item(0),
                                n = this.elem_.getBoundingClientRect();
                            this.emitter.emit("down", {
                                altKey: e.altKey,
                                data: this.computePosition_(t ? {
                                    x: t.clientX - n.left,
                                    y: t.clientY - n.top
                                } : void 0),
                                sender: this,
                                shiftKey: e.shiftKey
                            }), this.lastTouch_ = t
                        }
                        onTouchMove_(e) {
                            const t = e.targetTouches.item(0),
                                n = this.elem_.getBoundingClientRect();
                            this.emitter.emit("move", {
                                altKey: e.altKey,
                                data: this.computePosition_(t ? {
                                    x: t.clientX - n.left,
                                    y: t.clientY - n.top
                                } : void 0),
                                sender: this,
                                shiftKey: e.shiftKey
                            }), this.lastTouch_ = t
                        }
                        onTouchEnd_(e) {
                            var t;
                            const n = null !== (t = e.targetTouches.item(0)) && void 0 !== t ? t : this.lastTouch_,
                                i = this.elem_.getBoundingClientRect();
                            this.emitter.emit("up", {
                                altKey: e.altKey,
                                data: this.computePosition_(n ? {
                                    x: n.clientX - i.left,
                                    y: n.clientY - i.top
                                } : void 0),
                                sender: this,
                                shiftKey: e.shiftKey
                            })
                        }
                    }

                    function zt(e, t, n, i, r) {
                        return i + (e - t) / (n - t) * (r - i)
                    }

                    function Vt(e) {
                        return String(e.toFixed(10)).split(".")[1].replace(/0+$/, "").length
                    }

                    function Ht(e, t, n) {
                        return Math.min(Math.max(e, t), n)
                    }

                    function Gt(e, t) {
                        return (e % t + t) % t
                    }
                    const Wt = m("txt");
                    class jt {
                        constructor(e, t) {
                            this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Wt(), Wt(void 0, "num")), t.arrayPosition && this.element.classList.add(Wt(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("input");
                            n.classList.add(Wt("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Wt()), this.inputElement.classList.add(Wt("i"));
                            const i = e.createElement("div");
                            i.classList.add(Wt("k")), this.element.appendChild(i), this.knobElement = i;
                            const r = e.createElementNS(O, "svg");
                            r.classList.add(Wt("g")), this.knobElement.appendChild(r);
                            const s = e.createElementNS(O, "path");
                            s.classList.add(Wt("gb")), r.appendChild(s), this.guideBodyElem_ = s;
                            const a = e.createElementNS(O, "path");
                            a.classList.add(Wt("gh")), r.appendChild(a), this.guideHeadElem_ = a;
                            const o = e.createElement("div");
                            o.classList.add(m("tt")()), this.knobElement.appendChild(o), this.tooltipElem_ = o, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh()
                        }
                        onDraggingChange_(e) {
                            if (null === e.rawValue) return void this.element.classList.remove(Wt(void 0, "drg"));
                            this.element.classList.add(Wt(void 0, "drg"));
                            const t = e.rawValue / this.props_.get("draggingScale"),
                                n = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
                                i = Ht(-n, -4, 4);
                            this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n+i},0 L${n},4 L${n+i},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
                            const r = this.props_.get("formatter");
                            this.tooltipElem_.textContent = r(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`
                        }
                        refresh() {
                            const e = this.props_.get("formatter");
                            this.inputElement.value = e(this.value.rawValue)
                        }
                        onChange_() {
                            this.refresh()
                        }
                    }
                    class Yt {
                        constructor(e, t) {
                            var n;
                            this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.parser_ = t.parser, this.props = t.props, this.sliderProps_ = null !== (n = t.sliderProps) && void 0 !== n ? n : null, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = E(null), this.view = new jt(e, {
                                arrayPosition: t.arrayPosition,
                                dragging: this.dragging_,
                                props: this.props,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
                            const i = new Ut(this.view.knobElement);
                            i.emitter.on("down", this.onPointerDown_), i.emitter.on("move", this.onPointerMove_), i.emitter.on("up", this.onPointerUp_)
                        }
                        constrainValue_(e) {
                            var t, n;
                            const i = null === (t = this.sliderProps_) || void 0 === t ? void 0 : t.get("minValue"),
                                r = null === (n = this.sliderProps_) || void 0 === n ? void 0 : n.get("maxValue");
                            let s = e;
                            return void 0 !== i && (s = Math.max(s, i)), void 0 !== r && (s = Math.min(s, r)), s
                        }
                        onInputChange_(e) {
                            const t = e.currentTarget.value,
                                n = this.parser_(t);
                            o(n) || (this.value.rawValue = this.constrainValue_(n)), this.view.refresh()
                        }
                        onInputKeyDown_(e) {
                            const t = Bt(this.baseStep_, Ot(e));
                            0 !== t && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t), {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onInputKeyUp_(e) {
                            0 !== Bt(this.baseStep_, Ot(e)) && this.value.setRawValue(this.value.rawValue, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                        onPointerDown_() {
                            this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
                        }
                        computeDraggingValue_(e) {
                            if (!e.point) return null;
                            const t = e.point.x - e.bounds.width / 2;
                            return this.constrainValue_(this.originRawValue_ + t * this.props.get("draggingScale"))
                        }
                        onPointerMove_(e) {
                            const t = this.computeDraggingValue_(e.data);
                            null !== t && (this.value.setRawValue(t, {
                                forceEmit: !1,
                                last: !1
                            }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
                        }
                        onPointerUp_(e) {
                            const t = this.computeDraggingValue_(e.data);
                            null !== t && (this.value.setRawValue(t, {
                                forceEmit: !0,
                                last: !0
                            }), this.dragging_.rawValue = null)
                        }
                    }
                    const Xt = m("sld");
                    class Qt {
                        constructor(e, t) {
                            this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Xt()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("div");
                            n.classList.add(Xt("t")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.trackElement = n;
                            const i = e.createElement("div");
                            i.classList.add(Xt("k")), this.trackElement.appendChild(i), this.knobElement = i, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_()
                        }
                        update_() {
                            const e = Ht(zt(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
                            this.knobElement.style.width = `${e}%`
                        }
                        onChange_() {
                            this.update_()
                        }
                    }
                    class qt {
                        constructor(e, t) {
                            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new Qt(e, {
                                props: this.props,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.ptHandler_ = new Ut(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
                        }
                        handlePointerEvent_(e, t) {
                            e.point && this.value.setRawValue(zt(Ht(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t)
                        }
                        onPointerDownOrMove_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerUp_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                        onKeyDown_(e) {
                            const t = Bt(this.baseStep_, kt(e));
                            0 !== t && this.value.setRawValue(this.value.rawValue + t, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onKeyUp_(e) {
                            0 !== Bt(this.baseStep_, kt(e)) && this.value.setRawValue(this.value.rawValue, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                    }
                    const Kt = m("sldtxt");
                    class Zt {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(Kt());
                            const n = e.createElement("div");
                            n.classList.add(Kt("s")), this.sliderView_ = t.sliderView, n.appendChild(this.sliderView_.element), this.element.appendChild(n);
                            const i = e.createElement("div");
                            i.classList.add(Kt("t")), this.textView_ = t.textView, i.appendChild(this.textView_.element), this.element.appendChild(i)
                        }
                    }
                    class Jt {
                        constructor(e, t) {
                            this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new qt(e, {
                                baseStep: t.baseStep,
                                props: t.sliderProps,
                                value: t.value,
                                viewProps: this.viewProps
                            }), this.textC_ = new Yt(e, {
                                baseStep: t.baseStep,
                                parser: t.parser,
                                props: t.textProps,
                                sliderProps: t.sliderProps,
                                value: t.value,
                                viewProps: t.viewProps
                            }), this.view = new Zt(e, {
                                sliderView: this.sliderC_.view,
                                textView: this.textC_.view
                            })
                        }
                        get sliderController() {
                            return this.sliderC_
                        }
                        get textController() {
                            return this.textC_
                        }
                    }

                    function $t(e, t) {
                        e.write(t)
                    }

                    function en(e) {
                        const t = P;
                        return Array.isArray(e) ? t.required.array(t.required.object({
                            text: t.required.string,
                            value: t.required.raw
                        }))(e).value : "object" == typeof e ? t.required.raw(e).value : void 0
                    }

                    function tn(e) {
                        if ("inline" === e || "popup" === e) return e
                    }

                    function nn(e) {
                        const t = P;
                        return t.required.object({
                            max: t.optional.number,
                            min: t.optional.number,
                            step: t.optional.number
                        })(e).value
                    }

                    function rn(e) {
                        if (Array.isArray(e)) return e;
                        const t = [];
                        return Object.keys(e).forEach((n => {
                            t.push({
                                text: n,
                                value: e[n]
                            })
                        })), t
                    }

                    function sn(e) {
                        return o(e) ? null : new je(rn(e))
                    }

                    function an(e) {
                        const t = e ? We(e, je) : null;
                        return t ? t.options : null
                    }

                    function on(e, t) {
                        const n = e && We(e, Xe);
                        return n ? Vt(n.step) : Math.max(Vt(t), 2)
                    }

                    function ln(e) {
                        const t = function(e) {
                            const t = e ? We(e, Xe) : null;
                            return t ? t.step : null
                        }(e);
                        return null != t ? t : 1
                    }

                    function cn(e, t) {
                        var n;
                        const i = e && We(e, Xe),
                            r = Math.abs(null !== (n = null == i ? void 0 : i.step) && void 0 !== n ? n : t);
                        return 0 === r ? .1 : Math.pow(10, Math.floor(Math.log10(r)) - 1)
                    }
                    const hn = m("ckb");
                    class un {
                        constructor(e, t) {
                            this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(hn()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("label");
                            n.classList.add(hn("l")), this.element.appendChild(n);
                            const i = e.createElement("input");
                            i.classList.add(hn("i")), i.type = "checkbox", n.appendChild(i), this.inputElement = i, t.viewProps.bindDisabled(this.inputElement);
                            const r = e.createElement("div");
                            r.classList.add(hn("w")), n.appendChild(r);
                            const s = z(e, "check");
                            r.appendChild(s), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_()
                        }
                        update_() {
                            this.inputElement.checked = this.value.rawValue
                        }
                        onValueChange_() {
                            this.update_()
                        }
                    }
                    class dn {
                        constructor(e, t) {
                            this.onInputChange_ = this.onInputChange_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new un(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view.inputElement.addEventListener("change", this.onInputChange_)
                        }
                        onInputChange_(e) {
                            const t = e.currentTarget;
                            this.value.rawValue = t.checked
                        }
                    }
                    const pn = {
                            id: "input-bool",
                            type: "input",
                            accept: (e, t) => {
                                if ("boolean" != typeof e) return null;
                                const n = R(t, {
                                    options: P.optional.custom(en)
                                });
                                return n ? {
                                    initialValue: e,
                                    params: n
                                } : null
                            },
                            binding: {
                                reader: e => it,
                                constraint: e => function(e) {
                                    const t = [],
                                        n = sn(e.options);
                                    return n && t.push(n), new Ge(t)
                                }(e.params),
                                writer: e => $t
                            },
                            controller: e => {
                                var t;
                                const n = e.document,
                                    i = e.value,
                                    r = e.constraint;
                                return r && We(r, je) ? new Ke(n, {
                                    props: T.fromObject({
                                        options: null !== (t = an(r)) && void 0 !== t ? t : []
                                    }),
                                    value: i,
                                    viewProps: e.viewProps
                                }) : new dn(n, {
                                    value: i,
                                    viewProps: e.viewProps
                                })
                            }
                        },
                        fn = m("col");
                    class mn {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(fn()), t.foldable.bindExpandedClass(this.element, fn(void 0, "expanded")), x(t.foldable, "completed", w(this.element, fn(void 0, "cpl")));
                            const n = e.createElement("div");
                            n.classList.add(fn("h")), this.element.appendChild(n);
                            const i = e.createElement("div");
                            i.classList.add(fn("s")), n.appendChild(i), this.swatchElement = i;
                            const r = e.createElement("div");
                            if (r.classList.add(fn("t")), n.appendChild(r), this.textElement = r, "inline" === t.pickerLayout) {
                                const t = e.createElement("div");
                                t.classList.add(fn("p")), this.element.appendChild(t), this.pickerElement = t
                            } else this.pickerElement = null
                        }
                    }

                    function gn(e, t, n) {
                        const i = Gt(e, 360),
                            r = Ht(t / 100, 0, 1),
                            s = Ht(n / 100, 0, 1),
                            a = s * r,
                            o = a * (1 - Math.abs(i / 60 % 2 - 1)),
                            l = s - a;
                        let c, h, u;
                        return [c, h, u] = i >= 0 && i < 60 ? [a, o, 0] : i >= 60 && i < 120 ? [o, a, 0] : i >= 120 && i < 180 ? [0, a, o] : i >= 180 && i < 240 ? [0, o, a] : i >= 240 && i < 300 ? [o, 0, a] : [a, 0, o], [255 * (c + l), 255 * (h + l), 255 * (u + l)]
                    }

                    function vn(e) {
                        return [e[0], e[1], e[2]]
                    }

                    function xn(e, t) {
                        return [e[0], e[1], e[2], t]
                    }
                    const wn = {
                        hsl: {
                            hsl: (e, t, n) => [e, t, n],
                            hsv: function(e, t, n) {
                                const i = n + t * (100 - Math.abs(2 * n - 100)) / 200;
                                return [e, 0 !== i ? t * (100 - Math.abs(2 * n - 100)) / i : 0, n + t * (100 - Math.abs(2 * n - 100)) / 200]
                            },
                            rgb: function(e, t, n) {
                                const i = (e % 360 + 360) % 360,
                                    r = Ht(t / 100, 0, 1),
                                    s = Ht(n / 100, 0, 1),
                                    a = (1 - Math.abs(2 * s - 1)) * r,
                                    o = a * (1 - Math.abs(i / 60 % 2 - 1)),
                                    l = s - a / 2;
                                let c, h, u;
                                return [c, h, u] = i >= 0 && i < 60 ? [a, o, 0] : i >= 60 && i < 120 ? [o, a, 0] : i >= 120 && i < 180 ? [0, a, o] : i >= 180 && i < 240 ? [0, o, a] : i >= 240 && i < 300 ? [o, 0, a] : [a, 0, o], [255 * (c + l), 255 * (h + l), 255 * (u + l)]
                            }
                        },
                        hsv: {
                            hsl: function(e, t, n) {
                                const i = 100 - Math.abs(n * (200 - t) / 100 - 100);
                                return [e, 0 !== i ? t * n / i : 0, n * (200 - t) / 200]
                            },
                            hsv: (e, t, n) => [e, t, n],
                            rgb: gn
                        },
                        rgb: {
                            hsl: function(e, t, n) {
                                const i = Ht(e / 255, 0, 1),
                                    r = Ht(t / 255, 0, 1),
                                    s = Ht(n / 255, 0, 1),
                                    a = Math.max(i, r, s),
                                    o = Math.min(i, r, s),
                                    l = a - o;
                                let c = 0,
                                    h = 0;
                                const u = (o + a) / 2;
                                return 0 !== l && (h = l / (1 - Math.abs(a + o - 1)), c = i === a ? (r - s) / l : r === a ? 2 + (s - i) / l : 4 + (i - r) / l, c = c / 6 + (c < 0 ? 1 : 0)), [360 * c, 100 * h, 100 * u]
                            },
                            hsv: function(e, t, n) {
                                const i = Ht(e / 255, 0, 1),
                                    r = Ht(t / 255, 0, 1),
                                    s = Ht(n / 255, 0, 1),
                                    a = Math.max(i, r, s),
                                    o = a - Math.min(i, r, s);
                                let l;
                                return l = 0 === o ? 0 : a === i ? ((r - s) / o % 6 + 6) % 6 * 60 : a === r ? 60 * ((s - i) / o + 2) : 60 * ((i - r) / o + 4), [l, 100 * (0 === a ? 0 : o / a), 100 * a]
                            },
                            rgb: (e, t, n) => [e, t, n]
                        }
                    };

                    function bn(e, t) {
                        return ["float" === t ? 1 : "rgb" === e ? 255 : 360, "float" === t ? 1 : "rgb" === e ? 255 : 100, "float" === t ? 1 : "rgb" === e ? 255 : 100]
                    }

                    function _n(e, t, n, i) {
                        const r = bn(t, n),
                            s = bn(t, i);
                        return e.map(((e, t) => e / r[t] * s[t]))
                    }

                    function yn(e, t) {
                        return "object" == typeof e && !o(e) && t in e && "number" == typeof e[t]
                    }
                    class An {
                        constructor(e, t, n = "int") {
                            this.mode = t, this.type = n, this.comps_ = function(e, t, n) {
                                var i;
                                const r = bn(t, n);
                                return ["rgb" === t ? Ht(e[0], 0, r[0]) : Gt(e[0], r[0]), Ht(e[1], 0, r[1]), Ht(e[2], 0, r[2]), Ht(null !== (i = e[3]) && void 0 !== i ? i : 1, 0, 1)]
                            }(e, t, n)
                        }
                        static black(e = "int") {
                            return new An([0, 0, 0], "rgb", e)
                        }
                        static fromObject(e, t = "int") {
                            const n = "a" in e ? [e.r, e.g, e.b, e.a] : [e.r, e.g, e.b];
                            return new An(n, "rgb", t)
                        }
                        static toRgbaObject(e, t = "int") {
                            return e.toRgbaObject(t)
                        }
                        static isRgbColorObject(e) {
                            return yn(e, "r") && yn(e, "g") && yn(e, "b")
                        }
                        static isRgbaColorObject(e) {
                            return this.isRgbColorObject(e) && yn(e, "a")
                        }
                        static isColorObject(e) {
                            return this.isRgbColorObject(e)
                        }
                        static equals(e, t) {
                            if (e.mode !== t.mode) return !1;
                            const n = e.comps_,
                                i = t.comps_;
                            for (let e = 0; e < n.length; e++)
                                if (n[e] !== i[e]) return !1;
                            return !0
                        }
                        getComponents(e, t = "int") {
                            return xn(function(e, t, n) {
                                const i = _n(e, t.mode, t.type, "int");
                                return _n(wn[t.mode][n.mode](...i), n.mode, "int", n.type)
                            }(vn(this.comps_), {
                                mode: this.mode,
                                type: this.type
                            }, {
                                mode: null != e ? e : this.mode,
                                type: t
                            }), this.comps_[3])
                        }
                        toRgbaObject(e = "int") {
                            const t = this.getComponents("rgb", e);
                            return {
                                r: t[0],
                                g: t[1],
                                b: t[2],
                                a: t[3]
                            }
                        }
                    }
                    const Mn = m("colp");
                    class Sn {
                        constructor(e, t) {
                            this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(Mn());
                            const n = e.createElement("div");
                            n.classList.add(Mn("hsv"));
                            const i = e.createElement("div");
                            i.classList.add(Mn("sv")), this.svPaletteView_ = t.svPaletteView, i.appendChild(this.svPaletteView_.element), n.appendChild(i);
                            const r = e.createElement("div");
                            r.classList.add(Mn("h")), this.hPaletteView_ = t.hPaletteView, r.appendChild(this.hPaletteView_.element), n.appendChild(r), this.element.appendChild(n);
                            const s = e.createElement("div");
                            if (s.classList.add(Mn("rgb")), this.textView_ = t.textView, s.appendChild(this.textView_.element), this.element.appendChild(s), t.alphaViews) {
                                this.alphaViews_ = {
                                    palette: t.alphaViews.palette,
                                    text: t.alphaViews.text
                                };
                                const n = e.createElement("div");
                                n.classList.add(Mn("a"));
                                const i = e.createElement("div");
                                i.classList.add(Mn("ap")), i.appendChild(this.alphaViews_.palette.element), n.appendChild(i);
                                const r = e.createElement("div");
                                r.classList.add(Mn("at")), r.appendChild(this.alphaViews_.text.element), n.appendChild(r), this.element.appendChild(n)
                            }
                        }
                        get allFocusableElements() {
                            const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map((e => e.inputElement))];
                            return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e
                        }
                    }

                    function En(e) {
                        return "int" === e ? "int" : "float" === e ? "float" : void 0
                    }

                    function Tn(e) {
                        const t = P;
                        return R(e, {
                            alpha: t.optional.boolean,
                            color: t.optional.object({
                                alpha: t.optional.boolean,
                                type: t.optional.custom(En)
                            }),
                            expanded: t.optional.boolean,
                            picker: t.optional.custom(tn)
                        })
                    }

                    function Cn(e) {
                        return e ? .1 : 1
                    }

                    function Dn(e) {
                        var t;
                        return null === (t = e.color) || void 0 === t ? void 0 : t.type
                    }

                    function Pn(e, t) {
                        const n = e.match(/^(.+)%$/);
                        return n ? Math.min(.01 * parseFloat(n[1]) * t, t) : Math.min(parseFloat(e), t)
                    }
                    const Rn = {
                        deg: e => e,
                        grad: e => 360 * e / 400,
                        rad: e => 360 * e / (2 * Math.PI),
                        turn: e => 360 * e
                    };

                    function Ln(e) {
                        const t = e.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
                        if (!t) return parseFloat(e);
                        const n = parseFloat(t[1]),
                            i = t[2];
                        return Rn[i](n)
                    }

                    function In(e) {
                        const t = e.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [Pn(t[1], 255), Pn(t[2], 255), Pn(t[3], 255)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n
                    }

                    function Bn(e) {
                        return t => {
                            const n = In(t);
                            return n ? new An(n, "rgb", e) : null
                        }
                    }

                    function On(e) {
                        const t = e.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [Pn(t[1], 255), Pn(t[2], 255), Pn(t[3], 255), Pn(t[4], 1)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n
                    }

                    function kn(e) {
                        return t => {
                            const n = On(t);
                            return n ? new An(n, "rgb", e) : null
                        }
                    }

                    function Nn(e) {
                        const t = e.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [Ln(t[1]), Pn(t[2], 100), Pn(t[3], 100)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n
                    }

                    function Fn(e) {
                        return t => {
                            const n = Nn(t);
                            return n ? new An(n, "hsl", e) : null
                        }
                    }

                    function Un(e) {
                        const t = e.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [Ln(t[1]), Pn(t[2], 100), Pn(t[3], 100), Pn(t[4], 1)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n
                    }

                    function zn(e) {
                        return t => {
                            const n = Un(t);
                            return n ? new An(n, "hsl", e) : null
                        }
                    }

                    function Vn(e) {
                        const t = e.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
                        if (t) return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)];
                        const n = e.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
                        return n ? [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)] : null
                    }

                    function Hn(e) {
                        const t = e.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
                        if (t) return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16), zt(parseInt(t[4] + t[4], 16), 0, 255, 0, 1)];
                        const n = e.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
                        return n ? [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), zt(parseInt(n[4], 16), 0, 255, 0, 1)] : null
                    }

                    function Gn(e) {
                        const t = e.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
                        if (!t) return null;
                        const n = [parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n
                    }

                    function Wn(e) {
                        return t => {
                            const n = Gn(t);
                            return n ? new An(n, "rgb", e) : null
                        }
                    }

                    function jn(e) {
                        const t = e.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
                        if (!t) return null;
                        const n = [parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4])];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n
                    }

                    function Yn(e) {
                        return t => {
                            const n = jn(t);
                            return n ? new An(n, "rgb", e) : null
                        }
                    }
                    const Xn = [{
                        parser: Vn,
                        result: {
                            alpha: !1,
                            mode: "rgb",
                            notation: "hex"
                        }
                    }, {
                        parser: Hn,
                        result: {
                            alpha: !0,
                            mode: "rgb",
                            notation: "hex"
                        }
                    }, {
                        parser: In,
                        result: {
                            alpha: !1,
                            mode: "rgb",
                            notation: "func"
                        }
                    }, {
                        parser: On,
                        result: {
                            alpha: !0,
                            mode: "rgb",
                            notation: "func"
                        }
                    }, {
                        parser: Nn,
                        result: {
                            alpha: !1,
                            mode: "hsl",
                            notation: "func"
                        }
                    }, {
                        parser: Un,
                        result: {
                            alpha: !0,
                            mode: "hsl",
                            notation: "func"
                        }
                    }, {
                        parser: Gn,
                        result: {
                            alpha: !1,
                            mode: "rgb",
                            notation: "object"
                        }
                    }, {
                        parser: jn,
                        result: {
                            alpha: !0,
                            mode: "rgb",
                            notation: "object"
                        }
                    }];

                    function Qn(e, t = "int") {
                        const n = function(e) {
                            return Xn.reduce(((t, {
                                parser: n,
                                result: i
                            }) => t || (n(e) ? i : null)), null)
                        }(e);
                        return n ? "hex" === n.notation && "float" !== t ? Object.assign(Object.assign({}, n), {
                            type: "int"
                        }) : "func" === n.notation ? Object.assign(Object.assign({}, n), {
                            type: t
                        }) : null : null
                    }
                    const qn = {
                        int: [function(e) {
                            const t = Vn(e);
                            return t ? new An(t, "rgb", "int") : null
                        }, function(e) {
                            const t = Hn(e);
                            return t ? new An(t, "rgb", "int") : null
                        }, Bn("int"), kn("int"), Fn("int"), zn("int"), Wn("int"), Yn("int")],
                        float: [Bn("float"), kn("float"), Fn("float"), zn("float"), Wn("float"), Yn("float")]
                    };

                    function Kn(e) {
                        const t = qn[e];
                        return e => t.reduce(((t, n) => t || n(e)), null)
                    }

                    function Zn(e) {
                        const t = Ht(Math.floor(e), 0, 255).toString(16);
                        return 1 === t.length ? `0${t}` : t
                    }

                    function Jn(e, t = "#") {
                        return `${t}${vn(e.getComponents("rgb")).map(Zn).join("")}`
                    }

                    function $n(e, t = "#") {
                        const n = e.getComponents("rgb");
                        return `${t}${[n[0],n[1],n[2],255*n[3]].map(Zn).join("")}`
                    }

                    function ei(e, t) {
                        const n = St("float" === t ? 2 : 0);
                        return `rgb(${vn(e.getComponents("rgb",t)).map((e=>n(e))).join(", ")})`
                    }

                    function ti(e) {
                        return t => ei(t, e)
                    }

                    function ni(e, t) {
                        const n = St(2),
                            i = St("float" === t ? 2 : 0);
                        return `rgba(${e.getComponents("rgb",t).map(((e,t)=>(3===t?n:i)(e))).join(", ")})`
                    }

                    function ii(e) {
                        return t => ni(t, e)
                    }

                    function ri(e, t) {
                        const n = St("float" === t ? 2 : 0),
                            i = ["r", "g", "b"];
                        return `{${vn(e.getComponents("rgb",t)).map(((e,t)=>`${i[t]}: ${n(e)}`)).join(", ")}}`
                    }

                    function si(e) {
                        return t => ri(t, e)
                    }

                    function ai(e, t) {
                        const n = St(2),
                            i = St("float" === t ? 2 : 0),
                            r = ["r", "g", "b", "a"];
                        return `{${e.getComponents("rgb",t).map(((e,t)=>`${r[t]}: ${(3===t?n:i)(e)}`)).join(", ")}}`
                    }

                    function oi(e) {
                        return t => ai(t, e)
                    }
                    const li = [{
                        format: {
                            alpha: !1,
                            mode: "rgb",
                            notation: "hex",
                            type: "int"
                        },
                        stringifier: Jn
                    }, {
                        format: {
                            alpha: !0,
                            mode: "rgb",
                            notation: "hex",
                            type: "int"
                        },
                        stringifier: $n
                    }, {
                        format: {
                            alpha: !1,
                            mode: "hsl",
                            notation: "func",
                            type: "int"
                        },
                        stringifier: function(e) {
                            const t = [St(0), Tt, Tt];
                            return `hsl(${vn(e.getComponents("hsl")).map(((e,n)=>t[n](e))).join(", ")})`
                        }
                    }, {
                        format: {
                            alpha: !0,
                            mode: "hsl",
                            notation: "func",
                            type: "int"
                        },
                        stringifier: function(e) {
                            const t = [St(0), Tt, Tt, St(2)];
                            return `hsla(${e.getComponents("hsl").map(((e,n)=>t[n](e))).join(", ")})`
                        }
                    }, ...["int", "float"].reduce(((e, t) => [...e, {
                        format: {
                            alpha: !1,
                            mode: "rgb",
                            notation: "func",
                            type: t
                        },
                        stringifier: ti(t)
                    }, {
                        format: {
                            alpha: !0,
                            mode: "rgb",
                            notation: "func",
                            type: t
                        },
                        stringifier: ii(t)
                    }, {
                        format: {
                            alpha: !1,
                            mode: "rgb",
                            notation: "object",
                            type: t
                        },
                        stringifier: si(t)
                    }, {
                        format: {
                            alpha: !0,
                            mode: "rgb",
                            notation: "object",
                            type: t
                        },
                        stringifier: oi(t)
                    }]), [])];

                    function ci(e) {
                        return li.reduce(((t, n) => {
                            return t || (i = n.format, r = e, i.alpha === r.alpha && i.mode === r.mode && i.notation === r.notation && i.type === r.type ? n.stringifier : null);
                            var i, r
                        }), null)
                    }
                    const hi = m("apl");
                    class ui {
                        constructor(e, t) {
                            this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(hi()), t.viewProps.bindTabIndex(this.element);
                            const n = e.createElement("div");
                            n.classList.add(hi("b")), this.element.appendChild(n);
                            const i = e.createElement("div");
                            i.classList.add(hi("c")), n.appendChild(i), this.colorElem_ = i;
                            const r = e.createElement("div");
                            r.classList.add(hi("m")), this.element.appendChild(r), this.markerElem_ = r;
                            const s = e.createElement("div");
                            s.classList.add(hi("p")), this.markerElem_.appendChild(s), this.previewElem_ = s, this.update_()
                        }
                        update_() {
                            const e = this.value.rawValue,
                                t = e.getComponents("rgb"),
                                n = new An([t[0], t[1], t[2], 0], "rgb"),
                                i = new An([t[0], t[1], t[2], 255], "rgb"),
                                r = ["to right", ni(n), ni(i)];
                            this.colorElem_.style.background = `linear-gradient(${r.join(",")})`, this.previewElem_.style.backgroundColor = ni(e);
                            const s = zt(t[3], 0, 1, 0, 100);
                            this.markerElem_.style.left = `${s}%`
                        }
                        onValueChange_() {
                            this.update_()
                        }
                    }
                    class di {
                        constructor(e, t) {
                            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new ui(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.ptHandler_ = new Ut(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
                        }
                        handlePointerEvent_(e, t) {
                            if (!e.point) return;
                            const n = e.point.x / e.bounds.width,
                                i = this.value.rawValue,
                                [r, s, a] = i.getComponents("hsv");
                            this.value.setRawValue(new An([r, s, a, n], "hsv"), t)
                        }
                        onPointerDown_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerMove_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerUp_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                        onKeyDown_(e) {
                            const t = Bt(Cn(!0), kt(e));
                            if (0 === t) return;
                            const n = this.value.rawValue,
                                [i, r, s, a] = n.getComponents("hsv");
                            this.value.setRawValue(new An([i, r, s, a + t], "hsv"), {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onKeyUp_(e) {
                            0 !== Bt(Cn(!0), kt(e)) && this.value.setRawValue(this.value.rawValue, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                    }
                    const pi = m("coltxt");
                    class fi {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(pi());
                            const n = e.createElement("div");
                            n.classList.add(pi("m")), this.modeElem_ = function(e) {
                                const t = e.createElement("select");
                                return t.appendChild([{
                                    text: "RGB",
                                    value: "rgb"
                                }, {
                                    text: "HSL",
                                    value: "hsl"
                                }, {
                                    text: "HSV",
                                    value: "hsv"
                                }].reduce(((t, n) => {
                                    const i = e.createElement("option");
                                    return i.textContent = n.text, i.value = n.value, t.appendChild(i), t
                                }), e.createDocumentFragment())), t
                            }(e), this.modeElem_.classList.add(pi("ms")), n.appendChild(this.modeSelectElement);
                            const i = e.createElement("div");
                            i.classList.add(pi("mm")), i.appendChild(z(e, "dropdown")), n.appendChild(i), this.element.appendChild(n);
                            const r = e.createElement("div");
                            r.classList.add(pi("w")), this.element.appendChild(r), this.textsElem_ = r, this.textViews_ = t.textViews, this.applyTextViews_(), v(t.colorMode, (e => {
                                this.modeElem_.value = e
                            }))
                        }
                        get modeSelectElement() {
                            return this.modeElem_
                        }
                        get textViews() {
                            return this.textViews_
                        }
                        set textViews(e) {
                            this.textViews_ = e, this.applyTextViews_()
                        }
                        applyTextViews_() {
                            G(this.textsElem_);
                            const e = this.element.ownerDocument;
                            this.textViews_.forEach((t => {
                                const n = e.createElement("div");
                                n.classList.add(pi("c")), n.appendChild(t.element), this.textsElem_.appendChild(n)
                            }))
                        }
                    }

                    function mi(e, t, n) {
                        const i = bn(e, t)[n];
                        return new Ye({
                            min: 0,
                            max: i
                        })
                    }

                    function gi(e, t, n) {
                        return new Yt(e, {
                            arrayPosition: 0 === n ? "fst" : 2 === n ? "lst" : "mid",
                            baseStep: Cn(!1),
                            parser: t.parser,
                            props: T.fromObject({
                                draggingScale: "float" === t.colorType ? .01 : 1,
                                formatter: (i = t.colorType, St("float" === i ? 2 : 0))
                            }),
                            value: E(0, {
                                constraint: mi(t.colorMode, t.colorType, n)
                            }),
                            viewProps: t.viewProps
                        });
                        var i
                    }
                    class vi {
                        constructor(e, t) {
                            this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t.colorType, this.parser_ = t.parser, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = E(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new fi(e, {
                                colorMode: this.colorMode,
                                textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
                            }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
                        }
                        createComponentControllers_(e) {
                            const t = {
                                    colorMode: this.colorMode.rawValue,
                                    colorType: this.colorType_,
                                    parser: this.parser_,
                                    viewProps: this.viewProps
                                },
                                n = [gi(e, t, 0), gi(e, t, 1), gi(e, t, 2)];
                            return n.forEach(((e, t) => {
                                It({
                                    primary: this.value,
                                    secondary: e.value,
                                    forward: e => e.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[t],
                                    backward: (e, n) => {
                                        const i = this.colorMode.rawValue,
                                            r = e.rawValue.getComponents(i, this.colorType_);
                                        return r[t] = n.rawValue, new An(xn(vn(r), r[3]), i, this.colorType_)
                                    }
                                })
                            })), n
                        }
                        onModeSelectChange_(e) {
                            const t = e.currentTarget;
                            this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
                        }
                    }
                    const xi = m("hpl");
                    class wi {
                        constructor(e, t) {
                            this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(xi()), t.viewProps.bindTabIndex(this.element);
                            const n = e.createElement("div");
                            n.classList.add(xi("c")), this.element.appendChild(n);
                            const i = e.createElement("div");
                            i.classList.add(xi("m")), this.element.appendChild(i), this.markerElem_ = i, this.update_()
                        }
                        update_() {
                            const e = this.value.rawValue,
                                [t] = e.getComponents("hsv");
                            this.markerElem_.style.backgroundColor = ei(new An([t, 100, 100], "hsv"));
                            const n = zt(t, 0, 360, 0, 100);
                            this.markerElem_.style.left = `${n}%`
                        }
                        onValueChange_() {
                            this.update_()
                        }
                    }
                    class bi {
                        constructor(e, t) {
                            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new wi(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.ptHandler_ = new Ut(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
                        }
                        handlePointerEvent_(e, t) {
                            if (!e.point) return;
                            const n = zt(Ht(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 359),
                                i = this.value.rawValue,
                                [, r, s, a] = i.getComponents("hsv");
                            this.value.setRawValue(new An([n, r, s, a], "hsv"), t)
                        }
                        onPointerDown_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerMove_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerUp_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                        onKeyDown_(e) {
                            const t = Bt(Cn(!1), kt(e));
                            if (0 === t) return;
                            const n = this.value.rawValue,
                                [i, r, s, a] = n.getComponents("hsv");
                            this.value.setRawValue(new An([i + t, r, s, a], "hsv"), {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onKeyUp_(e) {
                            0 !== Bt(Cn(!1), kt(e)) && this.value.setRawValue(this.value.rawValue, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                    }
                    const _i = m("svp");
                    class yi {
                        constructor(e, t) {
                            this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(_i()), t.viewProps.bindTabIndex(this.element);
                            const n = e.createElement("canvas");
                            n.height = 64, n.width = 64, n.classList.add(_i("c")), this.element.appendChild(n), this.canvasElement = n;
                            const i = e.createElement("div");
                            i.classList.add(_i("m")), this.element.appendChild(i), this.markerElem_ = i, this.update_()
                        }
                        update_() {
                            const e = function(e) {
                                const t = e.ownerDocument.defaultView;
                                return t && "document" in t ? e.getContext("2d") : null
                            }(this.canvasElement);
                            if (!e) return;
                            const t = this.value.rawValue.getComponents("hsv"),
                                n = this.canvasElement.width,
                                i = this.canvasElement.height,
                                r = e.getImageData(0, 0, n, i),
                                s = r.data;
                            for (let e = 0; e < i; e++)
                                for (let r = 0; r < n; r++) {
                                    const a = zt(r, 0, n, 0, 100),
                                        o = zt(e, 0, i, 100, 0),
                                        l = gn(t[0], a, o),
                                        c = 4 * (e * n + r);
                                    s[c] = l[0], s[c + 1] = l[1], s[c + 2] = l[2], s[c + 3] = 255
                                }
                            e.putImageData(r, 0, 0);
                            const a = zt(t[1], 0, 100, 0, 100);
                            this.markerElem_.style.left = `${a}%`;
                            const o = zt(t[2], 0, 100, 100, 0);
                            this.markerElem_.style.top = `${o}%`
                        }
                        onValueChange_() {
                            this.update_()
                        }
                    }
                    class Ai {
                        constructor(e, t) {
                            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new yi(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.ptHandler_ = new Ut(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
                        }
                        handlePointerEvent_(e, t) {
                            if (!e.point) return;
                            const n = zt(e.point.x, 0, e.bounds.width, 0, 100),
                                i = zt(e.point.y, 0, e.bounds.height, 100, 0),
                                [r, , , s] = this.value.rawValue.getComponents("hsv");
                            this.value.setRawValue(new An([r, n, i, s], "hsv"), t)
                        }
                        onPointerDown_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerMove_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerUp_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                        onKeyDown_(e) {
                            Nt(e.key) && e.preventDefault();
                            const [t, n, i, r] = this.value.rawValue.getComponents("hsv"), s = Cn(!1), a = Bt(s, kt(e)), o = Bt(s, Ot(e));
                            0 === a && 0 === o || this.value.setRawValue(new An([t, n + a, i + o, r], "hsv"), {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onKeyUp_(e) {
                            const t = Cn(!1),
                                n = Bt(t, kt(e)),
                                i = Bt(t, Ot(e));
                            0 === n && 0 === i || this.value.setRawValue(this.value.rawValue, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                    }
                    class Mi {
                        constructor(e, t) {
                            this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new bi(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.svPaletteC_ = new Ai(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.alphaIcs_ = t.supportsAlpha ? {
                                palette: new di(e, {
                                    value: this.value,
                                    viewProps: this.viewProps
                                }),
                                text: new Yt(e, {
                                    parser: yt,
                                    baseStep: .1,
                                    props: T.fromObject({
                                        draggingScale: .01,
                                        formatter: St(2)
                                    }),
                                    value: E(0, {
                                        constraint: new Ye({
                                            min: 0,
                                            max: 1
                                        })
                                    }),
                                    viewProps: this.viewProps
                                })
                            } : null, this.alphaIcs_ && It({
                                primary: this.value,
                                secondary: this.alphaIcs_.text.value,
                                forward: e => e.rawValue.getComponents()[3],
                                backward: (e, t) => {
                                    const n = e.rawValue.getComponents();
                                    return n[3] = t.rawValue, new An(n, e.rawValue.mode)
                                }
                            }), this.textC_ = new vi(e, {
                                colorType: t.colorType,
                                parser: yt,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view = new Sn(e, {
                                alphaViews: this.alphaIcs_ ? {
                                    palette: this.alphaIcs_.palette.view,
                                    text: this.alphaIcs_.text.view
                                } : null,
                                hPaletteView: this.hPaletteC_.view,
                                supportsAlpha: t.supportsAlpha,
                                svPaletteView: this.svPaletteC_.view,
                                textView: this.textC_.view
                            })
                        }
                        get textController() {
                            return this.textC_
                        }
                    }
                    const Si = m("colsw");
                    class Ei {
                        constructor(e, t) {
                            this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(Si()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("div");
                            n.classList.add(Si("sw")), this.element.appendChild(n), this.swatchElem_ = n;
                            const i = e.createElement("button");
                            i.classList.add(Si("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i, this.update_()
                        }
                        update_() {
                            const e = this.value.rawValue;
                            this.swatchElem_.style.backgroundColor = $n(e)
                        }
                        onValueChange_() {
                            this.update_()
                        }
                    }
                    class Ti {
                        constructor(e, t) {
                            this.value = t.value, this.viewProps = t.viewProps, this.view = new Ei(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            })
                        }
                    }
                    class Ci {
                        constructor(e, t) {
                            this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Z.create(t.expanded), this.swatchC_ = new Ti(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            });
                            const n = this.swatchC_.view.buttonElement;
                            n.addEventListener("blur", this.onButtonBlur_), n.addEventListener("click", this.onButtonClick_), this.textC_ = new nt(e, {
                                parser: t.parser,
                                props: T.fromObject({
                                    formatter: t.formatter
                                }),
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view = new mn(e, {
                                foldable: this.foldable_,
                                pickerLayout: t.pickerLayout
                            }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === t.pickerLayout ? new $e(e, {
                                viewProps: this.viewProps
                            }) : null;
                            const i = new Mi(e, {
                                colorType: t.colorType,
                                supportsAlpha: t.supportsAlpha,
                                value: this.value,
                                viewProps: this.viewProps
                            });
                            i.view.allFocusableElements.forEach((e => {
                                e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_)
                            })), this.pickerC_ = i, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(i.view.element), It({
                                primary: this.foldable_.value("expanded"),
                                secondary: this.popC_.shows,
                                forward: e => e.rawValue,
                                backward: (e, t) => t.rawValue
                            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $(this.foldable_, this.view.pickerElement))
                        }
                        get textController() {
                            return this.textC_
                        }
                        onButtonBlur_(e) {
                            if (!this.popC_) return;
                            const t = this.view.element,
                                n = e.relatedTarget;
                            n && t.contains(n) || (this.popC_.shows.rawValue = !1)
                        }
                        onButtonClick_() {
                            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
                        }
                        onPopupChildBlur_(e) {
                            if (!this.popC_) return;
                            const t = this.popC_.view.element,
                                n = W(e);
                            n && t.contains(n) || n && n === this.swatchC_.view.buttonElement && !N(t.ownerDocument) || (this.popC_.shows.rawValue = !1)
                        }
                        onPopupChildKeydown_(e) {
                            this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.swatchC_.view.buttonElement.focus()
                        }
                    }

                    function Di(e) {
                        return vn(e.getComponents("rgb")).reduce(((e, t) => e << 8 | 255 & Math.floor(t)), 0)
                    }

                    function Pi(e) {
                        return e.getComponents("rgb").reduce(((e, t, n) => e << 8 | 255 & Math.floor(3 === n ? 255 * t : t)), 0) >>> 0
                    }

                    function Ri(e) {
                        return "number" != typeof e ? An.black() : new An([(t = e) >> 16 & 255, t >> 8 & 255, 255 & t], "rgb");
                        var t
                    }

                    function Li(e) {
                        return "number" != typeof e ? An.black() : new An([(t = e) >> 24 & 255, t >> 16 & 255, t >> 8 & 255, zt(255 & t, 0, 255, 0, 1)], "rgb");
                        var t
                    }

                    function Ii(e) {
                        var t;
                        return !(!(null == e ? void 0 : e.alpha) && !(null === (t = null == e ? void 0 : e.color) || void 0 === t ? void 0 : t.alpha))
                    }

                    function Bi(e) {
                        return e ? e => $n(e, "0x") : e => Jn(e, "0x")
                    }
                    const Oi = {
                        id: "input-color-number",
                        type: "input",
                        accept: (e, t) => {
                            if ("number" != typeof e) return null;
                            if (! function(e) {
                                    return "color" in e || "view" in e && "color" === e.view
                                }(t)) return null;
                            const n = Tn(t);
                            return n ? {
                                initialValue: e,
                                params: n
                            } : null
                        },
                        binding: {
                            reader: e => Ii(e.params) ? Li : Ri,
                            equals: An.equals,
                            writer: e => function(e) {
                                const t = e ? Pi : Di;
                                return (e, n) => {
                                    $t(e, t(n))
                                }
                            }(Ii(e.params))
                        },
                        controller: e => {
                            const t = Ii(e.params),
                                n = "expanded" in e.params ? e.params.expanded : void 0,
                                i = "picker" in e.params ? e.params.picker : void 0;
                            return new Ci(e.document, {
                                colorType: "int",
                                expanded: null != n && n,
                                formatter: Bi(t),
                                parser: Kn("int"),
                                pickerLayout: null != i ? i : "popup",
                                supportsAlpha: t,
                                value: e.value,
                                viewProps: e.viewProps
                            })
                        }
                    };

                    function ki(e) {
                        return t => function(e, t) {
                            return An.isColorObject(e) ? An.fromObject(e, t) : An.black(t)
                        }(t, e)
                    }

                    function Ni(e, t) {
                        return n => e ? ai(n, t) : ri(n, t)
                    }
                    const Fi = {
                            id: "input-color-object",
                            type: "input",
                            accept: (e, t) => {
                                if (!An.isColorObject(e)) return null;
                                const n = Tn(t);
                                return n ? {
                                    initialValue: e,
                                    params: n
                                } : null
                            },
                            binding: {
                                reader: e => ki(Dn(e.params)),
                                equals: An.equals,
                                writer: e => {
                                    return i = e.initialValue, t = An.isRgbaColorObject(i), n = Dn(e.params), (e, i) => {
                                        t ? function(e, t, n) {
                                            const i = t.toRgbaObject(n);
                                            e.writeProperty("r", i.r), e.writeProperty("g", i.g), e.writeProperty("b", i.b), e.writeProperty("a", i.a)
                                        }(e, i, n) : function(e, t, n) {
                                            const i = t.toRgbaObject(n);
                                            e.writeProperty("r", i.r), e.writeProperty("g", i.g), e.writeProperty("b", i.b)
                                        }(e, i, n)
                                    };
                                    var t, n, i
                                }
                            },
                            controller: e => {
                                var t;
                                const n = An.isRgbaColorObject(e.initialValue),
                                    i = "expanded" in e.params ? e.params.expanded : void 0,
                                    r = "picker" in e.params ? e.params.picker : void 0,
                                    s = null !== (t = Dn(e.params)) && void 0 !== t ? t : "int";
                                return new Ci(e.document, {
                                    colorType: s,
                                    expanded: null != i && i,
                                    formatter: Ni(n, s),
                                    parser: Kn(s),
                                    pickerLayout: null != r ? r : "popup",
                                    supportsAlpha: n,
                                    value: e.value,
                                    viewProps: e.viewProps
                                })
                            }
                        },
                        Ui = {
                            id: "input-color-string",
                            type: "input",
                            accept: (e, t) => {
                                if ("string" != typeof e) return null;
                                if ("view" in t && "text" === t.view) return null;
                                const n = Qn(e, Dn(t));
                                if (!n) return null;
                                if (!ci(n)) return null;
                                const i = Tn(t);
                                return i ? {
                                    initialValue: e,
                                    params: i
                                } : null
                            },
                            binding: {
                                reader: e => {
                                    var t;
                                    return function(e) {
                                        const t = qn[e];
                                        return n => {
                                            if ("string" != typeof n) return An.black(e);
                                            const i = t.reduce(((e, t) => e || t(n)), null);
                                            return null != i ? i : An.black(e)
                                        }
                                    }(null !== (t = Dn(e.params)) && void 0 !== t ? t : "int")
                                },
                                equals: An.equals,
                                writer: e => {
                                    const t = Qn(e.initialValue, Dn(e.params));
                                    if (!t) throw h.shouldNeverHappen();
                                    const n = function(e) {
                                        const t = ci(e);
                                        return t ? (e, n) => {
                                            $t(e, t(n))
                                        } : null
                                    }(t);
                                    if (!n) throw h.notBindable();
                                    return n
                                }
                            },
                            controller: e => {
                                const t = Qn(e.initialValue, Dn(e.params));
                                if (!t) throw h.shouldNeverHappen();
                                const n = ci(t);
                                if (!n) throw h.shouldNeverHappen();
                                const i = "expanded" in e.params ? e.params.expanded : void 0,
                                    r = "picker" in e.params ? e.params.picker : void 0;
                                return new Ci(e.document, {
                                    colorType: t.type,
                                    expanded: null != i && i,
                                    formatter: n,
                                    parser: Kn(t.type),
                                    pickerLayout: null != r ? r : "popup",
                                    supportsAlpha: t.alpha,
                                    value: e.value,
                                    viewProps: e.viewProps
                                })
                            }
                        };
                    class zi {
                        constructor(e) {
                            this.components = e.components, this.asm_ = e.assembly
                        }
                        constrain(e) {
                            const t = this.asm_.toComponents(e).map(((e, t) => {
                                var n, i;
                                return null !== (i = null === (n = this.components[t]) || void 0 === n ? void 0 : n.constrain(e)) && void 0 !== i ? i : e
                            }));
                            return this.asm_.fromComponents(t)
                        }
                    }
                    const Vi = m("pndtxt");
                    class Hi {
                        constructor(e, t) {
                            this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(Vi()), this.textViews.forEach((t => {
                                const n = e.createElement("div");
                                n.classList.add(Vi("a")), n.appendChild(t.element), this.element.appendChild(n)
                            }))
                        }
                    }
                    class Gi {
                        constructor(e, t) {
                            this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map(((n, i) => function(e, t, n) {
                                return new Yt(e, {
                                    arrayPosition: 0 === n ? "fst" : n === t.axes.length - 1 ? "lst" : "mid",
                                    baseStep: t.axes[n].baseStep,
                                    parser: t.parser,
                                    props: t.axes[n].textProps,
                                    value: E(0, {
                                        constraint: t.axes[n].constraint
                                    }),
                                    viewProps: t.viewProps
                                })
                            }(e, t, i))), this.acs_.forEach(((e, n) => {
                                It({
                                    primary: this.value,
                                    secondary: e.value,
                                    forward: e => t.assembly.toComponents(e.rawValue)[n],
                                    backward: (e, i) => {
                                        const r = t.assembly.toComponents(e.rawValue);
                                        return r[n] = i.rawValue, t.assembly.fromComponents(r)
                                    }
                                })
                            })), this.view = new Hi(e, {
                                textViews: this.acs_.map((e => e.view))
                            })
                        }
                    }

                    function Wi(e, t) {
                        return "step" in e && !o(e.step) ? new Xe(e.step, t) : null
                    }

                    function ji(e) {
                        return "max" in e && !o(e.max) || "min" in e && !o(e.min) ? new Ye({
                            max: e.max,
                            min: e.min
                        }) : null
                    }

                    function Yi(e) {
                        const [t, n] = function(e) {
                            const t = e ? We(e, Ye) : null;
                            return t ? [t.minValue, t.maxValue] : [void 0, void 0]
                        }(e);
                        return [null != t ? t : 0, null != n ? n : 100]
                    }
                    const Xi = {
                        id: "input-number",
                        type: "input",
                        accept: (e, t) => {
                            if ("number" != typeof e) return null;
                            const n = P,
                                i = R(t, {
                                    format: n.optional.function,
                                    max: n.optional.number,
                                    min: n.optional.number,
                                    options: n.optional.custom(en),
                                    step: n.optional.number
                                });
                            return i ? {
                                initialValue: e,
                                params: i
                            } : null
                        },
                        binding: {
                            reader: e => At,
                            constraint: e => function(e, t) {
                                const n = [],
                                    i = Wi(e, t);
                                i && n.push(i);
                                const r = ji(e);
                                r && n.push(r);
                                const s = sn(e.options);
                                return s && n.push(s), new Ge(n)
                            }(e.params, e.initialValue),
                            writer: e => $t
                        },
                        controller: e => {
                            var t, n;
                            const i = e.value,
                                r = e.constraint;
                            if (r && We(r, je)) return new Ke(e.document, {
                                props: T.fromObject({
                                    options: null !== (t = an(r)) && void 0 !== t ? t : []
                                }),
                                value: i,
                                viewProps: e.viewProps
                            });
                            const s = null !== (n = "format" in e.params ? e.params.format : void 0) && void 0 !== n ? n : St(on(r, i.rawValue));
                            if (r && We(r, Ye)) {
                                const [t, n] = Yi(r);
                                return new Jt(e.document, {
                                    baseStep: ln(r),
                                    parser: yt,
                                    sliderProps: T.fromObject({
                                        maxValue: n,
                                        minValue: t
                                    }),
                                    textProps: T.fromObject({
                                        draggingScale: cn(r, i.rawValue),
                                        formatter: s
                                    }),
                                    value: i,
                                    viewProps: e.viewProps
                                })
                            }
                            return new Yt(e.document, {
                                baseStep: ln(r),
                                parser: yt,
                                props: T.fromObject({
                                    draggingScale: cn(r, i.rawValue),
                                    formatter: s
                                }),
                                value: i,
                                viewProps: e.viewProps
                            })
                        }
                    };
                    class Qi {
                        constructor(e = 0, t = 0) {
                            this.x = e, this.y = t
                        }
                        getComponents() {
                            return [this.x, this.y]
                        }
                        static isObject(e) {
                            if (o(e)) return !1;
                            const t = e.x,
                                n = e.y;
                            return "number" == typeof t && "number" == typeof n
                        }
                        static equals(e, t) {
                            return e.x === t.x && e.y === t.y
                        }
                        toObject() {
                            return {
                                x: this.x,
                                y: this.y
                            }
                        }
                    }
                    const qi = {
                            toComponents: e => e.getComponents(),
                            fromComponents: e => new Qi(...e)
                        },
                        Ki = m("p2d");
                    class Zi {
                        constructor(e, t) {
                            this.element = e.createElement("div"), this.element.classList.add(Ki()), t.viewProps.bindClassModifiers(this.element), v(t.expanded, w(this.element, Ki(void 0, "expanded")));
                            const n = e.createElement("div");
                            n.classList.add(Ki("h")), this.element.appendChild(n);
                            const i = e.createElement("button");
                            i.classList.add(Ki("b")), i.appendChild(z(e, "p2dpad")), t.viewProps.bindDisabled(i), n.appendChild(i), this.buttonElement = i;
                            const r = e.createElement("div");
                            if (r.classList.add(Ki("t")), n.appendChild(r), this.textElement = r, "inline" === t.pickerLayout) {
                                const t = e.createElement("div");
                                t.classList.add(Ki("p")), this.element.appendChild(t), this.pickerElement = t
                            } else this.pickerElement = null
                        }
                    }
                    const Ji = m("p2dp");
                    class $i {
                        constructor(e, t) {
                            this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t.invertsY, this.maxValue_ = t.maxValue, this.element = e.createElement("div"), this.element.classList.add(Ji()), "popup" === t.layout && this.element.classList.add(Ji(void 0, "p"));
                            const n = e.createElement("div");
                            n.classList.add(Ji("p")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.padElement = n;
                            const i = e.createElementNS(O, "svg");
                            i.classList.add(Ji("g")), this.padElement.appendChild(i), this.svgElem_ = i;
                            const r = e.createElementNS(O, "line");
                            r.classList.add(Ji("ax")), r.setAttributeNS(null, "x1", "0"), r.setAttributeNS(null, "y1", "50%"), r.setAttributeNS(null, "x2", "100%"), r.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(r);
                            const s = e.createElementNS(O, "line");
                            s.classList.add(Ji("ax")), s.setAttributeNS(null, "x1", "50%"), s.setAttributeNS(null, "y1", "0"), s.setAttributeNS(null, "x2", "50%"), s.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s);
                            const a = e.createElementNS(O, "line");
                            a.classList.add(Ji("l")), a.setAttributeNS(null, "x1", "50%"), a.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(a), this.lineElem_ = a;
                            const o = e.createElement("div");
                            o.classList.add(Ji("m")), this.padElement.appendChild(o), this.markerElem_ = o, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_()
                        }
                        get allFocusableElements() {
                            return [this.padElement]
                        }
                        update_() {
                            const [e, t] = this.value.rawValue.getComponents(), n = this.maxValue_, i = zt(e, -n, +n, 0, 100), r = zt(t, -n, +n, 0, 100), s = this.invertsY_ ? 100 - r : r;
                            this.lineElem_.setAttributeNS(null, "x2", `${i}%`), this.lineElem_.setAttributeNS(null, "y2", `${s}%`), this.markerElem_.style.left = `${i}%`, this.markerElem_.style.top = `${s}%`
                        }
                        onValueChange_() {
                            this.update_()
                        }
                        onFoldableChange_() {
                            this.update_()
                        }
                    }

                    function er(e, t, n) {
                        return [Bt(t[0], kt(e)), Bt(t[1], Ot(e)) * (n ? 1 : -1)]
                    }
                    class tr {
                        constructor(e, t) {
                            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.baseSteps_ = t.baseSteps, this.maxValue_ = t.maxValue, this.invertsY_ = t.invertsY, this.view = new $i(e, {
                                invertsY: this.invertsY_,
                                layout: t.layout,
                                maxValue: this.maxValue_,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.ptHandler_ = new Ut(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
                        }
                        handlePointerEvent_(e, t) {
                            if (!e.point) return;
                            const n = this.maxValue_,
                                i = zt(e.point.x, 0, e.bounds.width, -n, +n),
                                r = zt(this.invertsY_ ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -n, +n);
                            this.value.setRawValue(new Qi(i, r), t)
                        }
                        onPointerDown_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerMove_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPointerUp_(e) {
                            this.handlePointerEvent_(e.data, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                        onPadKeyDown_(e) {
                            Nt(e.key) && e.preventDefault();
                            const [t, n] = er(e, this.baseSteps_, this.invertsY_);
                            0 === t && 0 === n || this.value.setRawValue(new Qi(this.value.rawValue.x + t, this.value.rawValue.y + n), {
                                forceEmit: !1,
                                last: !1
                            })
                        }
                        onPadKeyUp_(e) {
                            const [t, n] = er(e, this.baseSteps_, this.invertsY_);
                            0 === t && 0 === n || this.value.setRawValue(this.value.rawValue, {
                                forceEmit: !0,
                                last: !0
                            })
                        }
                    }
                    class nr {
                        constructor(e, t) {
                            var n, i;
                            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Z.create(t.expanded), this.popC_ = "popup" === t.pickerLayout ? new $e(e, {
                                viewProps: this.viewProps
                            }) : null;
                            const r = new tr(e, {
                                baseSteps: [t.axes[0].baseStep, t.axes[1].baseStep],
                                invertsY: t.invertsY,
                                layout: t.pickerLayout,
                                maxValue: t.maxValue,
                                value: this.value,
                                viewProps: this.viewProps
                            });
                            r.view.allFocusableElements.forEach((e => {
                                e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_)
                            })), this.pickerC_ = r, this.textC_ = new Gi(e, {
                                assembly: qi,
                                axes: t.axes,
                                parser: t.parser,
                                value: this.value,
                                viewProps: this.viewProps
                            }), this.view = new Zi(e, {
                                expanded: this.foldable_.value("expanded"),
                                pickerLayout: t.pickerLayout,
                                viewProps: this.viewProps
                            }), this.view.textElement.appendChild(this.textC_.view.element), null === (n = this.view.buttonElement) || void 0 === n || n.addEventListener("blur", this.onPadButtonBlur_), null === (i = this.view.buttonElement) || void 0 === i || i.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), It({
                                primary: this.foldable_.value("expanded"),
                                secondary: this.popC_.shows,
                                forward: e => e.rawValue,
                                backward: (e, t) => t.rawValue
                            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $(this.foldable_, this.view.pickerElement))
                        }
                        onPadButtonBlur_(e) {
                            if (!this.popC_) return;
                            const t = this.view.element,
                                n = e.relatedTarget;
                            n && t.contains(n) || (this.popC_.shows.rawValue = !1)
                        }
                        onPadButtonClick_() {
                            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
                        }
                        onPopupChildBlur_(e) {
                            if (!this.popC_) return;
                            const t = this.popC_.view.element,
                                n = W(e);
                            n && t.contains(n) || n && n === this.view.buttonElement && !N(t.ownerDocument) || (this.popC_.shows.rawValue = !1)
                        }
                        onPopupChildKeydown_(e) {
                            this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.view.buttonElement.focus()
                        }
                    }

                    function ir(e) {
                        return Qi.isObject(e) ? new Qi(e.x, e.y) : new Qi
                    }

                    function rr(e, t) {
                        e.writeProperty("x", t.x), e.writeProperty("y", t.y)
                    }

                    function sr(e, t) {
                        if (!e) return;
                        const n = [],
                            i = Wi(e, t);
                        i && n.push(i);
                        const r = ji(e);
                        return r && n.push(r), new Ge(n)
                    }

                    function ar(e, t) {
                        var n, i;
                        const r = e && We(e, Ye);
                        if (r) return Math.max(Math.abs(null !== (n = r.minValue) && void 0 !== n ? n : 0), Math.abs(null !== (i = r.maxValue) && void 0 !== i ? i : 0));
                        const s = ln(e);
                        return Math.max(10 * Math.abs(s), 10 * Math.abs(t))
                    }

                    function or(e, t) {
                        const n = t instanceof zi ? t.components[0] : void 0,
                            i = t instanceof zi ? t.components[1] : void 0,
                            r = ar(n, e.x),
                            s = ar(i, e.y);
                        return Math.max(r, s)
                    }

                    function lr(e, t) {
                        return {
                            baseStep: ln(t),
                            constraint: t,
                            textProps: T.fromObject({
                                draggingScale: cn(t, e),
                                formatter: St(on(t, e))
                            })
                        }
                    }

                    function cr(e) {
                        if (!("y" in e)) return !1;
                        const t = e.y;
                        return !!t && "inverted" in t && !!t.inverted
                    }
                    const hr = {
                        id: "input-point2d",
                        type: "input",
                        accept: (e, t) => {
                            if (!Qi.isObject(e)) return null;
                            const n = P,
                                i = R(t, {
                                    expanded: n.optional.boolean,
                                    picker: n.optional.custom(tn),
                                    x: n.optional.custom(nn),
                                    y: n.optional.object({
                                        inverted: n.optional.boolean,
                                        max: n.optional.number,
                                        min: n.optional.number,
                                        step: n.optional.number
                                    })
                                });
                            return i ? {
                                initialValue: e,
                                params: i
                            } : null
                        },
                        binding: {
                            reader: e => ir,
                            constraint: e => {
                                return t = e.params, n = e.initialValue, new zi({
                                    assembly: qi,
                                    components: [sr("x" in t ? t.x : void 0, n.x), sr("y" in t ? t.y : void 0, n.y)]
                                });
                                var t, n
                            },
                            equals: Qi.equals,
                            writer: e => rr
                        },
                        controller: e => {
                            const t = e.document,
                                n = e.value,
                                i = e.constraint;
                            if (!(i instanceof zi)) throw h.shouldNeverHappen();
                            const r = "expanded" in e.params ? e.params.expanded : void 0,
                                s = "picker" in e.params ? e.params.picker : void 0;
                            return new nr(t, {
                                axes: [lr(n.rawValue.x, i.components[0]), lr(n.rawValue.y, i.components[1])],
                                expanded: null != r && r,
                                invertsY: cr(e.params),
                                maxValue: or(n.rawValue, i),
                                parser: yt,
                                pickerLayout: null != s ? s : "popup",
                                value: n,
                                viewProps: e.viewProps
                            })
                        }
                    };
                    class ur {
                        constructor(e = 0, t = 0, n = 0) {
                            this.x = e, this.y = t, this.z = n
                        }
                        getComponents() {
                            return [this.x, this.y, this.z]
                        }
                        static isObject(e) {
                            if (o(e)) return !1;
                            const t = e.x,
                                n = e.y,
                                i = e.z;
                            return "number" == typeof t && "number" == typeof n && "number" == typeof i
                        }
                        static equals(e, t) {
                            return e.x === t.x && e.y === t.y && e.z === t.z
                        }
                        toObject() {
                            return {
                                x: this.x,
                                y: this.y,
                                z: this.z
                            }
                        }
                    }
                    const dr = {
                        toComponents: e => e.getComponents(),
                        fromComponents: e => new ur(...e)
                    };

                    function pr(e) {
                        return ur.isObject(e) ? new ur(e.x, e.y, e.z) : new ur
                    }

                    function fr(e, t) {
                        e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z)
                    }

                    function mr(e, t) {
                        return {
                            baseStep: ln(t),
                            constraint: t,
                            textProps: T.fromObject({
                                draggingScale: cn(t, e),
                                formatter: St(on(t, e))
                            })
                        }
                    }
                    const gr = {
                        id: "input-point3d",
                        type: "input",
                        accept: (e, t) => {
                            if (!ur.isObject(e)) return null;
                            const n = P,
                                i = R(t, {
                                    x: n.optional.custom(nn),
                                    y: n.optional.custom(nn),
                                    z: n.optional.custom(nn)
                                });
                            return i ? {
                                initialValue: e,
                                params: i
                            } : null
                        },
                        binding: {
                            reader: e => pr,
                            constraint: e => {
                                return t = e.params, n = e.initialValue, new zi({
                                    assembly: dr,
                                    components: [sr("x" in t ? t.x : void 0, n.x), sr("y" in t ? t.y : void 0, n.y), sr("z" in t ? t.z : void 0, n.z)]
                                });
                                var t, n
                            },
                            equals: ur.equals,
                            writer: e => fr
                        },
                        controller: e => {
                            const t = e.value,
                                n = e.constraint;
                            if (!(n instanceof zi)) throw h.shouldNeverHappen();
                            return new Gi(e.document, {
                                assembly: dr,
                                axes: [mr(t.rawValue.x, n.components[0]), mr(t.rawValue.y, n.components[1]), mr(t.rawValue.z, n.components[2])],
                                parser: yt,
                                value: t,
                                viewProps: e.viewProps
                            })
                        }
                    };
                    class vr {
                        constructor(e = 0, t = 0, n = 0, i = 0) {
                            this.x = e, this.y = t, this.z = n, this.w = i
                        }
                        getComponents() {
                            return [this.x, this.y, this.z, this.w]
                        }
                        static isObject(e) {
                            if (o(e)) return !1;
                            const t = e.x,
                                n = e.y,
                                i = e.z,
                                r = e.w;
                            return "number" == typeof t && "number" == typeof n && "number" == typeof i && "number" == typeof r
                        }
                        static equals(e, t) {
                            return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
                        }
                        toObject() {
                            return {
                                x: this.x,
                                y: this.y,
                                z: this.z,
                                w: this.w
                            }
                        }
                    }
                    const xr = {
                        toComponents: e => e.getComponents(),
                        fromComponents: e => new vr(...e)
                    };

                    function wr(e) {
                        return vr.isObject(e) ? new vr(e.x, e.y, e.z, e.w) : new vr
                    }

                    function br(e, t) {
                        e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z), e.writeProperty("w", t.w)
                    }
                    const _r = {
                        id: "input-point4d",
                        type: "input",
                        accept: (e, t) => {
                            if (!vr.isObject(e)) return null;
                            const n = P,
                                i = R(t, {
                                    x: n.optional.custom(nn),
                                    y: n.optional.custom(nn),
                                    z: n.optional.custom(nn),
                                    w: n.optional.custom(nn)
                                });
                            return i ? {
                                initialValue: e,
                                params: i
                            } : null
                        },
                        binding: {
                            reader: e => wr,
                            constraint: e => {
                                return t = e.params, n = e.initialValue, new zi({
                                    assembly: xr,
                                    components: [sr("x" in t ? t.x : void 0, n.x), sr("y" in t ? t.y : void 0, n.y), sr("z" in t ? t.z : void 0, n.z), sr("w" in t ? t.w : void 0, n.w)]
                                });
                                var t, n
                            },
                            equals: vr.equals,
                            writer: e => br
                        },
                        controller: e => {
                            const t = e.value,
                                n = e.constraint;
                            if (!(n instanceof zi)) throw h.shouldNeverHappen();
                            return new Gi(e.document, {
                                assembly: xr,
                                axes: t.rawValue.getComponents().map(((e, t) => {
                                    return i = e, {
                                        baseStep: ln(r = n.components[t]),
                                        constraint: r,
                                        textProps: T.fromObject({
                                            draggingScale: cn(r, i),
                                            formatter: St(on(r, i))
                                        })
                                    };
                                    var i, r
                                })),
                                parser: yt,
                                value: t,
                                viewProps: e.viewProps
                            })
                        }
                    };
                    const yr = {
                            id: "input-string",
                            type: "input",
                            accept: (e, t) => {
                                if ("string" != typeof e) return null;
                                const n = R(t, {
                                    options: P.optional.custom(en)
                                });
                                return n ? {
                                    initialValue: e,
                                    params: n
                                } : null
                            },
                            binding: {
                                reader: e => Ct,
                                constraint: e => function(e) {
                                    const t = [],
                                        n = sn(e.options);
                                    return n && t.push(n), new Ge(t)
                                }(e.params),
                                writer: e => $t
                            },
                            controller: e => {
                                var t;
                                const n = e.document,
                                    i = e.value,
                                    r = e.constraint;
                                return r && We(r, je) ? new Ke(n, {
                                    props: T.fromObject({
                                        options: null !== (t = an(r)) && void 0 !== t ? t : []
                                    }),
                                    value: i,
                                    viewProps: e.viewProps
                                }) : new nt(n, {
                                    parser: e => e,
                                    props: T.fromObject({
                                        formatter: Dt
                                    }),
                                    value: i,
                                    viewProps: e.viewProps
                                })
                            }
                        },
                        Ar = {
                            defaultInterval: 200,
                            defaultLineCount: 3
                        },
                        Mr = m("mll");
                    class Sr {
                        constructor(e, t) {
                            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(Mr()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("textarea");
                            n.classList.add(Mr("i")), n.style.height = `calc(var(--bld-us) * ${t.lineCount})`, n.readOnly = !0, t.viewProps.bindDisabled(n), this.element.appendChild(n), this.textareaElem_ = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
                        }
                        update_() {
                            const e = this.textareaElem_,
                                t = e.scrollTop === e.scrollHeight - e.clientHeight,
                                n = [];
                            this.value.rawValue.forEach((e => {
                                void 0 !== e && n.push(this.formatter_(e))
                            })), e.textContent = n.join("\n"), t && (e.scrollTop = e.scrollHeight)
                        }
                        onValueUpdate_() {
                            this.update_()
                        }
                    }
                    class Er {
                        constructor(e, t) {
                            this.value = t.value, this.viewProps = t.viewProps, this.view = new Sr(e, {
                                formatter: t.formatter,
                                lineCount: t.lineCount,
                                value: this.value,
                                viewProps: this.viewProps
                            })
                        }
                    }
                    const Tr = m("sgl");
                    class Cr {
                        constructor(e, t) {
                            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(Tr()), t.viewProps.bindClassModifiers(this.element);
                            const n = e.createElement("input");
                            n.classList.add(Tr("i")), n.readOnly = !0, n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
                        }
                        update_() {
                            const e = this.value.rawValue,
                                t = e[e.length - 1];
                            this.inputElement.value = void 0 !== t ? this.formatter_(t) : ""
                        }
                        onValueUpdate_() {
                            this.update_()
                        }
                    }
                    class Dr {
                        constructor(e, t) {
                            this.value = t.value, this.viewProps = t.viewProps, this.view = new Cr(e, {
                                formatter: t.formatter,
                                value: this.value,
                                viewProps: this.viewProps
                            })
                        }
                    }
                    const Pr = {
                            id: "monitor-bool",
                            type: "monitor",
                            accept: (e, t) => {
                                if ("boolean" != typeof e) return null;
                                const n = R(t, {
                                    lineCount: P.optional.number
                                });
                                return n ? {
                                    initialValue: e,
                                    params: n
                                } : null
                            },
                            binding: {
                                reader: e => it
                            },
                            controller: e => {
                                var t;
                                return 1 === e.value.rawValue.length ? new Dr(e.document, {
                                    formatter: rt,
                                    value: e.value,
                                    viewProps: e.viewProps
                                }) : new Er(e.document, {
                                    formatter: rt,
                                    lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : Ar.defaultLineCount,
                                    value: e.value,
                                    viewProps: e.viewProps
                                })
                            }
                        },
                        Rr = m("grl");
                    class Lr {
                        constructor(e, t) {
                            this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(Rr()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.props_ = t.props, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
                            const n = e.createElementNS(O, "svg");
                            n.classList.add(Rr("g")), n.style.height = `calc(var(--bld-us) * ${t.lineCount})`, this.element.appendChild(n), this.svgElem_ = n;
                            const i = e.createElementNS(O, "polyline");
                            this.svgElem_.appendChild(i), this.lineElem_ = i;
                            const r = e.createElement("div");
                            r.classList.add(Rr("t"), m("tt")()), this.element.appendChild(r), this.tooltipElem_ = r, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
                        }
                        get graphElement() {
                            return this.svgElem_
                        }
                        update_() {
                            const e = this.svgElem_.getBoundingClientRect(),
                                t = this.value.rawValue.length - 1,
                                n = this.props_.get("minValue"),
                                i = this.props_.get("maxValue"),
                                r = [];
                            this.value.rawValue.forEach(((s, a) => {
                                if (void 0 === s) return;
                                const o = zt(a, 0, t, 0, e.width),
                                    l = zt(s, n, i, e.height, 0);
                                r.push([o, l].join(","))
                            })), this.lineElem_.setAttributeNS(null, "points", r.join(" "));
                            const s = this.tooltipElem_,
                                a = this.value.rawValue[this.cursor_.rawValue];
                            if (void 0 === a) return void s.classList.remove(Rr("t", "a"));
                            const o = zt(this.cursor_.rawValue, 0, t, 0, e.width),
                                l = zt(a, n, i, e.height, 0);
                            s.style.left = `${o}px`, s.style.top = `${l}px`, s.textContent = `${this.formatter_(a)}`, s.classList.contains(Rr("t", "a")) || (s.classList.add(Rr("t", "a"), Rr("t", "in")), k(s), s.classList.remove(Rr("t", "in")))
                        }
                        onValueUpdate_() {
                            this.update_()
                        }
                        onCursorChange_() {
                            this.update_()
                        }
                    }
                    class Ir {
                        constructor(e, t) {
                            if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = t.props, this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = E(-1), this.view = new Lr(e, {
                                    cursor: this.cursor_,
                                    formatter: t.formatter,
                                    lineCount: t.lineCount,
                                    props: this.props_,
                                    value: this.value,
                                    viewProps: this.viewProps
                                }), N(e)) {
                                const e = new Ut(this.view.element);
                                e.emitter.on("down", this.onGraphPointerDown_), e.emitter.on("move", this.onGraphPointerMove_), e.emitter.on("up", this.onGraphPointerUp_)
                            } else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_)
                        }
                        onGraphMouseLeave_() {
                            this.cursor_.rawValue = -1
                        }
                        onGraphMouseMove_(e) {
                            const t = this.view.element.getBoundingClientRect();
                            this.cursor_.rawValue = Math.floor(zt(e.offsetX, 0, t.width, 0, this.value.rawValue.length))
                        }
                        onGraphPointerDown_(e) {
                            this.onGraphPointerMove_(e)
                        }
                        onGraphPointerMove_(e) {
                            e.data.point ? this.cursor_.rawValue = Math.floor(zt(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.rawValue = -1
                        }
                        onGraphPointerUp_() {
                            this.cursor_.rawValue = -1
                        }
                    }

                    function Br(e) {
                        return "format" in e && !o(e.format) ? e.format : St(2)
                    }

                    function Or(e) {
                        return "view" in e && "graph" === e.view
                    }
                    const kr = {
                            id: "monitor-number",
                            type: "monitor",
                            accept: (e, t) => {
                                if ("number" != typeof e) return null;
                                const n = P,
                                    i = R(t, {
                                        format: n.optional.function,
                                        lineCount: n.optional.number,
                                        max: n.optional.number,
                                        min: n.optional.number,
                                        view: n.optional.string
                                    });
                                return i ? {
                                    initialValue: e,
                                    params: i
                                } : null
                            },
                            binding: {
                                defaultBufferSize: e => Or(e) ? 64 : 1,
                                reader: e => At
                            },
                            controller: e => Or(e.params) ? function(e) {
                                var t, n, i;
                                return new Ir(e.document, {
                                    formatter: Br(e.params),
                                    lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : Ar.defaultLineCount,
                                    props: T.fromObject({
                                        maxValue: null !== (n = "max" in e.params ? e.params.max : null) && void 0 !== n ? n : 100,
                                        minValue: null !== (i = "min" in e.params ? e.params.min : null) && void 0 !== i ? i : 0
                                    }),
                                    value: e.value,
                                    viewProps: e.viewProps
                                })
                            }(e) : function(e) {
                                var t;
                                return 1 === e.value.rawValue.length ? new Dr(e.document, {
                                    formatter: Br(e.params),
                                    value: e.value,
                                    viewProps: e.viewProps
                                }) : new Er(e.document, {
                                    formatter: Br(e.params),
                                    lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : Ar.defaultLineCount,
                                    value: e.value,
                                    viewProps: e.viewProps
                                })
                            }(e)
                        },
                        Nr = {
                            id: "monitor-string",
                            type: "monitor",
                            accept: (e, t) => {
                                if ("string" != typeof e) return null;
                                const n = P,
                                    i = R(t, {
                                        lineCount: n.optional.number,
                                        multiline: n.optional.boolean
                                    });
                                return i ? {
                                    initialValue: e,
                                    params: i
                                } : null
                            },
                            binding: {
                                reader: e => Ct
                            },
                            controller: e => {
                                var t;
                                const n = e.value;
                                return n.rawValue.length > 1 || "multiline" in e.params && e.params.multiline ? new Er(e.document, {
                                    formatter: Dt,
                                    lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : Ar.defaultLineCount,
                                    value: n,
                                    viewProps: e.viewProps
                                }) : new Dr(e.document, {
                                    formatter: Dt,
                                    value: n,
                                    viewProps: e.viewProps
                                })
                            }
                        };
                    class Fr {
                        constructor(e) {
                            this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e.reader, this.writer = e.writer, this.emitter = new p, this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.target = e.target, this.read()
                        }
                        read() {
                            const e = this.target.read();
                            void 0 !== e && (this.value.rawValue = this.reader(e))
                        }
                        write_(e) {
                            this.writer(this.target, e)
                        }
                        onValueChange_(e) {
                            this.write_(e.rawValue), this.emitter.emit("change", {
                                options: e.options,
                                rawValue: e.rawValue,
                                sender: this
                            })
                        }
                    }
                    class Ur {
                        constructor(e) {
                            this.onTick_ = this.onTick_.bind(this), this.reader_ = e.reader, this.target = e.target, this.emitter = new p, this.value = e.value, this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read()
                        }
                        dispose() {
                            this.ticker.dispose()
                        }
                        read() {
                            const e = this.target.read();
                            if (void 0 === e) return;
                            const t = this.value.rawValue,
                                n = this.reader_(e);
                            this.value.rawValue = function(e, t) {
                                const n = [...Lt(e), t];
                                return n.length > e.length ? n.splice(0, n.length - e.length) : Pt(n, e.length), n
                            }(t, n), this.emitter.emit("update", {
                                rawValue: n,
                                sender: this
                            })
                        }
                        onTick_(e) {
                            this.read()
                        }
                    }

                    function zr(e, t) {
                        return 0 === t ? new Ve : new He(e, null != t ? t : Ar.defaultInterval)
                    }
                    class Vr {
                        constructor() {
                            this.pluginsMap_ = {
                                blades: [],
                                inputs: [],
                                monitors: []
                            }
                        }
                        getAll() {
                            return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
                        }
                        register(e) {
                            "blade" === e.type ? this.pluginsMap_.blades.unshift(e) : "input" === e.type ? this.pluginsMap_.inputs.unshift(e) : "monitor" === e.type && this.pluginsMap_.monitors.unshift(e)
                        }
                        createInput(e, t, n) {
                            if (o(t.read())) throw new h({
                                context: {
                                    key: t.key
                                },
                                type: "nomatchingcontroller"
                            });
                            const i = this.pluginsMap_.inputs.reduce(((i, r) => null != i ? i : function(e, t) {
                                const n = e.accept(t.target.read(), t.params);
                                if (o(n)) return null;
                                const i = P,
                                    r = {
                                        target: t.target,
                                        initialValue: n.initialValue,
                                        params: n.params
                                    },
                                    s = e.binding.reader(r),
                                    a = e.binding.constraint ? e.binding.constraint(r) : void 0,
                                    l = E(s(n.initialValue), {
                                        constraint: a,
                                        equals: e.binding.equals
                                    }),
                                    c = new Fr({
                                        reader: s,
                                        target: t.target,
                                        value: l,
                                        writer: e.binding.writer(r)
                                    }),
                                    h = i.optional.boolean(t.params.disabled).value,
                                    u = i.optional.boolean(t.params.hidden).value,
                                    d = e.controller({
                                        constraint: a,
                                        document: t.document,
                                        initialValue: n.initialValue,
                                        params: n.params,
                                        value: c.value,
                                        viewProps: De.create({
                                            disabled: h,
                                            hidden: u
                                        })
                                    }),
                                    p = i.optional.string(t.params.label).value;
                                return new ie(t.document, {
                                    binding: c,
                                    blade: K(),
                                    props: T.fromObject({
                                        label: null != p ? p : t.target.key
                                    }),
                                    valueController: d
                                })
                            }(r, {
                                document: e,
                                target: t,
                                params: n
                            })), null);
                            if (i) return i;
                            throw new h({
                                context: {
                                    key: t.key
                                },
                                type: "nomatchingcontroller"
                            })
                        }
                        createMonitor(e, t, n) {
                            const i = this.pluginsMap_.monitors.reduce(((i, r) => null != i ? i : function(e, t) {
                                var n, i, r;
                                const s = P,
                                    a = e.accept(t.target.read(), t.params);
                                if (o(a)) return null;
                                const l = {
                                        target: t.target,
                                        initialValue: a.initialValue,
                                        params: a.params
                                    },
                                    c = e.binding.reader(l),
                                    h = null !== (i = null !== (n = s.optional.number(t.params.bufferSize).value) && void 0 !== n ? n : e.binding.defaultBufferSize && e.binding.defaultBufferSize(a.params)) && void 0 !== i ? i : 1,
                                    u = s.optional.number(t.params.interval).value,
                                    d = new Ur({
                                        reader: c,
                                        target: t.target,
                                        ticker: zr(t.document, u),
                                        value: Rt(h)
                                    }),
                                    p = s.optional.boolean(t.params.disabled).value,
                                    f = s.optional.boolean(t.params.hidden).value,
                                    m = e.controller({
                                        document: t.document,
                                        params: a.params,
                                        value: d.value,
                                        viewProps: De.create({
                                            disabled: p,
                                            hidden: f
                                        })
                                    }),
                                    g = null !== (r = s.optional.string(t.params.label).value) && void 0 !== r ? r : t.target.key;
                                return new se(t.document, {
                                    binding: d,
                                    blade: K(),
                                    props: T.fromObject({
                                        label: g
                                    }),
                                    valueController: m
                                })
                            }(r, {
                                document: e,
                                params: n,
                                target: t
                            })), null);
                            if (i) return i;
                            throw new h({
                                context: {
                                    key: t.key
                                },
                                type: "nomatchingcontroller"
                            })
                        }
                        createBlade(e, t) {
                            const n = this.pluginsMap_.blades.reduce(((n, i) => null != n ? n : function(e, t) {
                                const n = e.accept(t.params);
                                if (!n) return null;
                                const i = P.optional.boolean(t.params.disabled).value,
                                    r = P.optional.boolean(t.params.hidden).value;
                                return e.controller({
                                    blade: K(),
                                    document: t.document,
                                    params: Object.assign(Object.assign({}, n.params), {
                                        disabled: i,
                                        hidden: r
                                    }),
                                    viewProps: De.create({
                                        disabled: i,
                                        hidden: r
                                    })
                                })
                            }(i, {
                                document: e,
                                params: t
                            })), null);
                            if (!n) throw new h({
                                type: "nomatchingview",
                                context: {
                                    params: t
                                }
                            });
                            return n
                        }
                        createBladeApi(e) {
                            if (e instanceof ie) return new ne(e);
                            if (e instanceof se) return new re(e);
                            if (e instanceof ge) return new ce(e, this);
                            const t = this.pluginsMap_.blades.reduce(((t, n) => null != t ? t : n.api({
                                controller: e,
                                pool: this
                            })), null);
                            if (!t) throw h.shouldNeverHappen();
                            return t
                        }
                    }
                    class Hr extends t {
                        constructor(e) {
                            super(e), this.emitter_ = new p, this.controller_.valueController.value.emitter.on("change", (e => {
                                this.emitter_.emit("change", {
                                    event: new i(this, e.rawValue)
                                })
                            }))
                        }
                        get label() {
                            return this.controller_.props.get("label")
                        }
                        set label(e) {
                            this.controller_.props.set("label", e)
                        }
                        get options() {
                            return this.controller_.valueController.props.get("options")
                        }
                        set options(e) {
                            this.controller_.valueController.props.set("options", e)
                        }
                        get value() {
                            return this.controller_.valueController.value.rawValue
                        }
                        set value(e) {
                            this.controller_.valueController.value.rawValue = e
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                    }
                    class Gr extends t {
                        constructor(e) {
                            super(e), this.emitter_ = new p, this.controller_.valueController.value.emitter.on("change", (e => {
                                this.emitter_.emit("change", {
                                    event: new i(this, e.rawValue)
                                })
                            }))
                        }
                        get label() {
                            return this.controller_.props.get("label")
                        }
                        set label(e) {
                            this.controller_.props.set("label", e)
                        }
                        get maxValue() {
                            return this.controller_.valueController.sliderController.props.get("maxValue")
                        }
                        set maxValue(e) {
                            this.controller_.valueController.sliderController.props.set("maxValue", e)
                        }
                        get minValue() {
                            return this.controller_.valueController.sliderController.props.get("minValue")
                        }
                        set minValue(e) {
                            this.controller_.valueController.sliderController.props.set("minValue", e)
                        }
                        get value() {
                            return this.controller_.valueController.value.rawValue
                        }
                        set value(e) {
                            this.controller_.valueController.value.rawValue = e
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                    }
                    class Wr extends t {
                        constructor(e) {
                            super(e), this.emitter_ = new p, this.controller_.valueController.value.emitter.on("change", (e => {
                                this.emitter_.emit("change", {
                                    event: new i(this, e.rawValue)
                                })
                            }))
                        }
                        get label() {
                            return this.controller_.props.get("label")
                        }
                        set label(e) {
                            this.controller_.props.set("label", e)
                        }
                        get formatter() {
                            return this.controller_.valueController.props.get("formatter")
                        }
                        set formatter(e) {
                            this.controller_.valueController.props.set("formatter", e)
                        }
                        get value() {
                            return this.controller_.valueController.value.rawValue
                        }
                        set value(e) {
                            this.controller_.valueController.value.rawValue = e
                        }
                        on(e, t) {
                            const n = t.bind(this);
                            return this.emitter_.on(e, (e => {
                                n(e.event)
                            })), this
                        }
                    }
                    const jr = {
                        id: "list",
                        type: "blade",
                        accept(e) {
                            const t = P,
                                n = R(e, {
                                    options: t.required.custom(en),
                                    value: t.required.raw,
                                    view: t.required.constant("list"),
                                    label: t.optional.string
                                });
                            return n ? {
                                params: n
                            } : null
                        },
                        controller(e) {
                            const t = new Ke(e.document, {
                                props: T.fromObject({
                                    options: rn(e.params.options)
                                }),
                                value: E(e.params.value),
                                viewProps: e.viewProps
                            });
                            return new _e(e.document, {
                                blade: e.blade,
                                props: T.fromObject({
                                    label: e.params.label
                                }),
                                valueController: t
                            })
                        },
                        api: e => e.controller instanceof _e && e.controller.valueController instanceof Ke ? new Hr(e.controller) : null
                    };
                    class Yr extends he {
                        constructor(e, t) {
                            super(e, t)
                        }
                        get element() {
                            return this.controller_.view.element
                        }
                        importPreset(e) {
                            (function(e, t) {
                                e.forEach((e => {
                                    const n = t[e.presetKey];
                                    void 0 !== n && e.write(n)
                                }))
                            })(this.controller_.rackController.rack.find(ie).map((e => e.binding.target)), e), this.refresh()
                        }
                        exportPreset() {
                            return this.controller_.rackController.rack.find(ie).map((e => e.binding.target)).reduce(((e, t) => Object.assign(e, {
                                [t.presetKey]: t.read()
                            })), {})
                        }
                        refresh() {
                            this.controller_.rackController.rack.find(ie).forEach((e => {
                                e.binding.read()
                            })), this.controller_.rackController.rack.find(se).forEach((e => {
                                e.binding.read()
                            }))
                        }
                    }
                    class Xr extends we {
                        constructor(e, t) {
                            super(e, {
                                expanded: t.expanded,
                                blade: t.blade,
                                props: t.props,
                                root: !0,
                                viewProps: t.viewProps
                            })
                        }
                    }
                    const Qr = {
                            id: "slider",
                            type: "blade",
                            accept(e) {
                                const t = P,
                                    n = R(e, {
                                        max: t.required.number,
                                        min: t.required.number,
                                        view: t.required.constant("slider"),
                                        format: t.optional.function,
                                        label: t.optional.string,
                                        value: t.optional.number
                                    });
                                return n ? {
                                    params: n
                                } : null
                            },
                            controller(e) {
                                var t, n;
                                const i = null !== (t = e.params.value) && void 0 !== t ? t : 0,
                                    r = new Jt(e.document, {
                                        baseStep: 1,
                                        parser: yt,
                                        sliderProps: T.fromObject({
                                            maxValue: e.params.max,
                                            minValue: e.params.min
                                        }),
                                        textProps: T.fromObject({
                                            draggingScale: cn(void 0, i),
                                            formatter: null !== (n = e.params.format) && void 0 !== n ? n : Mt
                                        }),
                                        value: E(i),
                                        viewProps: e.viewProps
                                    });
                                return new _e(e.document, {
                                    blade: e.blade,
                                    props: T.fromObject({
                                        label: e.params.label
                                    }),
                                    valueController: r
                                })
                            },
                            api: e => e.controller instanceof _e && e.controller.valueController instanceof Jt ? new Gr(e.controller) : null
                        },
                        qr = {
                            id: "text",
                            type: "blade",
                            accept(e) {
                                const t = P,
                                    n = R(e, {
                                        parse: t.required.function,
                                        value: t.required.raw,
                                        view: t.required.constant("text"),
                                        format: t.optional.function,
                                        label: t.optional.string
                                    });
                                return n ? {
                                    params: n
                                } : null
                            },
                            controller(e) {
                                var t;
                                const n = new nt(e.document, {
                                    parser: e.params.parse,
                                    props: T.fromObject({
                                        formatter: null !== (t = e.params.format) && void 0 !== t ? t : e => String(e)
                                    }),
                                    value: E(e.params.value),
                                    viewProps: e.viewProps
                                });
                                return new _e(e.document, {
                                    blade: e.blade,
                                    props: T.fromObject({
                                        label: e.params.label
                                    }),
                                    valueController: n
                                })
                            },
                            api: e => e.controller instanceof _e && e.controller.valueController instanceof nt ? new Wr(e.controller) : null
                        };

                    function Kr(e, t, n) {
                        if (e.querySelector(`style[data-tp-style=${t}]`)) return;
                        const i = e.createElement("style");
                        i.dataset.tpStyle = t, i.textContent = n, e.head.appendChild(i)
                    }
                    const Zr = new class {
                        constructor(e) {
                            const [t, n] = e.split("-"), i = t.split(".");
                            this.major = parseInt(i[0], 10), this.minor = parseInt(i[1], 10), this.patch = parseInt(i[2], 10), this.prerelease = null != n ? n : null
                        }
                        toString() {
                            const e = [this.major, this.minor, this.patch].join(".");
                            return null !== this.prerelease ? [e, this.prerelease].join("-") : e
                        }
                    }("3.1.0");
                    e.BladeApi = t, e.ButtonApi = d, e.FolderApi = he, e.InputBindingApi = ne, e.ListApi = Hr, e.MonitorBindingApi = re, e.Pane = class extends Yr {
                        constructor(e) {
                            var t, n;
                            const i = null != e ? e : {},
                                r = null !== (t = i.document) && void 0 !== t ? t : F(),
                                s = function() {
                                    const e = new Vr;
                                    return [hr, gr, _r, yr, Xi, Ui, Fi, Oi, pn, Pr, Nr, kr, Q, be, Ee, ze].forEach((t => {
                                        e.register(t)
                                    })), e
                                }();
                            super(new Xr(r, {
                                expanded: i.expanded,
                                blade: K(),
                                props: T.fromObject({
                                    title: i.title
                                }),
                                viewProps: De.create()
                            }), s), this.pool_ = s, this.containerElem_ = null !== (n = i.container) && void 0 !== n ? n : function(e) {
                                const t = e.createElement("div");
                                return t.classList.add(m("dfw")()), e.body && e.body.appendChild(t), t
                            }(r), this.containerElem_.appendChild(this.element), this.doc_ = r, this.usesDefaultWrapper_ = !i.container, this.setUpDefaultPlugins_()
                        }
                        get document() {
                            if (!this.doc_) throw h.alreadyDisposed();
                            return this.doc_
                        }
                        dispose() {
                            const e = this.containerElem_;
                            if (!e) throw h.alreadyDisposed();
                            if (this.usesDefaultWrapper_) {
                                const t = e.parentElement;
                                t && t.removeChild(e)
                            }
                            this.containerElem_ = null, this.doc_ = null, super.dispose()
                        }
                        registerPlugin(e) {
                            ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach((e => {
                                this.pool_.register(e), this.embedPluginStyle_(e)
                            }))
                        }
                        embedPluginStyle_(e) {
                            e.css && Kr(this.document, `plugin-${e.id}`, e.css)
                        }
                        setUpDefaultPlugins_() {
                            Kr(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((e => {
                                this.embedPluginStyle_(e)
                            })), this.registerPlugin({
                                plugins: [Qr, jr, ze, qr]
                            })
                        }
                    }, e.SeparatorApi = ye, e.SliderApi = Gr, e.TabApi = Oe, e.TabPageApi = Be, e.TextApi = Wr, e.TpChangeEvent = i, e.VERSION = Zr, Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }(t)
            }
        },
        t = {};

    function n(i) {
        var r = t[i];
        if (void 0 !== r) return r.exports;
        var s = t[i] = {
            exports: {}
        };
        return e[i].call(s.exports, s, s.exports, n), s.exports
    }
    n.d = (e, t) => {
        for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, {
            enumerable: !0,
            get: t[i]
        })
    }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, (() => {
        "use strict";
        var e = {};
        n.r(e), n.d(e, {
            AsyncCompress: () => au,
            AsyncDecompress: () => yu,
            AsyncDeflate: () => Jh,
            AsyncGunzip: () => hu,
            AsyncGzip: () => au,
            AsyncInflate: () => nu,
            AsyncUnzipInflate: () => qu,
            AsyncUnzlib: () => xu,
            AsyncZipDeflate: () => Gu,
            AsyncZlib: () => fu,
            Compress: () => su,
            DecodeUTF8: () => Pu,
            Decompress: () => _u,
            Deflate: () => Zh,
            EncodeUTF8: () => Ru,
            Gunzip: () => cu,
            Gzip: () => su,
            Inflate: () => tu,
            Unzip: () => Ku,
            UnzipInflate: () => Qu,
            UnzipPassThrough: () => Xu,
            Unzlib: () => vu,
            Zip: () => Wu,
            ZipDeflate: () => Hu,
            ZipPassThrough: () => Vu,
            Zlib: () => pu,
            compress: () => ou,
            compressSync: () => lu,
            decompress: () => Au,
            decompressSync: () => Mu,
            deflate: () => $h,
            deflateSync: () => eu,
            gunzip: () => uu,
            gunzipSync: () => du,
            gzip: () => ou,
            gzipSync: () => lu,
            inflate: () => iu,
            inflateSync: () => ru,
            strFromU8: () => Iu,
            strToU8: () => Lu,
            unzip: () => Zu,
            unzipSync: () => Ju,
            unzlib: () => wu,
            unzlibSync: () => bu,
            zip: () => ju,
            zipSync: () => Yu,
            zlib: () => mu,
            zlibSync: () => gu
        });
        const t = "142",
            i = 100,
            r = 301,
            s = 302,
            a = 306,
            o = 1e3,
            l = 1001,
            c = 1002,
            h = 1003,
            u = 1004,
            d = 1005,
            p = 1006,
            f = 1008,
            m = 1009,
            g = 1014,
            v = 1015,
            x = 1016,
            w = 1020,
            b = 1023,
            _ = 1026,
            y = 1027,
            A = 33776,
            M = 33777,
            S = 33778,
            E = 33779,
            T = 2300,
            C = 2301,
            D = 2302,
            P = 3e3,
            R = 3001,
            L = "srgb",
            I = "srgb-linear",
            B = 7680,
            O = 35044,
            k = "300 es",
            N = 1035;
        class F {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            }
            removeEventListener(e, t) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[e];
                if (void 0 !== n) {
                    const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                if (void 0 === this._listeners) return;
                const t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    const n = t.slice(0);
                    for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                    e.target = null
                }
            }
        }
        const U = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let z = 1234567;
        const V = Math.PI / 180,
            H = 180 / Math.PI;

        function G() {
            const e = 4294967295 * Math.random() | 0,
                t = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (U[255 & e] + U[e >> 8 & 255] + U[e >> 16 & 255] + U[e >> 24 & 255] + "-" + U[255 & t] + U[t >> 8 & 255] + "-" + U[t >> 16 & 15 | 64] + U[t >> 24 & 255] + "-" + U[63 & n | 128] + U[n >> 8 & 255] + "-" + U[n >> 16 & 255] + U[n >> 24 & 255] + U[255 & i] + U[i >> 8 & 255] + U[i >> 16 & 255] + U[i >> 24 & 255]).toLowerCase()
        }

        function W(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }

        function j(e, t) {
            return (e % t + t) % t
        }

        function Y(e, t, n) {
            return (1 - n) * e + n * t
        }

        function X(e) {
            return 0 == (e & e - 1) && 0 !== e
        }

        function Q(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        }

        function q(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
        var K = Object.freeze({
            __proto__: null,
            DEG2RAD: V,
            RAD2DEG: H,
            generateUUID: G,
            clamp: W,
            euclideanModulo: j,
            mapLinear: function(e, t, n, i, r) {
                return i + (e - t) * (r - i) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: Y,
            damp: function(e, t, n, i) {
                return Y(e, t, 1 - Math.exp(-n * i))
            },
            pingpong: function(e, t = 1) {
                return t - Math.abs(j(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (z = e);
                let t = z += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * V
            },
            radToDeg: function(e) {
                return e * H
            },
            isPowerOfTwo: X,
            ceilPowerOfTwo: Q,
            floorPowerOfTwo: q,
            setQuaternionFromProperEuler: function(e, t, n, i, r) {
                const s = Math.cos,
                    a = Math.sin,
                    o = s(n / 2),
                    l = a(n / 2),
                    c = s((t + i) / 2),
                    h = a((t + i) / 2),
                    u = s((t - i) / 2),
                    d = a((t - i) / 2),
                    p = s((i - t) / 2),
                    f = a((i - t) / 2);
                switch (r) {
                    case "XYX":
                        e.set(o * h, l * u, l * d, o * c);
                        break;
                    case "YZY":
                        e.set(l * d, o * h, l * u, o * c);
                        break;
                    case "ZXZ":
                        e.set(l * u, l * d, o * h, o * c);
                        break;
                    case "XZX":
                        e.set(o * h, l * f, l * p, o * c);
                        break;
                    case "YXY":
                        e.set(l * p, o * h, l * f, o * c);
                        break;
                    case "ZYZ":
                        e.set(l * f, l * p, o * h, o * c);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: function(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint16Array:
                        return Math.round(65535 * e);
                    case Uint8Array:
                        return Math.round(255 * e);
                    case Int16Array:
                        return Math.round(32767 * e);
                    case Int8Array:
                        return Math.round(127 * e);
                    default:
                        throw new Error("Invalid component type.")
                }
            },
            denormalize: function(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                }
            }
        });
        class Z {
            constructor(e = 0, t = 0) {
                Z.prototype.isVector2 = !0, this.x = e, this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e, this.y = t, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this
            }
            add(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this
            }
            sub(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e
            }
            fromBufferAttribute(e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
            }
            rotateAround(e, t) {
                const n = Math.cos(t),
                    i = Math.sin(t),
                    r = this.x - e.x,
                    s = this.y - e.y;
                return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class J {
            constructor() {
                J.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(e, t, n, i, r, s, a, o, l) {
                const c = this.elements;
                return c[0] = e, c[1] = i, c[2] = a, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    s = n[0],
                    a = n[3],
                    o = n[6],
                    l = n[1],
                    c = n[4],
                    h = n[7],
                    u = n[2],
                    d = n[5],
                    p = n[8],
                    f = i[0],
                    m = i[3],
                    g = i[6],
                    v = i[1],
                    x = i[4],
                    w = i[7],
                    b = i[2],
                    _ = i[5],
                    y = i[8];
                return r[0] = s * f + a * v + o * b, r[3] = s * m + a * x + o * _, r[6] = s * g + a * w + o * y, r[1] = l * f + c * v + h * b, r[4] = l * m + c * x + h * _, r[7] = l * g + c * w + h * y, r[2] = u * f + d * v + p * b, r[5] = u * m + d * x + p * _, r[8] = u * g + d * w + p * y, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    s = e[4],
                    a = e[5],
                    o = e[6],
                    l = e[7],
                    c = e[8];
                return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    s = e[4],
                    a = e[5],
                    o = e[6],
                    l = e[7],
                    c = e[8],
                    h = c * s - a * l,
                    u = a * o - c * r,
                    d = l * r - s * o,
                    p = t * h + n * u + i * d;
                if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return e[0] = h * f, e[1] = (i * l - c * n) * f, e[2] = (a * n - i * s) * f, e[3] = u * f, e[4] = (c * t - i * o) * f, e[5] = (i * r - a * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (s * t - n * r) * f, this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
            }
            setUvTransform(e, t, n, i, r, s, a) {
                const o = Math.cos(r),
                    l = Math.sin(r);
                return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1), this
            }
            scale(e, t) {
                const n = this.elements;
                return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
            }
            rotate(e) {
                const t = Math.cos(e),
                    n = Math.sin(e),
                    i = this.elements,
                    r = i[0],
                    s = i[3],
                    a = i[6],
                    o = i[1],
                    l = i[4],
                    c = i[7];
                return i[0] = t * r + n * o, i[3] = t * s + n * l, i[6] = t * a + n * c, i[1] = -n * r + t * o, i[4] = -n * s + t * l, i[7] = -n * a + t * c, this
            }
            translate(e, t) {
                const n = this.elements;
                return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let e = 0; e < 9; e++)
                    if (t[e] !== n[e]) return !1;
                return !0
            }
            fromArray(e, t = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }

        function $(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] > 65535) return !0;
            return !1
        }

        function ee(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }

        function te(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }

        function ne(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        const ie = {
                [L]: {
                    [I]: te
                },
                [I]: {
                    [L]: ne
                }
            },
            re = {
                legacyMode: !0,
                get workingColorSpace() {
                    return I
                },
                set workingColorSpace(e) {
                    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                },
                convert: function(e, t, n) {
                    if (this.legacyMode || t === n || !t || !n) return e;
                    if (ie[t] && void 0 !== ie[t][n]) {
                        const i = ie[t][n];
                        return e.r = i(e.r), e.g = i(e.g), e.b = i(e.b), e
                    }
                    throw new Error("Unsupported color space conversion.")
                },
                fromWorkingColorSpace: function(e, t) {
                    return this.convert(e, this.workingColorSpace, t)
                },
                toWorkingColorSpace: function(e, t) {
                    return this.convert(e, t, this.workingColorSpace)
                }
            },
            se = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            ae = {
                r: 0,
                g: 0,
                b: 0
            },
            oe = {
                h: 0,
                s: 0,
                l: 0
            },
            le = {
                h: 0,
                s: 0,
                l: 0
            };

        function ce(e, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }

        function he(e, t) {
            return t.r = e.r, t.g = e.g, t.b = e.b, t
        }
        class ue {
            constructor(e, t, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
            }
            set(e) {
                return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
            }
            setScalar(e) {
                return this.r = e, this.g = e, this.b = e, this
            }
            setHex(e, t = "srgb") {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, re.toWorkingColorSpace(this, t), this
            }
            setRGB(e, t, n, i = "srgb-linear") {
                return this.r = e, this.g = t, this.b = n, re.toWorkingColorSpace(this, i), this
            }
            setHSL(e, t, n, i = "srgb-linear") {
                if (e = j(e, 1), t = W(t, 0, 1), n = W(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                        r = 2 * n - i;
                    this.r = ce(r, i, e + 1 / 3), this.g = ce(r, i, e), this.b = ce(r, i, e - 1 / 3)
                }
                return re.toWorkingColorSpace(this, i), this
            }
            setStyle(e, t = "srgb") {
                function n(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let i;
                if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                    let e;
                    const r = i[1],
                        s = i[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, re.toWorkingColorSpace(this, t), n(e[4]), this;
                            if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, re.toWorkingColorSpace(this, t), n(e[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                const i = parseFloat(e[1]) / 360,
                                    r = parseInt(e[2], 10) / 100,
                                    s = parseInt(e[3], 10) / 100;
                                return n(e[4]), this.setHSL(i, r, s, t)
                            }
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const e = i[1],
                        n = e.length;
                    if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, re.toWorkingColorSpace(this, t), this;
                    if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, re.toWorkingColorSpace(this, t), this
                }
                return e && e.length > 0 ? this.setColorName(e, t) : this
            }
            setColorName(e, t = "srgb") {
                const n = se[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            }
            copySRGBToLinear(e) {
                return this.r = te(e.r), this.g = te(e.g), this.b = te(e.b), this
            }
            copyLinearToSRGB(e) {
                return this.r = ne(e.r), this.g = ne(e.g), this.b = ne(e.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(e = "srgb") {
                return re.fromWorkingColorSpace(he(this, ae), e), W(255 * ae.r, 0, 255) << 16 ^ W(255 * ae.g, 0, 255) << 8 ^ W(255 * ae.b, 0, 255) << 0
            }
            getHexString(e = "srgb") {
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e, t = "srgb-linear") {
                re.fromWorkingColorSpace(he(this, ae), t);
                const n = ae.r,
                    i = ae.g,
                    r = ae.b,
                    s = Math.max(n, i, r),
                    a = Math.min(n, i, r);
                let o, l;
                const c = (a + s) / 2;
                if (a === s) o = 0, l = 0;
                else {
                    const e = s - a;
                    switch (l = c <= .5 ? e / (s + a) : e / (2 - s - a), s) {
                        case n:
                            o = (i - r) / e + (i < r ? 6 : 0);
                            break;
                        case i:
                            o = (r - n) / e + 2;
                            break;
                        case r:
                            o = (n - i) / e + 4
                    }
                    o /= 6
                }
                return e.h = o, e.s = l, e.l = c, e
            }
            getRGB(e, t = "srgb-linear") {
                return re.fromWorkingColorSpace(he(this, ae), t), e.r = ae.r, e.g = ae.g, e.b = ae.b, e
            }
            getStyle(e = "srgb") {
                return re.fromWorkingColorSpace(he(this, ae), e), e !== L ? `color(${e} ${ae.r} ${ae.g} ${ae.b})` : `rgb(${255*ae.r|0},${255*ae.g|0},${255*ae.b|0})`
            }
            offsetHSL(e, t, n) {
                return this.getHSL(oe), oe.h += e, oe.s += t, oe.l += n, this.setHSL(oe.h, oe.s, oe.l), this
            }
            add(e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            }
            addColors(e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            }
            addScalar(e) {
                return this.r += e, this.g += e, this.b += e, this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            }
            multiply(e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            }
            multiplyScalar(e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
            }
            lerpHSL(e, t) {
                this.getHSL(oe), e.getHSL(le);
                const n = Y(oe.h, le.h, t),
                    i = Y(oe.s, le.s, t),
                    r = Y(oe.l, le.l, t);
                return this.setHSL(n, i, r), this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, t = 0) {
                return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
            toJSON() {
                return this.getHex()
            }*[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        let de;
        ue.NAMES = se;
        class pe {
            static getDataURL(e) {
                if (/^data:/i.test(e.src)) return e.src;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                let t;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === de && (de = ee("canvas")), de.width = e.width, de.height = e.height;
                    const n = de.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = de
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = ee("canvas");
                    t.width = e.width, t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const i = n.getImageData(0, 0, e.width, e.height),
                        r = i.data;
                    for (let e = 0; e < r.length; e++) r[e] = 255 * te(r[e] / 255);
                    return n.putImageData(i, 0, 0), t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * te(t[e] / 255)) : t[e] = te(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
            }
        }
        class fe {
            constructor(e = null) {
                this.isSource = !0, this.uuid = G(), this.data = e, this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    i = this.data;
                if (null !== i) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(me(i[t].image)) : e.push(me(i[t]))
                    } else e = me(i);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n), n
            }
        }

        function me(e) {
            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? pe.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        let ge = 0;
        class ve extends F {
            constructor(e = ve.DEFAULT_IMAGE, t = ve.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: ge++
                }), this.uuid = G(), this.name = "", this.source = new fe(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Z(0, 0), this.repeat = new Z(1, 1), this.center = new Z(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new J, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(e) {
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (300 !== this.mapping) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case o:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case l:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case c:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case o:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case l:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case c:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++, this.source.needsUpdate = !0)
            }
        }
        ve.DEFAULT_IMAGE = null, ve.DEFAULT_MAPPING = 300;
        class xe {
            constructor(e = 0, t = 0, n = 0, i = 1) {
                xe.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, i) {
                return this.x = e, this.y = t, this.z = n, this.w = i, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setW(e) {
                return this.w = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
            }
            add(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            }
            sub(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    s = e.elements;
                return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, i, r;
                const s = .01,
                    a = .1,
                    o = e.elements,
                    l = o[0],
                    c = o[4],
                    h = o[8],
                    u = o[1],
                    d = o[5],
                    p = o[9],
                    f = o[2],
                    m = o[6],
                    g = o[10];
                if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
                    if (Math.abs(c + u) < a && Math.abs(h + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    const e = (l + 1) / 2,
                        o = (d + 1) / 2,
                        v = (g + 1) / 2,
                        x = (c + u) / 4,
                        w = (h + f) / 4,
                        b = (p + m) / 4;
                    return e > o && e > v ? e < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = x / n, r = w / n) : o > v ? o < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = x / i, r = b / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = w / r, i = b / r), this.set(n, i, r, t), this
                }
                let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
                return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (h - f) / v, this.z = (u - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            }
            fromBufferAttribute(e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class we extends F {
            constructor(e, t, n = {}) {
                super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new xe(0, 0, e, t), this.scissorTest = !1, this.viewport = new xe(0, 0, e, t);
                const i = {
                    width: e,
                    height: t,
                    depth: 1
                };
                this.texture = new ve(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : p, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
            }
            setSize(e, t, n = 1) {
                this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
                const t = Object.assign({}, e.texture.image);
                return this.texture.source = new fe(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class be extends ve {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = h, this.minFilter = h, this.wrapR = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class _e extends ve {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = h, this.minFilter = h, this.wrapR = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class ye extends we {
            constructor(e, t, n, i = {}) {
                super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
                const r = this.texture;
                this.texture = [];
                for (let e = 0; e < n; e++) this.texture[e] = r.clone(), this.texture[e].isRenderTargetTexture = !0
            }
            setSize(e, t, n = 1) {
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e, this.height = t, this.depth = n;
                    for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
                    this.dispose()
                }
                return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
            }
            copy(e) {
                this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
                for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
                return this
            }
        }
        class Ae {
            constructor(e = 0, t = 0, n = 0, i = 1) {
                this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
            }
            static slerp(e, t, n, i) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i)
            }
            static slerpFlat(e, t, n, i, r, s, a) {
                let o = n[i + 0],
                    l = n[i + 1],
                    c = n[i + 2],
                    h = n[i + 3];
                const u = r[s + 0],
                    d = r[s + 1],
                    p = r[s + 2],
                    f = r[s + 3];
                if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = h);
                if (1 === a) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = f);
                if (h !== f || o !== u || l !== d || c !== p) {
                    let e = 1 - a;
                    const t = o * u + l * d + c * p + h * f,
                        n = t >= 0 ? 1 : -1,
                        i = 1 - t * t;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i),
                            s = Math.atan2(r, t * n);
                        e = Math.sin(e * s) / r, a = Math.sin(a * s) / r
                    }
                    const r = a * n;
                    if (o = o * e + u * r, l = l * e + d * r, c = c * e + p * r, h = h * e + f * r, e === 1 - a) {
                        const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                        o *= e, l *= e, c *= e, h *= e
                    }
                }
                e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h
            }
            static multiplyQuaternionsFlat(e, t, n, i, r, s) {
                const a = n[i],
                    o = n[i + 1],
                    l = n[i + 2],
                    c = n[i + 3],
                    h = r[s],
                    u = r[s + 1],
                    d = r[s + 2],
                    p = r[s + 3];
                return e[t] = a * p + c * h + o * d - l * u, e[t + 1] = o * p + c * u + l * h - a * d, e[t + 2] = l * p + c * d + a * u - o * h, e[t + 3] = c * p - a * h - o * u - l * d, e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e, this._onChangeCallback()
            }
            set(e, t, n, i) {
                return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            }
            setFromEuler(e, t) {
                if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = e._x,
                    i = e._y,
                    r = e._z,
                    s = e._order,
                    a = Math.cos,
                    o = Math.sin,
                    l = a(n / 2),
                    c = a(i / 2),
                    h = a(r / 2),
                    u = o(n / 2),
                    d = o(i / 2),
                    p = o(r / 2);
                switch (s) {
                    case "XYZ":
                        this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                        break;
                    case "YXZ":
                        this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                        break;
                    case "ZXY":
                        this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                        break;
                    case "ZYX":
                        this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                        break;
                    case "YZX":
                        this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                        break;
                    case "XZY":
                        this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== t && this._onChangeCallback(), this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2,
                    i = Math.sin(n);
                return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(e) {
                const t = e.elements,
                    n = t[0],
                    i = t[4],
                    r = t[8],
                    s = t[1],
                    a = t[5],
                    o = t[9],
                    l = t[2],
                    c = t[6],
                    h = t[10],
                    u = n + a + h;
                if (u > 0) {
                    const e = .5 / Math.sqrt(u + 1);
                    this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (s - i) * e
                } else if (n > a && n > h) {
                    const e = 2 * Math.sqrt(1 + n - a - h);
                    this._w = (c - o) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e
                } else if (a > h) {
                    const e = 2 * Math.sqrt(1 + a - n - h);
                    this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (o + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + h - n - a);
                    this._w = (s - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(W(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n) return this;
                const i = Math.min(1, t / n);
                return this.slerp(e, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            }
            multiply(e, t) {
                return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x,
                    i = e._y,
                    r = e._z,
                    s = e._w,
                    a = t._x,
                    o = t._y,
                    l = t._z,
                    c = t._w;
                return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this
            }
            slerp(e, t) {
                if (0 === t) return this;
                if (1 === t) return this.copy(e);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    s = this._w;
                let a = s * e._w + n * e._x + i * e._y + r * e._z;
                if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                const o = 1 - a * a;
                if (o <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const l = Math.sqrt(o),
                    c = Math.atan2(l, a),
                    h = Math.sin((1 - t) * c) / l,
                    u = Math.sin(t * c) / l;
                return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = Math.random(),
                    t = Math.sqrt(1 - e),
                    n = Math.sqrt(e),
                    i = 2 * Math.PI * Math.random(),
                    r = 2 * Math.PI * Math.random();
                return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, t = 0) {
                return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
            }
            toArray(e = [], t = 0) {
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class Me {
            constructor(e = 0, t = 0, n = 0) {
                Me.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            }
            add(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
            }
            sub(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            }
            multiply(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            }
            applyEuler(e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Ee.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(Ee.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements,
                    s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this
            }
            applyQuaternion(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.x,
                    s = e.y,
                    a = e.z,
                    o = e.w,
                    l = o * t + s * i - a * n,
                    c = o * n + a * t - r * i,
                    h = o * i + r * n - s * t,
                    u = -r * t - s * n - a * i;
                return this.x = l * o + u * -r + c * -a - h * -s, this.y = c * o + u * -s + h * -r - l * -a, this.z = h * o + u * -a + l * -s - c * -r, this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
            }
            cross(e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x,
                    i = e.y,
                    r = e.z,
                    s = t.x,
                    a = t.y,
                    o = t.z;
                return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t) return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return Se.copy(this).projectOnVector(e), this.sub(Se)
            }
            reflect(e) {
                return this.sub(Se.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(W(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y,
                    i = this.z - e.z;
                return t * t + n * n + i * i
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const i = Math.sin(t) * e;
                return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x, this.y = e._y, this.z = e._z, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            }
            fromBufferAttribute(e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const e = 2 * (Math.random() - .5),
                    t = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - e ** 2);
                return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const Se = new Me,
            Ee = new Ae;
        class Te {
            constructor(e = new Me(1 / 0, 1 / 0, 1 / 0), t = new Me(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = e, this.max = t
            }
            set(e, t) {
                return this.min.copy(e), this.max.copy(t), this
            }
            setFromArray(e) {
                let t = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    a = -1 / 0;
                for (let o = 0, l = e.length; o < l; o += 3) {
                    const l = e[o],
                        c = e[o + 1],
                        h = e[o + 2];
                    l < t && (t = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > a && (a = h)
                }
                return this.min.set(t, n, i), this.max.set(r, s, a), this
            }
            setFromBufferAttribute(e) {
                let t = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    a = -1 / 0;
                for (let o = 0, l = e.count; o < l; o++) {
                    const l = e.getX(o),
                        c = e.getY(o),
                        h = e.getZ(o);
                    l < t && (t = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > a && (a = h)
                }
                return this.min.set(t, n, i), this.max.set(r, s, a), this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = De.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
            setFromObject(e, t = !1) {
                return this.makeEmpty(), this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            expandByObject(e, t = !1) {
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n)
                    if (t && null != n.attributes && void 0 !== n.attributes.position) {
                        const t = n.attributes.position;
                        for (let n = 0, i = t.count; n < i; n++) De.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(De)
                    } else null === n.boundingBox && n.computeBoundingBox(), Pe.copy(n.boundingBox), Pe.applyMatrix4(e.matrixWorld), this.union(Pe);
                const i = e.children;
                for (let e = 0, n = i.length; e < n; e++) this.expandByObject(i[e], t);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, De), De.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty()) return !1;
                this.getCenter(Ne), Fe.subVectors(this.max, Ne), Re.subVectors(e.a, Ne), Le.subVectors(e.b, Ne), Ie.subVectors(e.c, Ne), Be.subVectors(Le, Re), Oe.subVectors(Ie, Le), ke.subVectors(Re, Ie);
                let t = [0, -Be.z, Be.y, 0, -Oe.z, Oe.y, 0, -ke.z, ke.y, Be.z, 0, -Be.x, Oe.z, 0, -Oe.x, ke.z, 0, -ke.x, -Be.y, Be.x, 0, -Oe.y, Oe.x, 0, -ke.y, ke.x, 0];
                return !!Ve(t, Re, Le, Ie, Fe) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Ve(t, Re, Le, Ie, Fe) && (Ue.crossVectors(Be, Oe), t = [Ue.x, Ue.y, Ue.z], Ve(t, Re, Le, Ie, Fe)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return De.copy(e).clamp(this.min, this.max).sub(e).length()
            }
            getBoundingSphere(e) {
                return this.getCenter(e.center), e.radius = .5 * this.getSize(De).length(), e
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (Ce[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ce[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ce[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ce[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ce[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ce[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ce[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ce[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ce)), this
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const Ce = [new Me, new Me, new Me, new Me, new Me, new Me, new Me, new Me],
            De = new Me,
            Pe = new Te,
            Re = new Me,
            Le = new Me,
            Ie = new Me,
            Be = new Me,
            Oe = new Me,
            ke = new Me,
            Ne = new Me,
            Fe = new Me,
            Ue = new Me,
            ze = new Me;

        function Ve(e, t, n, i, r) {
            for (let s = 0, a = e.length - 3; s <= a; s += 3) {
                ze.fromArray(e, s);
                const a = r.x * Math.abs(ze.x) + r.y * Math.abs(ze.y) + r.z * Math.abs(ze.z),
                    o = t.dot(ze),
                    l = n.dot(ze),
                    c = i.dot(ze);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
            }
            return !0
        }
        const He = new Te,
            Ge = new Me,
            We = new Me,
            je = new Me;
        class Ye {
            constructor(e = new Me, t = -1) {
                this.center = e, this.radius = t
            }
            set(e, t) {
                return this.center.copy(e), this.radius = t, this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : He.setFromPoints(e).getCenter(n);
                let i = 0;
                for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
                return this.radius = Math.sqrt(i), this
            }
            copy(e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            }
            translate(e) {
                return this.center.add(e), this
            }
            expandByPoint(e) {
                je.subVectors(e, this.center);
                const t = je.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t),
                        n = .5 * (e - this.radius);
                    this.center.add(je.multiplyScalar(n / e)), this.radius += n
                }
                return this
            }
            union(e) {
                return !0 === this.center.equals(e.center) ? We.set(0, 0, 1).multiplyScalar(e.radius) : We.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Ge.copy(e.center).add(We)), this.expandByPoint(Ge.copy(e.center).sub(We)), this
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Xe = new Me,
            Qe = new Me,
            qe = new Me,
            Ke = new Me,
            Ze = new Me,
            Je = new Me,
            $e = new Me;
        class et {
            constructor(e = new Me, t = new Me(0, 0, -1)) {
                this.origin = e, this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            }
            copy(e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            }
            at(e, t) {
                return t.copy(this.direction).multiplyScalar(e).add(this.origin)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            }
            recast(e) {
                return this.origin.copy(this.at(e, Xe)), this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = Xe.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (Xe.copy(this.direction).multiplyScalar(t).add(this.origin), Xe.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, i) {
                Qe.copy(e).add(t).multiplyScalar(.5), qe.copy(t).sub(e).normalize(), Ke.copy(this.origin).sub(Qe);
                const r = .5 * e.distanceTo(t),
                    s = -this.direction.dot(qe),
                    a = Ke.dot(this.direction),
                    o = -Ke.dot(qe),
                    l = Ke.lengthSq(),
                    c = Math.abs(1 - s * s);
                let h, u, d, p;
                if (c > 0)
                    if (h = s * o - a, u = s * a - o, p = r * c, h >= 0)
                        if (u >= -p)
                            if (u <= p) {
                                const e = 1 / c;
                                h *= e, u *= e, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                            } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
                else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(qe).multiplyScalar(u).add(Qe), d
            }
            intersectSphere(e, t) {
                Xe.subVectors(e.center, this.origin);
                const n = Xe.dot(this.direction),
                    i = Xe.dot(Xe) - n * n,
                    r = e.radius * e.radius;
                if (i > r) return null;
                const s = Math.sqrt(r - i),
                    a = n - s,
                    o = n + s;
                return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                return 0 === t || e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, i, r, s, a, o;
                const l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    h = 1 / this.direction.z,
                    u = this.origin;
                return l >= 0 ? (n = (e.min.x - u.x) * l, i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, i = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, s = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, s = (e.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (e.min.z - u.z) * h, o = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h, o = (e.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, Xe)
            }
            intersectTriangle(e, t, n, i, r) {
                Ze.subVectors(t, e), Je.subVectors(n, e), $e.crossVectors(Ze, Je);
                let s, a = this.direction.dot($e);
                if (a > 0) {
                    if (i) return null;
                    s = 1
                } else {
                    if (!(a < 0)) return null;
                    s = -1, a = -a
                }
                Ke.subVectors(this.origin, e);
                const o = s * this.direction.dot(Je.crossVectors(Ke, Je));
                if (o < 0) return null;
                const l = s * this.direction.dot(Ze.cross(Ke));
                if (l < 0) return null;
                if (o + l > a) return null;
                const c = -s * Ke.dot($e);
                return c < 0 ? null : this.at(c / a, r)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class tt {
            constructor() {
                tt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(e, t, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
                const g = this.elements;
                return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new tt).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
            }
            copyPosition(e) {
                const t = this.elements,
                    n = e.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(e) {
                const t = this.elements,
                    n = e.elements,
                    i = 1 / nt.setFromMatrixColumn(e, 0).length(),
                    r = 1 / nt.setFromMatrixColumn(e, 1).length(),
                    s = 1 / nt.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromEuler(e) {
                e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z,
                    s = Math.cos(n),
                    a = Math.sin(n),
                    o = Math.cos(i),
                    l = Math.sin(i),
                    c = Math.cos(r),
                    h = Math.sin(r);
                if ("XYZ" === e.order) {
                    const e = s * c,
                        n = s * h,
                        i = a * c,
                        r = a * h;
                    t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -a * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * o
                } else if ("YXZ" === e.order) {
                    const e = o * c,
                        n = o * h,
                        i = l * c,
                        r = l * h;
                    t[0] = e + r * a, t[4] = i * a - n, t[8] = s * l, t[1] = s * h, t[5] = s * c, t[9] = -a, t[2] = n * a - i, t[6] = r + e * a, t[10] = s * o
                } else if ("ZXY" === e.order) {
                    const e = o * c,
                        n = o * h,
                        i = l * c,
                        r = l * h;
                    t[0] = e - r * a, t[4] = -s * h, t[8] = i + n * a, t[1] = n + i * a, t[5] = s * c, t[9] = r - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o
                } else if ("ZYX" === e.order) {
                    const e = s * c,
                        n = s * h,
                        i = a * c,
                        r = a * h;
                    t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * h, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = a * o, t[10] = s * o
                } else if ("YZX" === e.order) {
                    const e = s * o,
                        n = s * l,
                        i = a * o,
                        r = a * l;
                    t[0] = o * c, t[4] = r - e * h, t[8] = i * h + n, t[1] = h, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * h + i, t[10] = e - r * h
                } else if ("XZY" === e.order) {
                    const e = s * o,
                        n = s * l,
                        i = a * o,
                        r = a * l;
                    t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + r, t[5] = s * c, t[9] = n * h - i, t[2] = i * h - n, t[6] = a * c, t[10] = r * h + e
                }
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(rt, e, st)
            }
            lookAt(e, t, n) {
                const i = this.elements;
                return lt.subVectors(e, t), 0 === lt.lengthSq() && (lt.z = 1), lt.normalize(), at.crossVectors(n, lt), 0 === at.lengthSq() && (1 === Math.abs(n.z) ? lt.x += 1e-4 : lt.z += 1e-4, lt.normalize(), at.crossVectors(n, lt)), at.normalize(), ot.crossVectors(lt, at), i[0] = at.x, i[4] = ot.x, i[8] = lt.x, i[1] = at.y, i[5] = ot.y, i[9] = lt.y, i[2] = at.z, i[6] = ot.z, i[10] = lt.z, this
            }
            multiply(e, t) {
                return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    s = n[0],
                    a = n[4],
                    o = n[8],
                    l = n[12],
                    c = n[1],
                    h = n[5],
                    u = n[9],
                    d = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    x = n[7],
                    w = n[11],
                    b = n[15],
                    _ = i[0],
                    y = i[4],
                    A = i[8],
                    M = i[12],
                    S = i[1],
                    E = i[5],
                    T = i[9],
                    C = i[13],
                    D = i[2],
                    P = i[6],
                    R = i[10],
                    L = i[14],
                    I = i[3],
                    B = i[7],
                    O = i[11],
                    k = i[15];
                return r[0] = s * _ + a * S + o * D + l * I, r[4] = s * y + a * E + o * P + l * B, r[8] = s * A + a * T + o * R + l * O, r[12] = s * M + a * C + o * L + l * k, r[1] = c * _ + h * S + u * D + d * I, r[5] = c * y + h * E + u * P + d * B, r[9] = c * A + h * T + u * R + d * O, r[13] = c * M + h * C + u * L + d * k, r[2] = p * _ + f * S + m * D + g * I, r[6] = p * y + f * E + m * P + g * B, r[10] = p * A + f * T + m * R + g * O, r[14] = p * M + f * C + m * L + g * k, r[3] = v * _ + x * S + w * D + b * I, r[7] = v * y + x * E + w * P + b * B, r[11] = v * A + x * T + w * R + b * O, r[15] = v * M + x * C + w * L + b * k, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[4],
                    i = e[8],
                    r = e[12],
                    s = e[1],
                    a = e[5],
                    o = e[9],
                    l = e[13],
                    c = e[2],
                    h = e[6],
                    u = e[10],
                    d = e[14];
                return e[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * h - t * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * h + t * a * u + i * s * h - n * s * u + n * o * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            }
            setPosition(e, t, n) {
                const i = this.elements;
                return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    s = e[4],
                    a = e[5],
                    o = e[6],
                    l = e[7],
                    c = e[8],
                    h = e[9],
                    u = e[10],
                    d = e[11],
                    p = e[12],
                    f = e[13],
                    m = e[14],
                    g = e[15],
                    v = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
                    x = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
                    w = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
                    b = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
                    _ = t * v + n * x + i * w + r * b;
                if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const y = 1 / _;
                return e[0] = v * y, e[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * y, e[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * y, e[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * y, e[4] = x * y, e[5] = (c * m * r - p * u * r + p * i * d - t * m * d - c * i * g + t * u * g) * y, e[6] = (p * o * r - s * m * r - p * i * l + t * m * l + s * i * g - t * o * g) * y, e[7] = (s * u * r - c * o * r + c * i * l - t * u * l - s * i * d + t * o * d) * y, e[8] = w * y, e[9] = (p * h * r - c * f * r - p * n * d + t * f * d + c * n * g - t * h * g) * y, e[10] = (s * f * r - p * a * r + p * n * l - t * f * l - s * n * g + t * a * g) * y, e[11] = (c * a * r - s * h * r - c * n * l + t * h * l + s * n * d - t * a * d) * y, e[12] = b * y, e[13] = (c * f * i - p * h * i + p * n * u - t * f * u - c * n * m + t * h * m) * y, e[14] = (p * a * i - s * f * i - p * n * o + t * f * o + s * n * m - t * a * m) * y, e[15] = (s * h * i - c * a * i + c * n * o - t * h * o - s * n * u + t * a * u) * y, this
            }
            scale(e) {
                const t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z;
                return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            }
            makeTranslation(e, t, n) {
                return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            }
            makeRotationY(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t),
                    i = Math.sin(t),
                    r = 1 - n,
                    s = e.x,
                    a = e.y,
                    o = e.z,
                    l = r * s,
                    c = r * a;
                return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(e, t, n, i, r, s) {
                return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this
            }
            compose(e, t, n) {
                const i = this.elements,
                    r = t._x,
                    s = t._y,
                    a = t._z,
                    o = t._w,
                    l = r + r,
                    c = s + s,
                    h = a + a,
                    u = r * l,
                    d = r * c,
                    p = r * h,
                    f = s * c,
                    m = s * h,
                    g = a * h,
                    v = o * l,
                    x = o * c,
                    w = o * h,
                    b = n.x,
                    _ = n.y,
                    y = n.z;
                return i[0] = (1 - (f + g)) * b, i[1] = (d + w) * b, i[2] = (p - x) * b, i[3] = 0, i[4] = (d - w) * _, i[5] = (1 - (u + g)) * _, i[6] = (m + v) * _, i[7] = 0, i[8] = (p + x) * y, i[9] = (m - v) * y, i[10] = (1 - (u + f)) * y, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
            }
            decompose(e, t, n) {
                const i = this.elements;
                let r = nt.set(i[0], i[1], i[2]).length();
                const s = nt.set(i[4], i[5], i[6]).length(),
                    a = nt.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], it.copy(this);
                const o = 1 / r,
                    l = 1 / s,
                    c = 1 / a;
                return it.elements[0] *= o, it.elements[1] *= o, it.elements[2] *= o, it.elements[4] *= l, it.elements[5] *= l, it.elements[6] *= l, it.elements[8] *= c, it.elements[9] *= c, it.elements[10] *= c, t.setFromRotationMatrix(it), n.x = r, n.y = s, n.z = a, this
            }
            makePerspective(e, t, n, i, r, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const a = this.elements,
                    o = 2 * r / (t - e),
                    l = 2 * r / (n - i),
                    c = (t + e) / (t - e),
                    h = (n + i) / (n - i),
                    u = -(s + r) / (s - r),
                    d = -2 * s * r / (s - r);
                return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            }
            makeOrthographic(e, t, n, i, r, s) {
                const a = this.elements,
                    o = 1 / (t - e),
                    l = 1 / (n - i),
                    c = 1 / (s - r),
                    h = (t + e) * o,
                    u = (n + i) * l,
                    d = (s + r) * c;
                return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let e = 0; e < 16; e++)
                    if (t[e] !== n[e]) return !1;
                return !0
            }
            fromArray(e, t = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
            }
        }
        const nt = new Me,
            it = new tt,
            rt = new Me(0, 0, 0),
            st = new Me(1, 1, 1),
            at = new Me,
            ot = new Me,
            lt = new Me,
            ct = new tt,
            ht = new Ae;
        class ut {
            constructor(e = 0, t = 0, n = 0, i = ut.DefaultOrder) {
                this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e, this._onChangeCallback()
            }
            set(e, t, n, i = this._order) {
                return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(e, t = this._order, n = !0) {
                const i = e.elements,
                    r = i[0],
                    s = i[4],
                    a = i[8],
                    o = i[1],
                    l = i[5],
                    c = i[9],
                    h = i[2],
                    u = i[6],
                    d = i[10];
                switch (t) {
                    case "XYZ":
                        this._y = Math.asin(W(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-W(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(W(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-W(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(W(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-W(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(e, t, n) {
                return ct.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ct, t, n)
            }
            setFromVector3(e, t = this._order) {
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return ht.setFromEuler(this), this.setFromQuaternion(ht, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
            }
            toArray(e = [], t = 0) {
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
            toVector3() {
                console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
            }
        }
        ut.DefaultOrder = "XYZ", ut.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class dt {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = (1 << e | 0) >>> 0
            }
            enable(e) {
                this.mask |= 1 << e | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e | 0
            }
            disable(e) {
                this.mask &= ~(1 << e | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return 0 != (this.mask & e.mask)
            }
            isEnabled(e) {
                return 0 != (this.mask & (1 << e | 0))
            }
        }
        let pt = 0;
        const ft = new Me,
            mt = new Ae,
            gt = new tt,
            vt = new Me,
            xt = new Me,
            wt = new Me,
            bt = new Ae,
            _t = new Me(1, 0, 0),
            yt = new Me(0, 1, 0),
            At = new Me(0, 0, 1),
            Mt = {
                type: "added"
            },
            St = {
                type: "removed"
            };
        class Et extends F {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: pt++
                }), this.uuid = G(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Et.DefaultUp.clone();
                const e = new Me,
                    t = new ut,
                    n = new Ae,
                    i = new Me(1, 1, 1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                })), n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new tt
                    },
                    normalMatrix: {
                        value: new J
                    }
                }), this.matrix = new tt, this.matrixWorld = new tt, this.matrixAutoUpdate = Et.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new dt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e), this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return mt.setFromAxisAngle(e, t), this.quaternion.multiply(mt), this
            }
            rotateOnWorldAxis(e, t) {
                return mt.setFromAxisAngle(e, t), this.quaternion.premultiply(mt), this
            }
            rotateX(e) {
                return this.rotateOnAxis(_t, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(yt, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(At, e)
            }
            translateOnAxis(e, t) {
                return ft.copy(e).applyQuaternion(this.quaternion), this.position.add(ft.multiplyScalar(t)), this
            }
            translateX(e) {
                return this.translateOnAxis(_t, e)
            }
            translateY(e) {
                return this.translateOnAxis(yt, e)
            }
            translateZ(e) {
                return this.translateOnAxis(At, e)
            }
            localToWorld(e) {
                return e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return e.applyMatrix4(gt.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? vt.copy(e) : vt.set(e, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), xt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? gt.lookAt(xt, vt, this.up) : gt.lookAt(vt, xt, this.up), this.quaternion.setFromRotationMatrix(gt), i && (gt.extractRotation(i.matrixWorld), mt.setFromRotationMatrix(gt), this.quaternion.premultiply(mt.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Mt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(St)), this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this), this
            }
            clear() {
                for (let e = 0; e < this.children.length; e++) {
                    const t = this.children[e];
                    t.parent = null, t.dispatchEvent(St)
                }
                return this.children.length = 0, this
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1), gt.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), gt.multiply(e.parent.matrixWorld)), e.applyMatrix4(gt), this.add(e), e.updateWorldMatrix(!1, !0), this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== i) return i
                }
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xt, e, wt), e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xt, bt, e), e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible) return;
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t), t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e,
                    n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};

                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                r(e.shapes, i)
                            } else r(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                        i.material = t
                    } else i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        i.animations.push(r(e.animations, n))
                    }
                }
                if (t) {
                    const t = s(e.geometries),
                        i = s(e.materials),
                        r = s(e.textures),
                        a = s(e.images),
                        o = s(e.shapes),
                        l = s(e.skeletons),
                        c = s(e.animations),
                        h = s(e.nodes);
                    t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), h.length > 0 && (n.nodes = h)
                }
                return n.object = i, n;

                function s(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata, t.push(i)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e, t = !0) {
                if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                    for (let t = 0; t < e.children.length; t++) {
                        const n = e.children[t];
                        this.add(n.clone())
                    }
                return this
            }
        }
        Et.DefaultUp = new Me(0, 1, 0), Et.DefaultMatrixAutoUpdate = !0;
        const Tt = new Me,
            Ct = new Me,
            Dt = new Me,
            Pt = new Me,
            Rt = new Me,
            Lt = new Me,
            It = new Me,
            Bt = new Me,
            Ot = new Me,
            kt = new Me;
        class Nt {
            constructor(e = new Me, t = new Me, n = new Me) {
                this.a = e, this.b = t, this.c = n
            }
            static getNormal(e, t, n, i) {
                i.subVectors(n, t), Tt.subVectors(e, t), i.cross(Tt);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, i, r) {
                Tt.subVectors(i, t), Ct.subVectors(n, t), Dt.subVectors(e, t);
                const s = Tt.dot(Tt),
                    a = Tt.dot(Ct),
                    o = Tt.dot(Dt),
                    l = Ct.dot(Ct),
                    c = Ct.dot(Dt),
                    h = s * l - a * a;
                if (0 === h) return r.set(-2, -1, -1);
                const u = 1 / h,
                    d = (l * o - a * c) * u,
                    p = (s * c - a * o) * u;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(e, t, n, i) {
                return this.getBarycoord(e, t, n, i, Pt), Pt.x >= 0 && Pt.y >= 0 && Pt.x + Pt.y <= 1
            }
            static getUV(e, t, n, i, r, s, a, o) {
                return this.getBarycoord(e, t, n, i, Pt), o.set(0, 0), o.addScaledVector(r, Pt.x), o.addScaledVector(s, Pt.y), o.addScaledVector(a, Pt.z), o
            }
            static isFrontFacing(e, t, n, i) {
                return Tt.subVectors(n, t), Ct.subVectors(e, t), Tt.cross(Ct).dot(i) < 0
            }
            set(e, t, n) {
                return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            }
            setFromPointsAndIndices(e, t, n, i) {
                return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
            }
            setFromAttributeAndIndices(e, t, n, i) {
                return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            }
            getArea() {
                return Tt.subVectors(this.c, this.b), Ct.subVectors(this.a, this.b), .5 * Tt.cross(Ct).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return Nt.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return Nt.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getUV(e, t, n, i, r) {
                return Nt.getUV(e, this.a, this.b, this.c, t, n, i, r)
            }
            containsPoint(e) {
                return Nt.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return Nt.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let s, a;
                Rt.subVectors(i, n), Lt.subVectors(r, n), Bt.subVectors(e, n);
                const o = Rt.dot(Bt),
                    l = Lt.dot(Bt);
                if (o <= 0 && l <= 0) return t.copy(n);
                Ot.subVectors(e, i);
                const c = Rt.dot(Ot),
                    h = Lt.dot(Ot);
                if (c >= 0 && h <= c) return t.copy(i);
                const u = o * h - c * l;
                if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(Rt, s);
                kt.subVectors(e, r);
                const d = Rt.dot(kt),
                    p = Lt.dot(kt);
                if (p >= 0 && d <= p) return t.copy(r);
                const f = d * l - o * p;
                if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(Lt, a);
                const m = c * p - d * h;
                if (m <= 0 && h - c >= 0 && d - p >= 0) return It.subVectors(r, i), a = (h - c) / (h - c + (d - p)), t.copy(i).addScaledVector(It, a);
                const g = 1 / (m + f + u);
                return s = f * g, a = u * g, t.copy(n).addScaledVector(Rt, s).addScaledVector(Lt, a)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        let Ft = 0;
        class Ut extends F {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: Ft++
                }), this.uuid = G(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = B, this.stencilZFail = B, this.stencilZPass = B, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === t) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            continue
                        }
                        const i = this[t];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata, t.push(i)
                    }
                    return t
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                    const t = i(e.textures),
                        r = i(e.images);
                    t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
        }
        class zt extends Ut {
            constructor(e) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
            }
        }
        const Vt = new Me,
            Ht = new Z;
        class Gt {
            constructor(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = O, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setUsage(e) {
                return this.usage = e, this
            }
            copy(e) {
                return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
            }
            copyAt(e, t, n) {
                e *= this.itemSize, n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            }
            copyArray(e) {
                return this.array.set(e), this
            }
            copyColorsArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new ue), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b
                }
                return this
            }
            copyVector2sArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Z), t[n++] = r.x, t[n++] = r.y
                }
                return this
            }
            copyVector3sArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Me), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z
                }
                return this
            }
            copyVector4sArray(e) {
                const t = this.array;
                let n = 0;
                for (let i = 0, r = e.length; i < r; i++) {
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new xe), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w
                }
                return this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++) Ht.fromBufferAttribute(this, t), Ht.applyMatrix3(e), this.setXY(t, Ht.x, Ht.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++) Vt.fromBufferAttribute(this, t), Vt.applyMatrix3(e), this.setXYZ(t, Vt.x, Vt.y, Vt.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++) Vt.fromBufferAttribute(this, t), Vt.applyMatrix4(e), this.setXYZ(t, Vt.x, Vt.y, Vt.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) Vt.fromBufferAttribute(this, t), Vt.applyNormalMatrix(e), this.setXYZ(t, Vt.x, Vt.y, Vt.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) Vt.fromBufferAttribute(this, t), Vt.transformDirection(e), this.setXYZ(t, Vt.x, Vt.y, Vt.z);
                return this
            }
            set(e, t = 0) {
                return this.array.set(e, t), this
            }
            getX(e) {
                return this.array[e * this.itemSize]
            }
            setX(e, t) {
                return this.array[e * this.itemSize] = t, this
            }
            getY(e) {
                return this.array[e * this.itemSize + 1]
            }
            setY(e, t) {
                return this.array[e * this.itemSize + 1] = t, this
            }
            getZ(e) {
                return this.array[e * this.itemSize + 2]
            }
            setZ(e, t) {
                return this.array[e * this.itemSize + 2] = t, this
            }
            getW(e) {
                return this.array[e * this.itemSize + 3]
            }
            setW(e, t) {
                return this.array[e * this.itemSize + 3] = t, this
            }
            setXY(e, t, n) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
            }
            setXYZ(e, t, n, i) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
            }
            setXYZW(e, t, n, i, r) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name), this.usage !== O && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
            }
        }
        class Wt extends Gt {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class jt extends Gt {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class Yt extends Gt {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        let Xt = 0;
        const Qt = new tt,
            qt = new Et,
            Kt = new Me,
            Zt = new Te,
            Jt = new Te,
            $t = new Me;
        class en extends F {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: Xt++
                }), this.uuid = G(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new($(e) ? jt : Wt)(e, 1) : this.index = e, this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t, this
            }
            deleteAttribute(e) {
                return delete this.attributes[e], this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t, n = 0) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e, this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new J).getNormalMatrix(e);
                    n.applyNormalMatrix(t), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(e) {
                return Qt.makeRotationFromQuaternion(e), this.applyMatrix4(Qt), this
            }
            rotateX(e) {
                return Qt.makeRotationX(e), this.applyMatrix4(Qt), this
            }
            rotateY(e) {
                return Qt.makeRotationY(e), this.applyMatrix4(Qt), this
            }
            rotateZ(e) {
                return Qt.makeRotationZ(e), this.applyMatrix4(Qt), this
            }
            translate(e, t, n) {
                return Qt.makeTranslation(e, t, n), this.applyMatrix4(Qt), this
            }
            scale(e, t, n) {
                return Qt.makeScale(e, t, n), this.applyMatrix4(Qt), this
            }
            lookAt(e) {
                return qt.lookAt(e), qt.updateMatrix(), this.applyMatrix4(qt.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Kt).negate(), this.translate(Kt.x, Kt.y, Kt.z), this
            }
            setFromPoints(e) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    t.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Yt(t, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new Te);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Me(-1 / 0, -1 / 0, -1 / 0), new Me(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Zt.setFromBufferAttribute(n), this.morphTargetsRelative ? ($t.addVectors(this.boundingBox.min, Zt.min), this.boundingBox.expandByPoint($t), $t.addVectors(this.boundingBox.max, Zt.max), this.boundingBox.expandByPoint($t)) : (this.boundingBox.expandByPoint(Zt.min), this.boundingBox.expandByPoint(Zt.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Ye);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Me, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (Zt.setFromBufferAttribute(e), t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Jt.setFromBufferAttribute(n), this.morphTargetsRelative ? ($t.addVectors(Zt.min, Jt.min), Zt.expandByPoint($t), $t.addVectors(Zt.max, Jt.max), Zt.expandByPoint($t)) : (Zt.expandByPoint(Jt.min), Zt.expandByPoint(Jt.max))
                        }
                    Zt.getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.count; t < r; t++) $t.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared($t));
                    if (t)
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r],
                                a = this.morphTargetsRelative;
                            for (let t = 0, r = s.count; t < r; t++) $t.fromBufferAttribute(s, t), a && (Kt.fromBufferAttribute(e, t), $t.add(Kt)), i = Math.max(i, n.distanceToSquared($t))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index,
                    t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = e.array,
                    i = t.position.array,
                    r = t.normal.array,
                    s = t.uv.array,
                    a = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Gt(new Float32Array(4 * a), 4));
                const o = this.getAttribute("tangent").array,
                    l = [],
                    c = [];
                for (let e = 0; e < a; e++) l[e] = new Me, c[e] = new Me;
                const h = new Me,
                    u = new Me,
                    d = new Me,
                    p = new Z,
                    f = new Z,
                    m = new Z,
                    g = new Me,
                    v = new Me;

                function x(e, t, n) {
                    h.fromArray(i, 3 * e), u.fromArray(i, 3 * t), d.fromArray(i, 3 * n), p.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * n), u.sub(h), d.sub(h), f.sub(p), m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v))
                }
                let w = this.groups;
                0 === w.length && (w = [{
                    start: 0,
                    count: n.length
                }]);
                for (let e = 0, t = w.length; e < t; ++e) {
                    const t = w[e],
                        i = t.start;
                    for (let e = i, r = i + t.count; e < r; e += 3) x(n[e + 0], n[e + 1], n[e + 2])
                }
                const b = new Me,
                    _ = new Me,
                    y = new Me,
                    A = new Me;

                function M(e) {
                    y.fromArray(r, 3 * e), A.copy(y);
                    const t = l[e];
                    b.copy(t), b.sub(y.multiplyScalar(y.dot(t))).normalize(), _.crossVectors(A, t);
                    const n = _.dot(c[e]) < 0 ? -1 : 1;
                    o[4 * e] = b.x, o[4 * e + 1] = b.y, o[4 * e + 2] = b.z, o[4 * e + 3] = n
                }
                for (let e = 0, t = w.length; e < t; ++e) {
                    const t = w[e],
                        i = t.start;
                    for (let e = i, r = i + t.count; e < r; e += 3) M(n[e + 0]), M(n[e + 1]), M(n[e + 2])
                }
            }
            computeVertexNormals() {
                const e = this.index,
                    t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Gt(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                    const i = new Me,
                        r = new Me,
                        s = new Me,
                        a = new Me,
                        o = new Me,
                        l = new Me,
                        c = new Me,
                        h = new Me;
                    if (e)
                        for (let u = 0, d = e.count; u < d; u += 3) {
                            const d = e.getX(u + 0),
                                p = e.getX(u + 1),
                                f = e.getX(u + 2);
                            i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
                        } else
                            for (let e = 0, a = t.count; e < a; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            merge(e, t) {
                if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const i in n) {
                    if (void 0 === e.attributes[i]) continue;
                    const r = n[i].array,
                        s = e.attributes[i],
                        a = s.array,
                        o = s.itemSize * t,
                        l = Math.min(a.length, r.length - o);
                    for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e]
                }
                return this
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++) $t.fromBufferAttribute(e, t), $t.normalize(), e.setXYZ(t, $t.x, $t.y, $t.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array,
                        i = e.itemSize,
                        r = e.normalized,
                        s = new n.constructor(t.length * i);
                    let a = 0,
                        o = 0;
                    for (let r = 0, l = t.length; r < l; r++) {
                        a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                        for (let e = 0; e < i; e++) s[o++] = n[a++]
                    }
                    return new Gt(s, i, r)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const t = new en,
                    n = this.index.array,
                    i = this.attributes;
                for (const r in i) {
                    const s = e(i[r], n);
                    t.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = [],
                        a = r[i];
                    for (let t = 0, i = a.length; t < i; t++) {
                        const i = e(a[t], n);
                        s.push(i)
                    }
                    t.morphAttributes[i] = s
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let e = 0, n = s.length; e < n; e++) {
                    const n = s[e];
                    t.addGroup(n.start, n.count, n.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const t in n) {
                    const i = n[t];
                    e.data.attributes[t] = i.toJSON(e.data)
                }
                const i = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const n = this.morphAttributes[t],
                        s = [];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        s.push(i.toJSON(e.data))
                    }
                    s.length > 0 && (i[t] = s, r = !0)
                }
                r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                const a = this.boundingSphere;
                return null !== a && (e.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }), e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const i = e.attributes;
                for (const e in i) {
                    const n = i[e];
                    this.setAttribute(e, n.clone(t))
                }
                const r = e.morphAttributes;
                for (const e in r) {
                    const n = [],
                        i = r[e];
                    for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                    this.morphAttributes[e] = n
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const s = e.groups;
                for (let e = 0, t = s.length; e < t; e++) {
                    const t = s[e];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const a = e.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const o = e.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const tn = new tt,
            nn = new et,
            rn = new Ye,
            sn = new Me,
            an = new Me,
            on = new Me,
            ln = new Me,
            cn = new Me,
            hn = new Me,
            un = new Me,
            dn = new Me,
            pn = new Me,
            fn = new Z,
            mn = new Z,
            gn = new Z,
            vn = new Me,
            xn = new Me;
        class wn extends Et {
            constructor(e = new en, t = new zt) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (void 0 === i) return;
                if (null === n.boundingSphere && n.computeBoundingSphere(), rn.copy(n.boundingSphere), rn.applyMatrix4(r), !1 === e.ray.intersectsSphere(rn)) return;
                if (tn.copy(r).invert(), nn.copy(e.ray).applyMatrix4(tn), null !== n.boundingBox && !1 === nn.intersectsBox(n.boundingBox)) return;
                let s;
                const a = n.index,
                    o = n.attributes.position,
                    l = n.morphAttributes.position,
                    c = n.morphTargetsRelative,
                    h = n.attributes.uv,
                    u = n.attributes.uv2,
                    d = n.groups,
                    p = n.drawRange;
                if (null !== a)
                    if (Array.isArray(i))
                        for (let n = 0, r = d.length; n < r; n++) {
                            const r = d[n],
                                f = i[r.materialIndex];
                            for (let n = Math.max(r.start, p.start), i = Math.min(a.count, Math.min(r.start + r.count, p.start + p.count)); n < i; n += 3) {
                                const i = a.getX(n),
                                    d = a.getX(n + 1),
                                    p = a.getX(n + 2);
                                s = bn(this, f, e, nn, o, l, c, h, u, i, d, p), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, t.push(s))
                            }
                        } else
                            for (let n = Math.max(0, p.start), r = Math.min(a.count, p.start + p.count); n < r; n += 3) {
                                const r = a.getX(n),
                                    d = a.getX(n + 1),
                                    p = a.getX(n + 2);
                                s = bn(this, i, e, nn, o, l, c, h, u, r, d, p), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
                            } else if (void 0 !== o)
                                if (Array.isArray(i))
                                    for (let n = 0, r = d.length; n < r; n++) {
                                        const r = d[n],
                                            a = i[r.materialIndex];
                                        for (let n = Math.max(r.start, p.start), i = Math.min(o.count, Math.min(r.start + r.count, p.start + p.count)); n < i; n += 3) s = bn(this, a, e, nn, o, l, c, h, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, t.push(s))
                                    } else
                                        for (let n = Math.max(0, p.start), r = Math.min(o.count, p.start + p.count); n < r; n += 3) s = bn(this, i, e, nn, o, l, c, h, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
            }
        }

        function bn(e, t, n, i, r, s, a, o, l, c, h, u) {
            sn.fromBufferAttribute(r, c), an.fromBufferAttribute(r, h), on.fromBufferAttribute(r, u);
            const d = e.morphTargetInfluences;
            if (s && d) {
                un.set(0, 0, 0), dn.set(0, 0, 0), pn.set(0, 0, 0);
                for (let e = 0, t = s.length; e < t; e++) {
                    const t = d[e],
                        n = s[e];
                    0 !== t && (ln.fromBufferAttribute(n, c), cn.fromBufferAttribute(n, h), hn.fromBufferAttribute(n, u), a ? (un.addScaledVector(ln, t), dn.addScaledVector(cn, t), pn.addScaledVector(hn, t)) : (un.addScaledVector(ln.sub(sn), t), dn.addScaledVector(cn.sub(an), t), pn.addScaledVector(hn.sub(on), t)))
                }
                sn.add(un), an.add(dn), on.add(pn)
            }
            e.isSkinnedMesh && (e.boneTransform(c, sn), e.boneTransform(h, an), e.boneTransform(u, on));
            const p = function(e, t, n, i, r, s, a, o) {
                let l;
                if (l = 1 === t.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== t.side, o), null === l) return null;
                xn.copy(o), xn.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(xn);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: xn.clone(),
                    object: e
                }
            }(e, t, n, i, sn, an, on, vn);
            if (p) {
                o && (fn.fromBufferAttribute(o, c), mn.fromBufferAttribute(o, h), gn.fromBufferAttribute(o, u), p.uv = Nt.getUV(vn, sn, an, on, fn, mn, gn, new Z)), l && (fn.fromBufferAttribute(l, c), mn.fromBufferAttribute(l, h), gn.fromBufferAttribute(l, u), p.uv2 = Nt.getUV(vn, sn, an, on, fn, mn, gn, new Z));
                const e = {
                    a: c,
                    b: h,
                    c: u,
                    normal: new Me,
                    materialIndex: 0
                };
                Nt.getNormal(sn, an, on, e.normal), p.face = e
            }
            return p
        }
        class _n extends en {
            constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const a = this;
                i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                const o = [],
                    l = [],
                    c = [],
                    h = [];
                let u = 0,
                    d = 0;

                function p(e, t, n, i, r, s, p, f, m, g, v) {
                    const x = s / m,
                        w = p / g,
                        b = s / 2,
                        _ = p / 2,
                        y = f / 2,
                        A = m + 1,
                        M = g + 1;
                    let S = 0,
                        E = 0;
                    const T = new Me;
                    for (let s = 0; s < M; s++) {
                        const a = s * w - _;
                        for (let o = 0; o < A; o++) {
                            const u = o * x - b;
                            T[e] = u * i, T[t] = a * r, T[n] = y, l.push(T.x, T.y, T.z), T[e] = 0, T[t] = 0, T[n] = f > 0 ? 1 : -1, c.push(T.x, T.y, T.z), h.push(o / m), h.push(1 - s / g), S += 1
                        }
                    }
                    for (let e = 0; e < g; e++)
                        for (let t = 0; t < m; t++) {
                            const n = u + t + A * e,
                                i = u + t + A * (e + 1),
                                r = u + (t + 1) + A * (e + 1),
                                s = u + (t + 1) + A * e;
                            o.push(n, i, s), o.push(i, r, s), E += 6
                        }
                    a.addGroup(d, E, v), d += E, u += S
                }
                p("z", "y", "x", -1, -1, n, t, e, s, r, 0), p("z", "y", "x", 1, -1, n, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, s, 2), p("x", "z", "y", 1, -1, e, n, -t, i, s, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new Yt(l, 3)), this.setAttribute("normal", new Yt(c, 3)), this.setAttribute("uv", new Yt(h, 2))
            }
            static fromJSON(e) {
                return new _n(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
            }
        }

        function yn(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const i in e[n]) {
                    const r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                }
            }
            return t
        }

        function An(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const i = yn(e[n]);
                for (const e in i) t[e] = i[e]
            }
            return t
        }
        const Mn = {
            clone: yn,
            merge: An
        };
        class Sn extends Ut {
            constructor(e) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }
            copy(e) {
                return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = yn(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion, t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(e).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : t.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                const n = {};
                for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n), t
            }
        }
        class En extends Et {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new tt, this.projectionMatrix = new tt, this.projectionMatrixInverse = new tt
            }
            copy(e, t) {
                return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(-t[8], -t[9], -t[10]).normalize()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Tn extends En {
            constructor(e = 50, t = 1, n = .1, i = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * H * Math.atan(t), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * V * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * H * Math.atan(Math.tan(.5 * V * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(e, t, n, i, r, s) {
                this.aspect = e / t, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * V * this.fov) / this.zoom,
                    n = 2 * t,
                    i = this.aspect * n,
                    r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = s.fullWidth,
                        a = s.fullHeight;
                    r += s.offsetX * i / e, t -= s.offsetY * n / a, i *= s.width / e, n *= s.height / a
                }
                const a = this.filmOffset;
                0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }
        const Cn = 90;
        class Dn extends Et {
            constructor(e, t, n) {
                if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const i = new Tn(Cn, 1, e, t);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Me(1, 0, 0)), this.add(i);
                const r = new Tn(Cn, 1, e, t);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Me(-1, 0, 0)), this.add(r);
                const s = new Tn(Cn, 1, e, t);
                s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Me(0, 1, 0)), this.add(s);
                const a = new Tn(Cn, 1, e, t);
                a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Me(0, -1, 0)), this.add(a);
                const o = new Tn(Cn, 1, e, t);
                o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Me(0, 0, 1)), this.add(o);
                const l = new Tn(Cn, 1, e, t);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Me(0, 0, -1)), this.add(l)
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget,
                    [i, r, s, a, o, l] = this.children,
                    c = e.getRenderTarget(),
                    h = e.toneMapping,
                    u = e.xr.enabled;
                e.toneMapping = 0, e.xr.enabled = !1;
                const d = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = d, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(c), e.toneMapping = h, e.xr.enabled = u, n.texture.needsPMREMUpdate = !0
            }
        }
        class Pn extends ve {
            constructor(e, t, n, i, s, a, o, l, c, h) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : r, n, i, s, a, o, l, c, h), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class Rn extends we {
            constructor(e, t = {}) {
                super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: e,
                        height: e,
                        depth: 1
                    },
                    i = [n, n, n, n, n, n];
                this.texture = new Pn(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : p
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                const n = {
                        tEquirect: {
                            value: null
                        }
                    },
                    i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                    s = new _n(5, 5, 5),
                    a = new Sn({
                        name: "CubemapFromEquirect",
                        uniforms: yn(n),
                        vertexShader: i,
                        fragmentShader: r,
                        side: 1,
                        blending: 0
                    });
                a.uniforms.tEquirect.value = t;
                const o = new wn(s, a),
                    l = t.minFilter;
                return t.minFilter === f && (t.minFilter = p), new Dn(1, 10, this).update(e, o), t.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
            }
            clear(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }
        const Ln = new Me,
            In = new Me,
            Bn = new J;
        class On {
            constructor(e = new Me(1, 0, 0), t = 0) {
                this.isPlane = !0, this.normal = e, this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e), this.constant = t, this
            }
            setComponents(e, t, n, i) {
                return this.normal.set(e, t, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e), this.constant = -t.dot(this.normal), this
            }
            setFromCoplanarPoints(e, t, n) {
                const i = Ln.subVectors(n, t).cross(In.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e), this
            }
            copy(e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
            }
            intersectLine(e, t) {
                const n = e.delta(Ln),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || Bn.getNormalMatrix(e),
                    i = this.coplanarPoint(Ln).applyMatrix4(e),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal), this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const kn = new Ye,
            Nn = new Me;
        class Fn {
            constructor(e = new On, t = new On, n = new On, i = new On, r = new On, s = new On) {
                this.planes = [e, t, n, i, r, s]
            }
            set(e, t, n, i, r, s) {
                const a = this.planes;
                return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e) {
                const t = this.planes,
                    n = e.elements,
                    i = n[0],
                    r = n[1],
                    s = n[2],
                    a = n[3],
                    o = n[4],
                    l = n[5],
                    c = n[6],
                    h = n[7],
                    u = n[8],
                    d = n[9],
                    p = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    x = n[15];
                return t[0].setComponents(a - i, h - o, f - u, x - m).normalize(), t[1].setComponents(a + i, h + o, f + u, x + m).normalize(), t[2].setComponents(a + r, h + l, f + d, x + g).normalize(), t[3].setComponents(a - r, h - l, f - d, x - g).normalize(), t[4].setComponents(a - s, h - c, f - p, x - v).normalize(), t[5].setComponents(a + s, h + c, f + p, x + v).normalize(), this
            }
            intersectsObject(e) {
                const t = e.geometry;
                return null === t.boundingSphere && t.computeBoundingSphere(), kn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(kn)
            }
            intersectsSprite(e) {
                return kn.center.set(0, 0, 0), kn.radius = .7071067811865476, kn.applyMatrix4(e.matrixWorld), this.intersectsSphere(kn)
            }
            intersectsSphere(e) {
                const t = this.planes,
                    n = e.center,
                    i = -e.radius;
                for (let e = 0; e < 6; e++)
                    if (t[e].distanceToPoint(n) < i) return !1;
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (Nn.x = i.normal.x > 0 ? e.max.x : e.min.x, Nn.y = i.normal.y > 0 ? e.max.y : e.min.y, Nn.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Nn) < 0) return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Un() {
            let e = null,
                t = !1,
                n = null,
                i = null;

            function r(t, s) {
                n(t, s), i = e.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(i), t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }

        function zn(e, t) {
            const n = t.isWebGL2,
                i = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
                },
                remove: function(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const n = i.get(t);
                    n && (e.deleteBuffer(n.buffer), i.delete(t))
                },
                update: function(t, r) {
                    if (t.isGLBufferAttribute) {
                        const e = i.get(t);
                        return void((!e || e.version < t.version) && i.set(t, {
                            buffer: t.buffer,
                            type: t.type,
                            bytesPerElement: t.elementSize,
                            version: t.version
                        }))
                    }
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const s = i.get(t);
                    void 0 === s ? i.set(t, function(t, i) {
                        const r = t.array,
                            s = t.usage,
                            a = e.createBuffer();
                        let o;
                        if (e.bindBuffer(i, a), e.bufferData(i, r, s), t.onUploadCallback(), r instanceof Float32Array) o = 5126;
                        else if (r instanceof Uint16Array)
                            if (t.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                o = 5131
                            } else o = 5123;
                        else if (r instanceof Int16Array) o = 5122;
                        else if (r instanceof Uint32Array) o = 5125;
                        else if (r instanceof Int32Array) o = 5124;
                        else if (r instanceof Int8Array) o = 5120;
                        else if (r instanceof Uint8Array) o = 5121;
                        else {
                            if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                            o = 5121
                        }
                        return {
                            buffer: a,
                            type: o,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: t.version
                        }
                    }(t, r)) : s.version < t.version && (function(t, i, r) {
                        const s = i.array,
                            a = i.updateRange;
                        e.bindBuffer(r, t), -1 === a.count ? e.bufferSubData(r, 0, s) : (n ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                    }(s.buffer, t, r), s.version = t.version)
                }
            }
        }
        class Vn extends en {
            constructor(e = 1, t = 1, n = 1, i = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = e / 2,
                    s = t / 2,
                    a = Math.floor(n),
                    o = Math.floor(i),
                    l = a + 1,
                    c = o + 1,
                    h = e / a,
                    u = t / o,
                    d = [],
                    p = [],
                    f = [],
                    m = [];
                for (let e = 0; e < c; e++) {
                    const t = e * u - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * h - r;
                        p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - e / o)
                    }
                }
                for (let e = 0; e < o; e++)
                    for (let t = 0; t < a; t++) {
                        const n = t + l * e,
                            i = t + l * (e + 1),
                            r = t + 1 + l * (e + 1),
                            s = t + 1 + l * e;
                        d.push(n, i, s), d.push(i, r, s)
                    }
                this.setIndex(d), this.setAttribute("position", new Yt(p, 3)), this.setAttribute("normal", new Yt(f, 3)), this.setAttribute("uv", new Yt(m, 2))
            }
            static fromJSON(e) {
                return new Vn(e.width, e.height, e.widthSegments, e.heightSegments)
            }
        }
        const Hn = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
            },
            Gn = {
                common: {
                    diffuse: {
                        value: new ue(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new J
                    },
                    uv2Transform: {
                        value: new J
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new Z(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new ue(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new ue(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new J
                    }
                },
                sprite: {
                    diffuse: {
                        value: new ue(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Z(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new J
                    }
                }
            },
            Wn = {
                basic: {
                    uniforms: An([Gn.common, Gn.specularmap, Gn.envmap, Gn.aomap, Gn.lightmap, Gn.fog]),
                    vertexShader: Hn.meshbasic_vert,
                    fragmentShader: Hn.meshbasic_frag
                },
                lambert: {
                    uniforms: An([Gn.common, Gn.specularmap, Gn.envmap, Gn.aomap, Gn.lightmap, Gn.emissivemap, Gn.fog, Gn.lights, {
                        emissive: {
                            value: new ue(0)
                        }
                    }]),
                    vertexShader: Hn.meshlambert_vert,
                    fragmentShader: Hn.meshlambert_frag
                },
                phong: {
                    uniforms: An([Gn.common, Gn.specularmap, Gn.envmap, Gn.aomap, Gn.lightmap, Gn.emissivemap, Gn.bumpmap, Gn.normalmap, Gn.displacementmap, Gn.fog, Gn.lights, {
                        emissive: {
                            value: new ue(0)
                        },
                        specular: {
                            value: new ue(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Hn.meshphong_vert,
                    fragmentShader: Hn.meshphong_frag
                },
                standard: {
                    uniforms: An([Gn.common, Gn.envmap, Gn.aomap, Gn.lightmap, Gn.emissivemap, Gn.bumpmap, Gn.normalmap, Gn.displacementmap, Gn.roughnessmap, Gn.metalnessmap, Gn.fog, Gn.lights, {
                        emissive: {
                            value: new ue(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Hn.meshphysical_vert,
                    fragmentShader: Hn.meshphysical_frag
                },
                toon: {
                    uniforms: An([Gn.common, Gn.aomap, Gn.lightmap, Gn.emissivemap, Gn.bumpmap, Gn.normalmap, Gn.displacementmap, Gn.gradientmap, Gn.fog, Gn.lights, {
                        emissive: {
                            value: new ue(0)
                        }
                    }]),
                    vertexShader: Hn.meshtoon_vert,
                    fragmentShader: Hn.meshtoon_frag
                },
                matcap: {
                    uniforms: An([Gn.common, Gn.bumpmap, Gn.normalmap, Gn.displacementmap, Gn.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: Hn.meshmatcap_vert,
                    fragmentShader: Hn.meshmatcap_frag
                },
                points: {
                    uniforms: An([Gn.points, Gn.fog]),
                    vertexShader: Hn.points_vert,
                    fragmentShader: Hn.points_frag
                },
                dashed: {
                    uniforms: An([Gn.common, Gn.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Hn.linedashed_vert,
                    fragmentShader: Hn.linedashed_frag
                },
                depth: {
                    uniforms: An([Gn.common, Gn.displacementmap]),
                    vertexShader: Hn.depth_vert,
                    fragmentShader: Hn.depth_frag
                },
                normal: {
                    uniforms: An([Gn.common, Gn.bumpmap, Gn.normalmap, Gn.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Hn.meshnormal_vert,
                    fragmentShader: Hn.meshnormal_frag
                },
                sprite: {
                    uniforms: An([Gn.sprite, Gn.fog]),
                    vertexShader: Hn.sprite_vert,
                    fragmentShader: Hn.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new J
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: Hn.background_vert,
                    fragmentShader: Hn.background_frag
                },
                cube: {
                    uniforms: An([Gn.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Hn.cube_vert,
                    fragmentShader: Hn.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: Hn.equirect_vert,
                    fragmentShader: Hn.equirect_frag
                },
                distanceRGBA: {
                    uniforms: An([Gn.common, Gn.displacementmap, {
                        referencePosition: {
                            value: new Me
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: Hn.distanceRGBA_vert,
                    fragmentShader: Hn.distanceRGBA_frag
                },
                shadow: {
                    uniforms: An([Gn.lights, Gn.fog, {
                        color: {
                            value: new ue(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Hn.shadow_vert,
                    fragmentShader: Hn.shadow_frag
                }
            };

        function jn(e, t, n, i, r, s) {
            const o = new ue(0);
            let l, c, h = !0 === r ? 0 : 1,
                u = null,
                d = 0,
                p = null;

            function f(e, t) {
                n.buffers.color.setClear(e.r, e.g, e.b, t, s)
            }
            return {
                getClearColor: function() {
                    return o
                },
                setClearColor: function(e, t = 1) {
                    o.set(e), h = t, f(o, h)
                },
                getClearAlpha: function() {
                    return h
                },
                setClearAlpha: function(e) {
                    h = e, f(o, h)
                },
                render: function(n, r) {
                    let s = !1,
                        m = !0 === r.isScene ? r.background : null;
                    m && m.isTexture && (m = t.get(m));
                    const g = e.xr,
                        v = g.getSession && g.getSession();
                    v && "additive" === v.environmentBlendMode && (m = null), null === m ? f(o, h) : m && m.isColor && (f(m, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.mapping === a) ? (void 0 === c && (c = new wn(new _n(1, 1, 1), new Sn({
                        name: "BackgroundCubeMaterial",
                        uniforms: yn(Wn.cube.uniforms),
                        vertexShader: Wn.cube.vertexShader,
                        fragmentShader: Wn.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), i.update(c)), c.material.uniforms.envMap.value = m, c.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, u === m && d === m.version && p === e.toneMapping || (c.material.needsUpdate = !0, u = m, d = m.version, p = e.toneMapping), c.layers.enableAll(), n.unshift(c, c.geometry, c.material, 0, 0, null)) : m && m.isTexture && (void 0 === l && (l = new wn(new Vn(2, 2), new Sn({
                        name: "BackgroundMaterial",
                        uniforms: yn(Wn.background.uniforms),
                        vertexShader: Wn.background.vertexShader,
                        fragmentShader: Wn.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(l)), l.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), l.material.uniforms.uvTransform.value.copy(m.matrix), u === m && d === m.version && p === e.toneMapping || (l.material.needsUpdate = !0, u = m, d = m.version, p = e.toneMapping), l.layers.enableAll(), n.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function Yn(e, t, n, i) {
            const r = e.getParameter(34921),
                s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                a = i.isWebGL2 || null !== s,
                o = {},
                l = p(null);
            let c = l,
                h = !1;

            function u(t) {
                return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
            }

            function d(t) {
                return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
            }

            function p(e) {
                const t = [],
                    n = [],
                    i = [];
                for (let e = 0; e < r; e++) t[e] = 0, n[e] = 0, i[e] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: e,
                    attributes: {},
                    index: null
                }
            }

            function f() {
                const e = c.newAttributes;
                for (let t = 0, n = e.length; t < n; t++) e[t] = 0
            }

            function m(e) {
                g(e, 0)
            }

            function g(n, r) {
                const s = c.newAttributes,
                    a = c.enabledAttributes,
                    o = c.attributeDivisors;
                s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== r && ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r)
            }

            function v() {
                const t = c.newAttributes,
                    n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
            }

            function x(t, n, r, s, a, o) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, s, a, o) : e.vertexAttribIPointer(t, n, r, a, o)
            }

            function w() {
                b(), h = !0, c !== l && (c = l, u(c.object))
            }

            function b() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function(r, l, d, w, b) {
                    let _ = !1;
                    if (a) {
                        const t = function(t, n, r) {
                            const a = !0 === r.wireframe;
                            let l = o[t.id];
                            void 0 === l && (l = {}, o[t.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {}, l[n.id] = c);
                            let h = c[a];
                            return void 0 === h && (h = p(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = h), h
                        }(w, d, l);
                        c !== t && (c = t, u(c.object)), _ = function(e, t, n, i) {
                            const r = c.attributes,
                                s = t.attributes;
                            let a = 0;
                            const o = n.getAttributes();
                            for (const t in o)
                                if (o[t].location >= 0) {
                                    const n = r[t];
                                    let i = s[t];
                                    if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)), void 0 === n) return !0;
                                    if (n.attribute !== i) return !0;
                                    if (i && n.data !== i.data) return !0;
                                    a++
                                }
                            return c.attributesNum !== a || c.index !== i
                        }(r, w, d, b), _ && function(e, t, n, i) {
                            const r = {},
                                s = t.attributes;
                            let a = 0;
                            const o = n.getAttributes();
                            for (const t in o)
                                if (o[t].location >= 0) {
                                    let n = s[t];
                                    void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                    const i = {};
                                    i.attribute = n, n && n.data && (i.data = n.data), r[t] = i, a++
                                }
                            c.attributes = r, c.attributesNum = a, c.index = i
                        }(r, w, d, b)
                    } else {
                        const e = !0 === l.wireframe;
                        c.geometry === w.id && c.program === d.id && c.wireframe === e || (c.geometry = w.id, c.program = d.id, c.wireframe = e, _ = !0)
                    }
                    null !== b && n.update(b, 34963), (_ || h) && (h = !1, function(r, s, a, o) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                        f();
                        const l = o.attributes,
                            c = a.getAttributes(),
                            h = s.defaultAttributeValues;
                        for (const t in c) {
                            const i = c[t];
                            if (i.location >= 0) {
                                let s = l[t];
                                if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                    const t = s.normalized,
                                        a = s.itemSize,
                                        l = n.get(s);
                                    if (void 0 === l) continue;
                                    const c = l.buffer,
                                        h = l.type,
                                        u = l.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data,
                                            l = n.stride,
                                            d = s.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < i.locationSize; e++) g(i.location + e, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let e = 0; e < i.locationSize; e++) m(i.location + e);
                                        e.bindBuffer(34962, c);
                                        for (let e = 0; e < i.locationSize; e++) x(i.location + e, a / i.locationSize, h, t, l * u, (d + a / i.locationSize * e) * u)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let e = 0; e < i.locationSize; e++) g(i.location + e, s.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let e = 0; e < i.locationSize; e++) m(i.location + e);
                                        e.bindBuffer(34962, c);
                                        for (let e = 0; e < i.locationSize; e++) x(i.location + e, a / i.locationSize, h, t, a * u, a / i.locationSize * e * u)
                                    }
                                } else if (void 0 !== h) {
                                    const n = h[t];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            e.vertexAttrib2fv(i.location, n);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(i.location, n);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(i.location, n);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(i.location, n)
                                    }
                                }
                            }
                        }
                        v()
                    }(r, l, d, w), null !== b && e.bindBuffer(34963, n.get(b).buffer))
                },
                reset: w,
                resetDefaultState: b,
                dispose: function() {
                    w();
                    for (const e in o) {
                        const t = o[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) d(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete o[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === o[e.id]) return;
                    const t = o[e.id];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n) d(n[e].object), delete n[e];
                        delete t[e]
                    }
                    delete o[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in o) {
                        const n = o[t];
                        if (void 0 === n[e.id]) continue;
                        const i = n[e.id];
                        for (const e in i) d(i[e].object), delete i[e];
                        delete n[e.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }

        function Xn(e, t, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function(e) {
                s = e
            }, this.render = function(t, i) {
                e.drawArrays(s, t, i), n.update(i, s, 1)
            }, this.renderInstances = function(i, a, o) {
                if (0 === o) return;
                let l, c;
                if (r) l = e, c = "drawArraysInstanced";
                else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](s, i, a, o), n.update(a, s, o)
            }
        }

        function Qn(e, t, n) {
            let i;

            function r(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const o = r(a);
            o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
            const l = s || t.has("WEBGL_draw_buffers"),
                c = !0 === n.logarithmicDepthBuffer,
                h = e.getParameter(34930),
                u = e.getParameter(35660),
                d = e.getParameter(3379),
                p = e.getParameter(34076),
                f = e.getParameter(34921),
                m = e.getParameter(36347),
                g = e.getParameter(36348),
                v = e.getParameter(36349),
                x = u > 0,
                w = s || t.has("OES_texture_float");
            return {
                isWebGL2: s,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== i) return i;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: c,
                maxTextures: h,
                maxVertexTextures: u,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: x,
                floatFragmentTextures: w,
                floatVertexTextures: x && w,
                maxSamples: s ? e.getParameter(36183) : 0
            }
        }

        function qn(e) {
            const t = this;
            let n = null,
                i = 0,
                r = !1,
                s = !1;
            const a = new On,
                o = new J,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function c() {
                l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
            }

            function h(e, n, i, r) {
                const s = null !== e ? e.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value, !0 !== r || null === c) {
                        const t = i + 4 * s,
                            r = n.matrixWorldInverse;
                        o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let t = 0, n = i; t !== s; ++t, n += 4) a.copy(e[t]).applyMatrix4(r, o), a.normal.toArray(c, n), c[n + 3] = a.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return t.numPlanes = s, t.numIntersection = 0, c
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, s) {
                const a = 0 !== e.length || t || 0 !== i || r;
                return r = t, n = h(e, s, 0), i = e.length, a
            }, this.beginShadows = function() {
                s = !0, h(null)
            }, this.endShadows = function() {
                s = !1, c()
            }, this.setState = function(t, a, o) {
                const u = t.clippingPlanes,
                    d = t.clipIntersection,
                    p = t.clipShadows,
                    f = e.get(t);
                if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : c();
                else {
                    const e = s ? 0 : i,
                        t = 4 * e;
                    let r = f.clippingState || null;
                    l.value = r, r = h(u, a, t, o);
                    for (let e = 0; e !== t; ++e) r[e] = n[e];
                    f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
                }
            }
        }

        function Kn(e) {
            let t = new WeakMap;

            function n(e, t) {
                return 303 === t ? e.mapping = r : 304 === t && (e.mapping = s), e
            }

            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n), r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const s = r.mapping;
                        if (303 === s || 304 === s) {
                            if (t.has(r)) return n(t.get(r).texture, r.mapping); {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const a = new Rn(s.height / 2);
                                    return a.fromEquirectangularTexture(e, r), t.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        Wn.physical = {
            uniforms: An([Wn.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Z(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new ue(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new Z
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new ue(0)
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularColor: {
                    value: new ue(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                }
            }]),
            vertexShader: Hn.meshphysical_vert,
            fragmentShader: Hn.meshphysical_frag
        };
        class Zn extends En {
            constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
            }
            setViewOffset(e, t, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - e,
                    s = n + e,
                    a = i + t,
                    o = i - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += e * this.view.offsetX, s = r + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        }
        const Jn = [.125, .215, .35, .446, .526, .582],
            $n = new Zn,
            ei = new ue;
        let ti = null;
        const ni = (1 + Math.sqrt(5)) / 2,
            ii = 1 / ni,
            ri = [new Me(1, 1, 1), new Me(-1, 1, 1), new Me(1, 1, -1), new Me(-1, 1, -1), new Me(0, ni, ii), new Me(0, ni, -ii), new Me(ii, 0, ni), new Me(-ii, 0, ni), new Me(ni, ii, 0), new Me(-ni, ii, 0)];
        class si {
            constructor(e) {
                this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, t = 0, n = .1, i = 100) {
                ti = this._renderer.getRenderTarget(), this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
            }
            fromEquirectangular(e, t = null) {
                return this._fromTexture(e, t)
            }
            fromCubemap(e, t = null) {
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = ci(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = li(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(ti), e.scissorTest = !1, oi(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === r || e.mapping === s ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), ti = this._renderer.getRenderTarget();
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112),
                    t = 4 * this._cubeSize,
                    n = {
                        magFilter: p,
                        minFilter: p,
                        generateMipmaps: !1,
                        type: x,
                        format: b,
                        encoding: P,
                        depthBuffer: !1
                    },
                    i = ai(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = ai(e, t, n);
                    const {
                        _lodMax: i
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function(e) {
                        const t = [],
                            n = [],
                            i = [];
                        let r = e;
                        const s = e - 4 + 1 + Jn.length;
                        for (let a = 0; a < s; a++) {
                            const s = Math.pow(2, r);
                            n.push(s);
                            let o = 1 / s;
                            a > e - 4 ? o = Jn[a - e + 4 - 1] : 0 === a && (o = 0), i.push(o);
                            const l = 1 / (s - 2),
                                c = -l,
                                h = 1 + l,
                                u = [c, c, h, c, h, h, c, c, h, h, c, h],
                                d = 6,
                                p = 6,
                                f = 3,
                                m = 2,
                                g = 1,
                                v = new Float32Array(f * p * d),
                                x = new Float32Array(m * p * d),
                                w = new Float32Array(g * p * d);
                            for (let e = 0; e < d; e++) {
                                const t = e % 3 * 2 / 3 - 1,
                                    n = e > 2 ? 0 : -1,
                                    i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                v.set(i, f * p * e), x.set(u, m * p * e);
                                const r = [e, e, e, e, e, e];
                                w.set(r, g * p * e)
                            }
                            const b = new en;
                            b.setAttribute("position", new Gt(v, f)), b.setAttribute("uv", new Gt(x, m)), b.setAttribute("faceIndex", new Gt(w, g)), t.push(b), r > 4 && r--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)), this._blurMaterial = function(e, t, n) {
                        const i = new Float32Array(20),
                            r = new Me(0, 1, 0);
                        return new Sn({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${e}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(i, e, t)
                }
                return i
            }
            _compileMaterial(e) {
                const t = new wn(this._lodPlanes[0], e);
                this._renderer.compile(t, $n)
            }
            _sceneToCubeUV(e, t, n, i) {
                const r = new Tn(90, 1, t, n),
                    s = [1, -1, 1, 1, 1, 1],
                    a = [1, 1, 1, -1, -1, -1],
                    o = this._renderer,
                    l = o.autoClear,
                    c = o.toneMapping;
                o.getClearColor(ei), o.toneMapping = 0, o.autoClear = !1;
                const h = new zt({
                        name: "PMREM.Background",
                        side: 1,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    u = new wn(new _n, h);
                let d = !1;
                const p = e.background;
                p ? p.isColor && (h.color.copy(p), e.background = null, d = !0) : (h.color.copy(ei), d = !0);
                for (let t = 0; t < 6; t++) {
                    const n = t % 3;
                    0 === n ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t]));
                    const l = this._cubeSize;
                    oi(i, n * l, t > 2 ? l : 0, l, l), o.setRenderTarget(i), d && o.render(u, r), o.render(e, r)
                }
                u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, e.background = p
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer,
                    i = e.mapping === r || e.mapping === s;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = ci()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = li());
                const a = i ? this._cubemapMaterial : this._equirectMaterial,
                    o = new wn(this._lodPlanes[0], a);
                a.uniforms.envMap.value = e;
                const l = this._cubeSize;
                oi(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, $n)
            }
            _applyPMREM(e) {
                const t = this._renderer,
                    n = t.autoClear;
                t.autoClear = !1;
                for (let t = 1; t < this._lodPlanes.length; t++) {
                    const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                        i = ri[(t - 1) % ri.length];
                    this._blur(e, t - 1, t, n, i)
                }
                t.autoClear = n
            }
            _blur(e, t, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r)
            }
            _halfBlur(e, t, n, i, r, s, a) {
                const o = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new wn(this._lodPlanes[i], l),
                    h = l.uniforms,
                    u = this._sizeLods[n] - 1,
                    d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                    p = r / d,
                    f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let e = 0; e < 20; ++e) {
                    const t = e / p,
                        n = Math.exp(-t * t / 2);
                    m.push(n), 0 === e ? g += n : e < f && (g += 2 * n)
                }
                for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
                h.envMap.value = e.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a);
                const {
                    _lodMax: v
                } = this;
                h.dTheta.value = d, h.mipInt.value = v - n;
                const x = this._sizeLods[i];
                oi(t, 3 * x * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - x), 3 * x, 2 * x), o.setRenderTarget(t), o.render(c, $n)
            }
        }

        function ai(e, t, n) {
            const i = new we(e, t, n);
            return i.texture.mapping = a, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
        }

        function oi(e, t, n, i, r) {
            e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
        }

        function li() {
            return new Sn({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function ci() {
            return new Sn({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function hi(e) {
            let t = new WeakMap,
                n = null;

            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n), r.dispose())
            }
            return {
                get: function(a) {
                    if (a && a.isTexture) {
                        const o = a.mapping,
                            l = 303 === o || 304 === o,
                            c = o === r || o === s;
                        if (l || c) {
                            if (a.isRenderTargetTexture && !0 === a.needsPMREMUpdate) {
                                a.needsPMREMUpdate = !1;
                                let i = t.get(a);
                                return null === n && (n = new si(e)), i = l ? n.fromEquirectangular(a, i) : n.fromCubemap(a, i), t.set(a, i), i.texture
                            }
                            if (t.has(a)) return t.get(a).texture; {
                                const r = a.image;
                                if (l && r && r.height > 0 || c && r && function(e) {
                                        let t = 0;
                                        for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                        return 6 === t
                                    }(r)) {
                                    null === n && (n = new si(e));
                                    const r = l ? n.fromEquirectangular(a) : n.fromCubemap(a);
                                    return t.set(a, r), a.addEventListener("dispose", i), r.texture
                                }
                                return null
                            }
                        }
                    }
                    return a
                },
                dispose: function() {
                    t = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function ui(e) {
            const t = {};

            function n(n) {
                if (void 0 !== t[n]) return t[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = e.getExtension(n)
                }
                return t[n] = i, i
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function(e) {
                    e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                }
            }
        }

        function di(e, t, n, i) {
            const r = {},
                s = new WeakMap;

            function a(e) {
                const o = e.target;
                null !== o.index && t.remove(o.index);
                for (const e in o.attributes) t.remove(o.attributes[e]);
                o.removeEventListener("dispose", a), delete r[o.id];
                const l = s.get(o);
                l && (t.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
            }

            function o(e) {
                const n = [],
                    i = e.index,
                    r = e.attributes.position;
                let a = 0;
                if (null !== i) {
                    const e = i.array;
                    a = i.version;
                    for (let t = 0, i = e.length; t < i; t += 3) {
                        const i = e[t + 0],
                            r = e[t + 1],
                            s = e[t + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    const e = r.array;
                    a = r.version;
                    for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                        const e = t + 0,
                            i = t + 1,
                            r = t + 2;
                        n.push(e, i, i, r, r, e)
                    }
                }
                const o = new($(n) ? jt : Wt)(n, 1);
                o.version = a;
                const l = s.get(e);
                l && t.remove(l), s.set(e, o)
            }
            return {
                get: function(e, t) {
                    return !0 === r[t.id] || (t.addEventListener("dispose", a), r[t.id] = !0, n.memory.geometries++), t
                },
                update: function(e) {
                    const n = e.attributes;
                    for (const e in n) t.update(n[e], 34962);
                    const i = e.morphAttributes;
                    for (const e in i) {
                        const n = i[e];
                        for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962)
                    }
                },
                getWireframeAttribute: function(e) {
                    const t = s.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && o(e)
                    } else o(e);
                    return s.get(e)
                }
            }
        }

        function pi(e, t, n, i) {
            const r = i.isWebGL2;
            let s, a, o;
            this.setMode = function(e) {
                s = e
            }, this.setIndex = function(e) {
                a = e.type, o = e.bytesPerElement
            }, this.render = function(t, i) {
                e.drawElements(s, i, a, t * o), n.update(i, s, 1)
            }, this.renderInstances = function(i, l, c) {
                if (0 === c) return;
                let h, u;
                if (r) h = e, u = "drawElementsInstanced";
                else if (h = t.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[u](s, l, a, i * o, c), n.update(l, s, c)
            }
        }

        function fi(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                },
                update: function(e, n, i) {
                    switch (t.calls++, n) {
                        case 4:
                            t.triangles += i * (e / 3);
                            break;
                        case 1:
                            t.lines += i * (e / 2);
                            break;
                        case 3:
                            t.lines += i * (e - 1);
                            break;
                        case 2:
                            t.lines += i * e;
                            break;
                        case 0:
                            t.points += i * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        function mi(e, t) {
            return e[0] - t[0]
        }

        function gi(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1])
        }

        function vi(e, t) {
            let n = 1;
            const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
            i instanceof Int8Array ? n = 127 : i instanceof Uint8Array ? n = 255 : i instanceof Uint16Array ? n = 65535 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), e.divideScalar(n)
        }

        function xi(e, t, n) {
            const i = {},
                r = new Float32Array(8),
                s = new WeakMap,
                a = new xe,
                o = [];
            for (let e = 0; e < 8; e++) o[e] = [e, 0];
            return {
                update: function(l, c, h, u) {
                    const d = l.morphTargetInfluences;
                    if (!0 === t.isWebGL2) {
                        const i = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                            r = void 0 !== i ? i.length : 0;
                        let o = s.get(c);
                        if (void 0 === o || o.count !== r) {
                            void 0 !== o && o.texture.dispose();
                            const e = void 0 !== c.morphAttributes.position,
                                n = void 0 !== c.morphAttributes.normal,
                                i = void 0 !== c.morphAttributes.color,
                                l = c.morphAttributes.position || [],
                                h = c.morphAttributes.normal || [],
                                u = c.morphAttributes.color || [];
                            let d = 0;
                            !0 === e && (d = 1), !0 === n && (d = 2), !0 === i && (d = 3);
                            let p = c.attributes.position.count * d,
                                f = 1;
                            p > t.maxTextureSize && (f = Math.ceil(p / t.maxTextureSize), p = t.maxTextureSize);
                            const m = new Float32Array(p * f * 4 * r),
                                g = new be(m, p, f, r);
                            g.type = v, g.needsUpdate = !0;
                            const x = 4 * d;
                            for (let t = 0; t < r; t++) {
                                const r = l[t],
                                    s = h[t],
                                    o = u[t],
                                    c = p * f * 4 * t;
                                for (let t = 0; t < r.count; t++) {
                                    const l = t * x;
                                    !0 === e && (a.fromBufferAttribute(r, t), !0 === r.normalized && vi(a, r), m[c + l + 0] = a.x, m[c + l + 1] = a.y, m[c + l + 2] = a.z, m[c + l + 3] = 0), !0 === n && (a.fromBufferAttribute(s, t), !0 === s.normalized && vi(a, s), m[c + l + 4] = a.x, m[c + l + 5] = a.y, m[c + l + 6] = a.z, m[c + l + 7] = 0), !0 === i && (a.fromBufferAttribute(o, t), !0 === o.normalized && vi(a, o), m[c + l + 8] = a.x, m[c + l + 9] = a.y, m[c + l + 10] = a.z, m[c + l + 11] = 4 === o.itemSize ? a.w : 1)
                                }
                            }

                            function w() {
                                g.dispose(), s.delete(c), c.removeEventListener("dispose", w)
                            }
                            o = {
                                count: r,
                                texture: g,
                                size: new Z(p, f)
                            }, s.set(c, o), c.addEventListener("dispose", w)
                        }
                        let l = 0;
                        for (let e = 0; e < d.length; e++) l += d[e];
                        const h = c.morphTargetsRelative ? 1 : 1 - l;
                        u.getUniforms().setValue(e, "morphTargetBaseInfluence", h), u.getUniforms().setValue(e, "morphTargetInfluences", d), u.getUniforms().setValue(e, "morphTargetsTexture", o.texture, n), u.getUniforms().setValue(e, "morphTargetsTextureSize", o.size)
                    } else {
                        const t = void 0 === d ? 0 : d.length;
                        let n = i[c.id];
                        if (void 0 === n || n.length !== t) {
                            n = [];
                            for (let e = 0; e < t; e++) n[e] = [e, 0];
                            i[c.id] = n
                        }
                        for (let e = 0; e < t; e++) {
                            const t = n[e];
                            t[0] = e, t[1] = d[e]
                        }
                        n.sort(gi);
                        for (let e = 0; e < 8; e++) e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0);
                        o.sort(mi);
                        const s = c.morphAttributes.position,
                            a = c.morphAttributes.normal;
                        let l = 0;
                        for (let e = 0; e < 8; e++) {
                            const t = o[e],
                                n = t[0],
                                i = t[1];
                            n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), a && c.getAttribute("morphNormal" + e) !== a[n] && c.setAttribute("morphNormal" + e, a[n]), r[e] = i, l += i) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), a && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), r[e] = 0)
                        }
                        const h = c.morphTargetsRelative ? 1 : 1 - l;
                        u.getUniforms().setValue(e, "morphTargetBaseInfluence", h), u.getUniforms().setValue(e, "morphTargetInfluences", r)
                    }
                }
            }
        }

        function wi(e, t, n, i) {
            let r = new WeakMap;

            function s(e) {
                const t = e.target;
                t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(e) {
                    const a = i.render.frame,
                        o = e.geometry,
                        l = t.get(e, o);
                    return r.get(l) !== a && (t.update(l), r.set(l, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        const bi = new ve,
            _i = new be,
            yi = new _e,
            Ai = new Pn,
            Mi = [],
            Si = [],
            Ei = new Float32Array(16),
            Ti = new Float32Array(9),
            Ci = new Float32Array(4);

        function Di(e, t, n) {
            const i = e[0];
            if (i <= 0 || i > 0) return e;
            const r = t * n;
            let s = Mi[r];
            if (void 0 === s && (s = new Float32Array(r), Mi[r] = s), 0 !== t) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(s, r)
            }
            return s
        }

        function Pi(e, t) {
            if (e.length !== t.length) return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function Ri(e, t) {
            for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
        }

        function Li(e, t) {
            let n = Si[t];
            void 0 === n && (n = new Int32Array(t), Si[t] = n);
            for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
            return n
        }

        function Ii(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
        }

        function Bi(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (Pi(n, t)) return;
                e.uniform2fv(this.addr, t), Ri(n, t)
            }
        }

        function Oi(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
            else {
                if (Pi(n, t)) return;
                e.uniform3fv(this.addr, t), Ri(n, t)
            }
        }

        function ki(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (Pi(n, t)) return;
                e.uniform4fv(this.addr, t), Ri(n, t)
            }
        }

        function Ni(e, t) {
            const n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (Pi(n, t)) return;
                e.uniformMatrix2fv(this.addr, !1, t), Ri(n, t)
            } else {
                if (Pi(n, i)) return;
                Ci.set(i), e.uniformMatrix2fv(this.addr, !1, Ci), Ri(n, i)
            }
        }

        function Fi(e, t) {
            const n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (Pi(n, t)) return;
                e.uniformMatrix3fv(this.addr, !1, t), Ri(n, t)
            } else {
                if (Pi(n, i)) return;
                Ti.set(i), e.uniformMatrix3fv(this.addr, !1, Ti), Ri(n, i)
            }
        }

        function Ui(e, t) {
            const n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (Pi(n, t)) return;
                e.uniformMatrix4fv(this.addr, !1, t), Ri(n, t)
            } else {
                if (Pi(n, i)) return;
                Ei.set(i), e.uniformMatrix4fv(this.addr, !1, Ei), Ri(n, i)
            }
        }

        function zi(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
        }

        function Vi(e, t) {
            const n = this.cache;
            Pi(n, t) || (e.uniform2iv(this.addr, t), Ri(n, t))
        }

        function Hi(e, t) {
            const n = this.cache;
            Pi(n, t) || (e.uniform3iv(this.addr, t), Ri(n, t))
        }

        function Gi(e, t) {
            const n = this.cache;
            Pi(n, t) || (e.uniform4iv(this.addr, t), Ri(n, t))
        }

        function Wi(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
        }

        function ji(e, t) {
            const n = this.cache;
            Pi(n, t) || (e.uniform2uiv(this.addr, t), Ri(n, t))
        }

        function Yi(e, t) {
            const n = this.cache;
            Pi(n, t) || (e.uniform3uiv(this.addr, t), Ri(n, t))
        }

        function Xi(e, t) {
            const n = this.cache;
            Pi(n, t) || (e.uniform4uiv(this.addr, t), Ri(n, t))
        }

        function Qi(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(t || bi, r)
        }

        function qi(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || yi, r)
        }

        function Ki(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || Ai, r)
        }

        function Zi(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || _i, r)
        }

        function Ji(e, t) {
            e.uniform1fv(this.addr, t)
        }

        function $i(e, t) {
            const n = Di(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }

        function er(e, t) {
            const n = Di(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }

        function tr(e, t) {
            const n = Di(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }

        function nr(e, t) {
            const n = Di(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }

        function ir(e, t) {
            const n = Di(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }

        function rr(e, t) {
            const n = Di(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }

        function sr(e, t) {
            e.uniform1iv(this.addr, t)
        }

        function ar(e, t) {
            e.uniform2iv(this.addr, t)
        }

        function or(e, t) {
            e.uniform3iv(this.addr, t)
        }

        function lr(e, t) {
            e.uniform4iv(this.addr, t)
        }

        function cr(e, t) {
            e.uniform1uiv(this.addr, t)
        }

        function hr(e, t) {
            e.uniform2uiv(this.addr, t)
        }

        function ur(e, t) {
            e.uniform3uiv(this.addr, t)
        }

        function dr(e, t) {
            e.uniform4uiv(this.addr, t)
        }

        function pr(e, t, n) {
            const i = t.length,
                r = Li(n, i);
            e.uniform1iv(this.addr, r);
            for (let e = 0; e !== i; ++e) n.setTexture2D(t[e] || bi, r[e])
        }

        function fr(e, t, n) {
            const i = t.length,
                r = Li(n, i);
            e.uniform1iv(this.addr, r);
            for (let e = 0; e !== i; ++e) n.setTexture3D(t[e] || yi, r[e])
        }

        function mr(e, t, n) {
            const i = t.length,
                r = Li(n, i);
            e.uniform1iv(this.addr, r);
            for (let e = 0; e !== i; ++e) n.setTextureCube(t[e] || Ai, r[e])
        }

        function gr(e, t, n) {
            const i = t.length,
                r = Li(n, i);
            e.uniform1iv(this.addr, r);
            for (let e = 0; e !== i; ++e) n.setTexture2DArray(t[e] || _i, r[e])
        }
        class vr {
            constructor(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return Ii;
                        case 35664:
                            return Bi;
                        case 35665:
                            return Oi;
                        case 35666:
                            return ki;
                        case 35674:
                            return Ni;
                        case 35675:
                            return Fi;
                        case 35676:
                            return Ui;
                        case 5124:
                        case 35670:
                            return zi;
                        case 35667:
                        case 35671:
                            return Vi;
                        case 35668:
                        case 35672:
                            return Hi;
                        case 35669:
                        case 35673:
                            return Gi;
                        case 5125:
                            return Wi;
                        case 36294:
                            return ji;
                        case 36295:
                            return Yi;
                        case 36296:
                            return Xi;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Qi;
                        case 35679:
                        case 36299:
                        case 36307:
                            return qi;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Ki;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Zi
                    }
                }(t.type)
            }
        }
        class xr {
            constructor(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return Ji;
                        case 35664:
                            return $i;
                        case 35665:
                            return er;
                        case 35666:
                            return tr;
                        case 35674:
                            return nr;
                        case 35675:
                            return ir;
                        case 35676:
                            return rr;
                        case 5124:
                        case 35670:
                            return sr;
                        case 35667:
                        case 35671:
                            return ar;
                        case 35668:
                        case 35672:
                            return or;
                        case 35669:
                        case 35673:
                            return lr;
                        case 5125:
                            return cr;
                        case 36294:
                            return hr;
                        case 36295:
                            return ur;
                        case 36296:
                            return dr;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return pr;
                        case 35679:
                        case 36299:
                        case 36307:
                            return fr;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return mr;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return gr
                    }
                }(t.type)
            }
        }
        class wr {
            constructor(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            setValue(e, t, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(e, t[s.id], n)
                }
            }
        }
        const br = /(\w+)(\])?(\[|\.)?/g;

        function _r(e, t) {
            e.seq.push(t), e.map[t.id] = t
        }

        function yr(e, t, n) {
            const i = e.name,
                r = i.length;
            for (br.lastIndex = 0;;) {
                const s = br.exec(i),
                    a = br.lastIndex;
                let o = s[1];
                const l = "]" === s[2],
                    c = s[3];
                if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
                    _r(n, void 0 === c ? new vr(o, e, t) : new xr(o, e, t));
                    break
                } {
                    let e = n.map[o];
                    void 0 === e && (e = new wr(o), _r(n, e)), n = e
                }
            }
        }
        class Ar {
            constructor(e, t) {
                this.seq = [], this.map = {};
                const n = e.getProgramParameter(t, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    yr(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }
            setOptional(e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }
            static upload(e, t, n, i) {
                for (let r = 0, s = t.length; r !== s; ++r) {
                    const s = t[r],
                        a = n[s.id];
                    !1 !== a.needsUpdate && s.setValue(e, a.value, i)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            }
        }

        function Mr(e, t, n) {
            const i = e.createShader(t);
            return e.shaderSource(i, n), e.compileShader(i), i
        }
        let Sr = 0;

        function Er(e, t, n) {
            const i = e.getShaderParameter(t, 35713),
                r = e.getShaderInfoLog(t).trim();
            if (i && "" === r) return "";
            const s = /ERROR: 0:(\d+)/.exec(r);
            if (s) {
                const i = parseInt(s[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                    const n = e.split("\n"),
                        i = [],
                        r = Math.max(t - 6, 0),
                        s = Math.min(t + 6, n.length);
                    for (let e = r; e < s; e++) {
                        const r = e + 1;
                        i.push(`${r===t?">":" "} ${r}: ${n[e]}`)
                    }
                    return i.join("\n")
                }(e.getShaderSource(t), i)
            }
            return r
        }

        function Tr(e, t) {
            const n = function(e) {
                switch (e) {
                    case P:
                        return ["Linear", "( value )"];
                    case R:
                        return ["sRGB", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                }
            }(t);
            return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function Cr(e, t) {
            let n;
            switch (t) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "OptimizedCineon";
                    break;
                case 4:
                    n = "ACESFilmic";
                    break;
                case 5:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Dr(e) {
            return "" !== e
        }

        function Pr(e, t) {
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }

        function Rr(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const Lr = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Ir(e) {
            return e.replace(Lr, Br)
        }

        function Br(e, t) {
            const n = Hn[t];
            if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
            return Ir(n)
        }
        const Or = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            kr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Nr(e) {
            return e.replace(kr, Ur).replace(Or, Fr)
        }

        function Fr(e, t, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ur(0, t, n, i)
        }

        function Ur(e, t, n, i) {
            let r = "";
            for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
            return r
        }

        function zr(e) {
            let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
        }

        function Vr(e, t, n, i) {
            const o = e.getContext(),
                l = n.defines;
            let c = n.vertexShader,
                h = n.fragmentShader;
            const u = function(e) {
                    let t = "SHADOWMAP_TYPE_BASIC";
                    return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
                }(n),
                d = function(e) {
                    let t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap) switch (e.envMapMode) {
                        case r:
                        case s:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case a:
                            t = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return t
                }(n),
                p = function(e) {
                    let t = "ENVMAP_MODE_REFLECTION";
                    return e.envMap && e.envMapMode === s && (t = "ENVMAP_MODE_REFRACTION"), t
                }(n),
                f = function(e) {
                    let t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap) switch (e.combine) {
                        case 0:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            t = "ENVMAP_BLENDING_ADD"
                    }
                    return t
                }(n),
                m = function(e) {
                    const t = e.envMapCubeUVHeight;
                    if (null === t) return null;
                    const n = Math.log2(t) - 2,
                        i = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }(n),
                g = n.isWebGL2 ? "" : function(e) {
                    return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Dr).join("\n")
                }(n),
                v = function(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        !1 !== i && t.push("#define " + n + " " + i)
                    }
                    return t.join("\n")
                }(l),
                x = o.createProgram();
            let w, b, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (w = [v].filter(Dr).join("\n"), w.length > 0 && (w += "\n"), b = [g, v].filter(Dr).join("\n"), b.length > 0 && (b += "\n")) : (w = [zr(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Dr).join("\n"), b = [g, zr(n), "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Hn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Cr("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Hn.encodings_pars_fragment, Tr("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Dr).join("\n")), c = Ir(c), c = Pr(c, n), c = Rr(c, n), h = Ir(h), h = Pr(h, n), h = Rr(h, n), c = Nr(c), h = Nr(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", w = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + w, b = ["#define varying in", n.glslVersion === k ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === k ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
            const y = _ + b + h,
                A = Mr(o, 35633, _ + w + c),
                M = Mr(o, 35632, y);
            if (o.attachShader(x, A), o.attachShader(x, M), void 0 !== n.index0AttributeName ? o.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(x, 0, "position"), o.linkProgram(x), e.debug.checkShaderErrors) {
                const e = o.getProgramInfoLog(x).trim(),
                    t = o.getShaderInfoLog(A).trim(),
                    n = o.getShaderInfoLog(M).trim();
                let i = !0,
                    r = !0;
                if (!1 === o.getProgramParameter(x, 35714)) {
                    i = !1;
                    const t = Er(o, A, "vertex"),
                        n = Er(o, M, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(x, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
                } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (r = !1);
                r && (this.diagnostics = {
                    runnable: i,
                    programLog: e,
                    vertexShader: {
                        log: t,
                        prefix: w
                    },
                    fragmentShader: {
                        log: n,
                        prefix: b
                    }
                })
            }
            let S, E;
            return o.deleteShader(A), o.deleteShader(M), this.getUniforms = function() {
                return void 0 === S && (S = new Ar(o, x)), S
            }, this.getAttributes = function() {
                return void 0 === E && (E = function(e, t) {
                    const n = {},
                        i = e.getProgramParameter(t, 35721);
                    for (let r = 0; r < i; r++) {
                        const i = e.getActiveAttrib(t, r),
                            s = i.name;
                        let a = 1;
                        35674 === i.type && (a = 2), 35675 === i.type && (a = 3), 35676 === i.type && (a = 4), n[s] = {
                            type: i.type,
                            location: e.getAttribLocation(t, s),
                            locationSize: a
                        }
                    }
                    return n
                }(o, x)), E
            }, this.destroy = function() {
                i.releaseStatesOfProgram(this), o.deleteProgram(x), this.program = void 0
            }, this.name = n.shaderName, this.id = Sr++, this.cacheKey = t, this.usedTimes = 1, this.program = x, this.vertexShader = A, this.fragmentShader = M, this
        }
        let Hr = 0;
        class Gr {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader,
                    n = e.fragmentShader,
                    i = this._getShaderStage(t),
                    r = this._getShaderStage(n),
                    s = this._getShaderCacheForMaterial(e);
                return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
                return this.materialCache.delete(e), this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                return !1 === t.has(e) && t.set(e, new Set), t.get(e)
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                if (!1 === t.has(e)) {
                    const n = new Wr(e);
                    t.set(e, n)
                }
                return t.get(e)
            }
        }
        class Wr {
            constructor(e) {
                this.id = Hr++, this.code = e, this.usedTimes = 0
            }
        }

        function jr(e, t, n, i, r, s, o) {
            const l = new dt,
                c = new Gr,
                h = [],
                u = r.isWebGL2,
                d = r.logarithmicDepthBuffer,
                p = r.vertexTextures;
            let f = r.precision;
            const m = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            return {
                getParameters: function(s, l, h, g, v) {
                    const x = g.fog,
                        w = v.geometry,
                        b = s.isMeshStandardMaterial ? g.environment : null,
                        _ = (s.isMeshStandardMaterial ? n : t).get(s.envMap || b),
                        y = _ && _.mapping === a ? _.image.height : null,
                        A = m[s.type];
                    null !== s.precision && (f = r.getMaxPrecision(s.precision), f !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead."));
                    const M = w.morphAttributes.position || w.morphAttributes.normal || w.morphAttributes.color,
                        S = void 0 !== M ? M.length : 0;
                    let E, T, C, D, L = 0;
                    if (void 0 !== w.morphAttributes.position && (L = 1), void 0 !== w.morphAttributes.normal && (L = 2), void 0 !== w.morphAttributes.color && (L = 3), A) {
                        const e = Wn[A];
                        E = e.vertexShader, T = e.fragmentShader
                    } else E = s.vertexShader, T = s.fragmentShader, c.update(s), C = c.getVertexShaderID(s), D = c.getFragmentShaderID(s);
                    const I = e.getRenderTarget(),
                        B = s.alphaTest > 0,
                        O = s.clearcoat > 0,
                        k = s.iridescence > 0;
                    return {
                        isWebGL2: u,
                        shaderID: A,
                        shaderName: s.type,
                        vertexShader: E,
                        fragmentShader: T,
                        defines: s.defines,
                        customVertexShaderID: C,
                        customFragmentShaderID: D,
                        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                        glslVersion: s.glslVersion,
                        precision: f,
                        instancing: !0 === v.isInstancedMesh,
                        instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                        supportsVertexTextures: p,
                        outputEncoding: null === I ? e.outputEncoding : !0 === I.isXRRenderTarget ? I.texture.encoding : P,
                        map: !!s.map,
                        matcap: !!s.matcap,
                        envMap: !!_,
                        envMapMode: _ && _.mapping,
                        envMapCubeUVHeight: y,
                        lightMap: !!s.lightMap,
                        aoMap: !!s.aoMap,
                        emissiveMap: !!s.emissiveMap,
                        bumpMap: !!s.bumpMap,
                        normalMap: !!s.normalMap,
                        objectSpaceNormalMap: 1 === s.normalMapType,
                        tangentSpaceNormalMap: 0 === s.normalMapType,
                        decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === R,
                        clearcoat: O,
                        clearcoatMap: O && !!s.clearcoatMap,
                        clearcoatRoughnessMap: O && !!s.clearcoatRoughnessMap,
                        clearcoatNormalMap: O && !!s.clearcoatNormalMap,
                        iridescence: k,
                        iridescenceMap: k && !!s.iridescenceMap,
                        iridescenceThicknessMap: k && !!s.iridescenceThicknessMap,
                        displacementMap: !!s.displacementMap,
                        roughnessMap: !!s.roughnessMap,
                        metalnessMap: !!s.metalnessMap,
                        specularMap: !!s.specularMap,
                        specularIntensityMap: !!s.specularIntensityMap,
                        specularColorMap: !!s.specularColorMap,
                        opaque: !1 === s.transparent && 1 === s.blending,
                        alphaMap: !!s.alphaMap,
                        alphaTest: B,
                        gradientMap: !!s.gradientMap,
                        sheen: s.sheen > 0,
                        sheenColorMap: !!s.sheenColorMap,
                        sheenRoughnessMap: !!s.sheenRoughnessMap,
                        transmission: s.transmission > 0,
                        transmissionMap: !!s.transmissionMap,
                        thicknessMap: !!s.thicknessMap,
                        combine: s.combine,
                        vertexTangents: !!s.normalMap && !!w.attributes.tangent,
                        vertexColors: s.vertexColors,
                        vertexAlphas: !0 === s.vertexColors && !!w.attributes.color && 4 === w.attributes.color.itemSize,
                        vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                        uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                        fog: !!x,
                        useFog: !0 === s.fog,
                        fogExp2: x && x.isFogExp2,
                        flatShading: !!s.flatShading,
                        sizeAttenuation: s.sizeAttenuation,
                        logarithmicDepthBuffer: d,
                        skinning: !0 === v.isSkinnedMesh,
                        morphTargets: void 0 !== w.morphAttributes.position,
                        morphNormals: void 0 !== w.morphAttributes.normal,
                        morphColors: void 0 !== w.morphAttributes.color,
                        morphTargetsCount: S,
                        morphTextureStride: L,
                        numDirLights: l.directional.length,
                        numPointLights: l.point.length,
                        numSpotLights: l.spot.length,
                        numRectAreaLights: l.rectArea.length,
                        numHemiLights: l.hemi.length,
                        numDirLightShadows: l.directionalShadowMap.length,
                        numPointLightShadows: l.pointShadowMap.length,
                        numSpotLightShadows: l.spotShadowMap.length,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        dithering: s.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: s.toneMapped ? e.toneMapping : 0,
                        physicallyCorrectLights: e.physicallyCorrectLights,
                        premultipliedAlpha: s.premultipliedAlpha,
                        doubleSided: 2 === s.side,
                        flipSided: 1 === s.side,
                        useDepthPacking: !!s.depthPacking,
                        depthPacking: s.depthPacking || 0,
                        index0AttributeName: s.index0AttributeName,
                        extensionDerivatives: s.extensions && s.extensions.derivatives,
                        extensionFragDepth: s.extensions && s.extensions.fragDepth,
                        extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                        extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: s.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                        for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (function(e, t) {
                        e.push(t.precision), e.push(t.outputEncoding), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                    }(n, t), function(e, t) {
                        l.disableAll(), t.isWebGL2 && l.enable(0), t.supportsVertexTextures && l.enable(1), t.instancing && l.enable(2), t.instancingColor && l.enable(3), t.map && l.enable(4), t.matcap && l.enable(5), t.envMap && l.enable(6), t.lightMap && l.enable(7), t.aoMap && l.enable(8), t.emissiveMap && l.enable(9), t.bumpMap && l.enable(10), t.normalMap && l.enable(11), t.objectSpaceNormalMap && l.enable(12), t.tangentSpaceNormalMap && l.enable(13), t.clearcoat && l.enable(14), t.clearcoatMap && l.enable(15), t.clearcoatRoughnessMap && l.enable(16), t.clearcoatNormalMap && l.enable(17), t.iridescence && l.enable(18), t.iridescenceMap && l.enable(19), t.iridescenceThicknessMap && l.enable(20), t.displacementMap && l.enable(21), t.specularMap && l.enable(22), t.roughnessMap && l.enable(23), t.metalnessMap && l.enable(24), t.gradientMap && l.enable(25), t.alphaMap && l.enable(26), t.alphaTest && l.enable(27), t.vertexColors && l.enable(28), t.vertexAlphas && l.enable(29), t.vertexUvs && l.enable(30), t.vertexTangents && l.enable(31), t.uvsVertexOnly && l.enable(32), t.fog && l.enable(33), e.push(l.mask), l.disableAll(), t.useFog && l.enable(0), t.flatShading && l.enable(1), t.logarithmicDepthBuffer && l.enable(2), t.skinning && l.enable(3), t.morphTargets && l.enable(4), t.morphNormals && l.enable(5), t.morphColors && l.enable(6), t.premultipliedAlpha && l.enable(7), t.shadowMapEnabled && l.enable(8), t.physicallyCorrectLights && l.enable(9), t.doubleSided && l.enable(10), t.flipSided && l.enable(11), t.useDepthPacking && l.enable(12), t.dithering && l.enable(13), t.specularIntensityMap && l.enable(14), t.specularColorMap && l.enable(15), t.transmission && l.enable(16), t.transmissionMap && l.enable(17), t.thicknessMap && l.enable(18), t.sheen && l.enable(19), t.sheenColorMap && l.enable(20), t.sheenRoughnessMap && l.enable(21), t.decodeVideoTexture && l.enable(22), t.opaque && l.enable(23), e.push(l.mask)
                    }(n, t), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join()
                },
                getUniforms: function(e) {
                    const t = m[e.type];
                    let n;
                    if (t) {
                        const e = Wn[t];
                        n = Mn.clone(e.uniforms)
                    } else n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let i;
                    for (let e = 0, t = h.length; e < t; e++) {
                        const t = h[e];
                        if (t.cacheKey === n) {
                            i = t, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Vr(e, n, t, s), h.push(i)), i
                },
                releaseProgram: function(e) {
                    if (0 == --e.usedTimes) {
                        const t = h.indexOf(e);
                        h[t] = h[h.length - 1], h.pop(), e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    c.remove(e)
                },
                programs: h,
                dispose: function() {
                    c.dispose()
                }
            }
        }

        function Yr() {
            let e = new WeakMap;
            return {
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {}, e.set(t, n)), n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, i) {
                    e.get(t)[n] = i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Xr(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }

        function Qr(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function qr() {
            const e = [];
            let t = 0;
            const n = [],
                i = [],
                r = [];

            function s(n, i, r, s, a, o) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: o
                }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), t++, l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    t = 0, n.length = 0, i.length = 0, r.length = 0
                },
                push: function(e, t, a, o, l, c) {
                    const h = s(e, t, a, o, l, c);
                    a.transmission > 0 ? i.push(h) : !0 === a.transparent ? r.push(h) : n.push(h)
                },
                unshift: function(e, t, a, o, l, c) {
                    const h = s(e, t, a, o, l, c);
                    a.transmission > 0 ? i.unshift(h) : !0 === a.transparent ? r.unshift(h) : n.unshift(h)
                },
                finish: function() {
                    for (let n = t, i = e.length; n < i; n++) {
                        const t = e[n];
                        if (null === t.id) break;
                        t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || Xr), i.length > 1 && i.sort(t || Qr), r.length > 1 && r.sort(t || Qr)
                }
            }
        }

        function Kr() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    let i;
                    return !1 === e.has(t) ? (i = new qr, e.set(t, [i])) : n >= e.get(t).length ? (i = new qr, e.get(t).push(i)) : i = e.get(t)[n], i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Zr() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    let n;
                    switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Me,
                                color: new ue
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Me,
                                direction: new Me,
                                color: new ue,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Me,
                                color: new ue,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Me,
                                skyColor: new ue,
                                groundColor: new ue
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new ue,
                                position: new Me,
                                halfWidth: new Me,
                                halfHeight: new Me
                            }
                    }
                    return e[t.id] = n, n
                }
            }
        }
        let Jr = 0;

        function $r(e, t) {
            return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
        }

        function es(e, t) {
            const n = new Zr,
                i = function() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (void 0 !== e[t.id]) return e[t.id];
                            let n;
                            switch (t.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Z
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Z,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return e[t.id] = n, n
                        }
                    }
                }(),
                r = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
            for (let e = 0; e < 9; e++) r.probe.push(new Me);
            const s = new Me,
                a = new tt,
                o = new tt;
            return {
                setup: function(s, a) {
                    let o = 0,
                        l = 0,
                        c = 0;
                    for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                    let h = 0,
                        u = 0,
                        d = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0;
                    s.sort($r);
                    const x = !0 !== a ? Math.PI : 1;
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = s[e],
                            a = t.color,
                            w = t.intensity,
                            b = t.distance,
                            _ = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                        if (t.isAmbientLight) o += a.r * w * x, l += a.g * w * x, c += a.b * w * x;
                        else if (t.isLightProbe)
                            for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], w);
                        else if (t.isDirectionalLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * x), t.castShadow) {
                                const e = t.shadow,
                                    n = i.get(t);
                                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[h] = n, r.directionalShadowMap[h] = _, r.directionalShadowMatrix[h] = t.shadow.matrix, m++
                            }
                            r.directional[h] = e, h++
                        } else if (t.isSpotLight) {
                            const e = n.get(t);
                            if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(w * x), e.distance = b, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                                const e = t.shadow,
                                    n = i.get(t);
                                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = _, r.spotShadowMatrix[d] = t.shadow.matrix, v++
                            }
                            r.spot[d] = e, d++
                        } else if (t.isRectAreaLight) {
                            const e = n.get(t);
                            e.color.copy(a).multiplyScalar(w), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++
                        } else if (t.isPointLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * x), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                const e = t.shadow,
                                    n = i.get(t);
                                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = _, r.pointShadowMatrix[u] = t.shadow.matrix, g++
                            }
                            r.point[u] = e, u++
                        } else if (t.isHemisphereLight) {
                            const e = n.get(t);
                            e.skyColor.copy(t.color).multiplyScalar(w * x), e.groundColor.copy(t.groundColor).multiplyScalar(w * x), r.hemi[f] = e, f++
                        }
                    }
                    p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Gn.LTC_FLOAT_1, r.rectAreaLTC2 = Gn.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Gn.LTC_HALF_1, r.rectAreaLTC2 = Gn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                    const w = r.hash;
                    w.directionalLength === h && w.pointLength === u && w.spotLength === d && w.rectAreaLength === p && w.hemiLength === f && w.numDirectionalShadows === m && w.numPointShadows === g && w.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, w.directionalLength = h, w.pointLength = u, w.spotLength = d, w.rectAreaLength = p, w.hemiLength = f, w.numDirectionalShadows = m, w.numPointShadows = g, w.numSpotShadows = v, r.version = Jr++)
                },
                setupView: function(e, t) {
                    let n = 0,
                        i = 0,
                        l = 0,
                        c = 0,
                        h = 0;
                    const u = t.matrixWorldInverse;
                    for (let t = 0, d = e.length; t < d; t++) {
                        const d = e[t];
                        if (d.isDirectionalLight) {
                            const e = r.directional[n];
                            e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), n++
                        } else if (d.isSpotLight) {
                            const e = r.spot[l];
                            e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), l++
                        } else if (d.isRectAreaLight) {
                            const e = r.rectArea[c];
                            e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), o.identity(), a.copy(d.matrixWorld), a.premultiply(u), o.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
                        } else if (d.isPointLight) {
                            const e = r.point[i];
                            e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), i++
                        } else if (d.isHemisphereLight) {
                            const e = r.hemi[h];
                            e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), h++
                        }
                    }
                },
                state: r
            }
        }

        function ts(e, t) {
            const n = new es(e, t),
                i = [],
                r = [];
            return {
                init: function() {
                    i.length = 0, r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function(e) {
                    n.setup(i, e)
                },
                setupLightsView: function(e) {
                    n.setupView(i, e)
                },
                pushLight: function(e) {
                    i.push(e)
                },
                pushShadow: function(e) {
                    r.push(e)
                }
            }
        }

        function ns(e, t) {
            let n = new WeakMap;
            return {
                get: function(i, r = 0) {
                    let s;
                    return !1 === n.has(i) ? (s = new ts(e, t), n.set(i, [s])) : r >= n.get(i).length ? (s = new ts(e, t), n.get(i).push(s)) : s = n.get(i)[r], s
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class is extends Ut {
            constructor(e) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }
        }
        class rs extends Ut {
            constructor(e) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new Me, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }
        }

        function ss(e, t, n) {
            let i = new Fn;
            const r = new Z,
                s = new Z,
                a = new xe,
                o = new is({
                    depthPacking: 3201
                }),
                l = new rs,
                c = {},
                u = n.maxTextureSize,
                d = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                p = new Sn({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Z
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                f = p.clone();
            f.defines.HORIZONTAL_PASS = 1;
            const m = new en;
            m.setAttribute("position", new Gt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const g = new wn(m, p),
                v = this;

            function x(n, i) {
                const s = t.update(g);
                p.defines.VSM_SAMPLES !== n.blurSamples && (p.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), null === n.mapPass && (n.mapPass = new we(r.x, r.y)), p.uniforms.shadow_pass.value = n.map.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, s, p, g, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, s, f, g, null)
            }

            function w(t, n, i, r, s, a) {
                let h = null;
                const u = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (h = void 0 !== u ? u : !0 === i.isPointLight ? l : o, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
                    const e = h.uuid,
                        t = n.uuid;
                    let i = c[e];
                    void 0 === i && (i = {}, c[e] = i);
                    let r = i[t];
                    void 0 === r && (r = h.clone(), i[t] = r), h = r
                }
                return h.visible = n.visible, h.wireframe = n.wireframe, h.side = 3 === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], h.alphaMap = n.alphaMap, h.alphaTest = n.alphaTest, h.clipShadows = n.clipShadows, h.clippingPlanes = n.clippingPlanes, h.clipIntersection = n.clipIntersection, h.displacementMap = n.displacementMap, h.displacementScale = n.displacementScale, h.displacementBias = n.displacementBias, h.wireframeLinewidth = n.wireframeLinewidth, h.linewidth = n.linewidth, !0 === i.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(i.matrixWorld), h.nearDistance = r, h.farDistance = s), h
            }

            function b(n, r, s, a, o) {
                if (!1 === n.visible) return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = t.update(n),
                        r = n.material;
                    if (Array.isArray(r)) {
                        const t = i.groups;
                        for (let l = 0, c = t.length; l < c; l++) {
                            const c = t[l],
                                h = r[c.materialIndex];
                            if (h && h.visible) {
                                const t = w(n, h, a, s.near, s.far, o);
                                e.renderBufferDirect(s, null, i, t, n, c)
                            }
                        }
                    } else if (r.visible) {
                        const t = w(n, r, a, s.near, s.far, o);
                        e.renderBufferDirect(s, null, i, t, n, null)
                    }
                }
                const l = n.children;
                for (let e = 0, t = l.length; e < t; e++) b(l[e], r, s, a, o)
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, n, o) {
                if (!1 === v.enabled) return;
                if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
                if (0 === t.length) return;
                const l = e.getRenderTarget(),
                    c = e.getActiveCubeFace(),
                    d = e.getActiveMipmapLevel(),
                    p = e.state;
                p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                for (let l = 0, c = t.length; l < c; l++) {
                    const c = t[l],
                        d = c.shadow;
                    if (void 0 === d) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;
                    r.copy(d.mapSize);
                    const f = d.getFrameExtents();
                    if (r.multiply(f), s.copy(d.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / f.x), r.x = s.x * f.x, d.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / f.y), r.y = s.y * f.y, d.mapSize.y = s.y)), null === d.map) {
                        const e = 3 !== this.type ? {
                            minFilter: h,
                            magFilter: h
                        } : {};
                        d.map = new we(r.x, r.y, e), d.map.texture.name = c.name + ".shadowMap", d.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(d.map), e.clear();
                    const m = d.getViewportCount();
                    for (let e = 0; e < m; e++) {
                        const t = d.getViewport(e);
                        a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), p.viewport(a), d.updateMatrices(c, e), i = d.getFrustum(), b(n, o, d.camera, c, this.type)
                    }!0 !== d.isPointLightShadow && 3 === this.type && x(d, o), d.needsUpdate = !1
                }
                v.needsUpdate = !1, e.setRenderTarget(l, c, d)
            }
        }

        function as(e, t, n) {
            const r = n.isWebGL2,
                s = new function() {
                    let t = !1;
                    const n = new xe;
                    let i = null;
                    const r = new xe(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            i === n || t || (e.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t, i, s, a, o) {
                            !0 === o && (t *= a, i *= a, s *= a), n.set(t, i, s, a), !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n))
                        },
                        reset: function() {
                            t = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                a = new function() {
                    let t = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function(e) {
                            e ? U(2929) : z(2929)
                        },
                        setMask: function(i) {
                            n === i || t || (e.depthMask(i), n = i)
                        },
                        setFunc: function(t) {
                            if (i !== t) {
                                if (t) switch (t) {
                                    case 0:
                                        e.depthFunc(512);
                                        break;
                                    case 1:
                                        e.depthFunc(519);
                                        break;
                                    case 2:
                                        e.depthFunc(513);
                                        break;
                                    default:
                                        e.depthFunc(515);
                                        break;
                                    case 4:
                                        e.depthFunc(514);
                                        break;
                                    case 5:
                                        e.depthFunc(518);
                                        break;
                                    case 6:
                                        e.depthFunc(516);
                                        break;
                                    case 7:
                                        e.depthFunc(517)
                                } else e.depthFunc(515);
                                i = t
                            }
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            r !== t && (e.clearDepth(t), r = t)
                        },
                        reset: function() {
                            t = !1, n = null, i = null, r = null
                        }
                    }
                },
                o = new function() {
                    let t = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        a = null,
                        o = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function(e) {
                            t || (e ? U(2960) : z(2960))
                        },
                        setMask: function(i) {
                            n === i || t || (e.stencilMask(i), n = i)
                        },
                        setFunc: function(t, n, a) {
                            i === t && r === n && s === a || (e.stencilFunc(t, n, a), i = t, r = n, s = a)
                        },
                        setOp: function(t, n, i) {
                            a === t && o === n && l === i || (e.stencilOp(t, n, i), a = t, o = n, l = i)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            c !== t && (e.clearStencil(t), c = t)
                        },
                        reset: function() {
                            t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                        }
                    }
                };
            let l = {},
                c = {},
                h = new WeakMap,
                u = [],
                d = null,
                p = !1,
                f = null,
                m = null,
                g = null,
                v = null,
                x = null,
                w = null,
                b = null,
                _ = !1,
                y = null,
                A = null,
                M = null,
                S = null,
                E = null;
            const T = e.getParameter(35661);
            let C = !1,
                D = 0;
            const P = e.getParameter(7938); - 1 !== P.indexOf("WebGL") ? (D = parseFloat(/^WebGL (\d)/.exec(P)[1]), C = D >= 1) : -1 !== P.indexOf("OpenGL ES") && (D = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]), C = D >= 2);
            let R = null,
                L = {};
            const I = e.getParameter(3088),
                B = e.getParameter(2978),
                O = (new xe).fromArray(I),
                k = (new xe).fromArray(B);

            function N(t, n, i) {
                const r = new Uint8Array(4),
                    s = e.createTexture();
                e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                for (let t = 0; t < i; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }
            const F = {};

            function U(t) {
                !0 !== l[t] && (e.enable(t), l[t] = !0)
            }

            function z(t) {
                !1 !== l[t] && (e.disable(t), l[t] = !1)
            }
            F[3553] = N(3553, 3553, 1), F[34067] = N(34067, 34069, 6), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), U(2929), a.setFunc(3), W(!1), j(1), U(2884), G(0);
            const V = {
                [i]: 32774,
                101: 32778,
                102: 32779
            };
            if (r) V[103] = 32775, V[104] = 32776;
            else {
                const e = t.get("EXT_blend_minmax");
                null !== e && (V[103] = e.MIN_EXT, V[104] = e.MAX_EXT)
            }
            const H = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function G(t, n, r, s, a, o, l, c) {
                if (0 !== t) {
                    if (!1 === p && (U(3042), p = !0), 5 === t) a = a || n, o = o || r, l = l || s, n === m && a === x || (e.blendEquationSeparate(V[n], V[a]), m = n, x = a), r === g && s === v && o === w && l === b || (e.blendFuncSeparate(H[r], H[s], H[o], H[l]), g = r, v = s, w = o, b = l), f = t, _ = null;
                    else if (t !== f || c !== _) {
                        if (m === i && x === i || (e.blendEquation(32774), m = i, x = i), c) switch (t) {
                            case 1:
                                e.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                e.blendFunc(1, 1);
                                break;
                            case 3:
                                e.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case 4:
                                e.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        } else switch (t) {
                            case 1:
                                e.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                e.blendFunc(770, 1);
                                break;
                            case 3:
                                e.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case 4:
                                e.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                        g = null, v = null, w = null, b = null, f = t, _ = c
                    }
                } else !0 === p && (z(3042), p = !1)
            }

            function W(t) {
                y !== t && (t ? e.frontFace(2304) : e.frontFace(2305), y = t)
            }

            function j(t) {
                0 !== t ? (U(2884), t !== A && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : z(2884), A = t
            }

            function Y(t, n, i) {
                t ? (U(32823), S === n && E === i || (e.polygonOffset(n, i), S = n, E = i)) : z(32823)
            }

            function X(t) {
                void 0 === t && (t = 33984 + T - 1), R !== t && (e.activeTexture(t), R = t)
            }
            return {
                buffers: {
                    color: s,
                    depth: a,
                    stencil: o
                },
                enable: U,
                disable: z,
                bindFramebuffer: function(t, n) {
                    return c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, r && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)), !0)
                },
                drawBuffers: function(i, r) {
                    let s = u,
                        a = !1;
                    if (i)
                        if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
                            const e = i.texture;
                            if (s.length !== e.length || 36064 !== s[0]) {
                                for (let t = 0, n = e.length; t < n; t++) s[t] = 36064 + t;
                                s.length = e.length, a = !0
                            }
                        } else 36064 !== s[0] && (s[0] = 36064, a = !0);
                    else 1029 !== s[0] && (s[0] = 1029, a = !0);
                    a && (n.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                },
                useProgram: function(t) {
                    return d !== t && (e.useProgram(t), d = t, !0)
                },
                setBlending: G,
                setMaterial: function(e, t) {
                    2 === e.side ? z(2884) : U(2884);
                    let n = 1 === e.side;
                    t && (n = !n), W(n), 1 === e.blending && !1 === e.transparent ? G(0) : G(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), s.setMask(e.colorWrite);
                    const i = e.stencilWrite;
                    o.setTest(i), i && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Y(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? U(32926) : z(32926)
                },
                setFlipSided: W,
                setCullFace: j,
                setLineWidth: function(t) {
                    t !== M && (C && e.lineWidth(t), M = t)
                },
                setPolygonOffset: Y,
                setScissorTest: function(e) {
                    e ? U(3089) : z(3089)
                },
                activeTexture: X,
                bindTexture: function(t, n) {
                    null === R && X();
                    let i = L[R];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, L[R] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || F[t]), i.type = t, i.texture = n)
                },
                unbindTexture: function() {
                    const t = L[R];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                scissor: function(t) {
                    !1 === O.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), O.copy(t))
                },
                viewport: function(t) {
                    !1 === k.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), k.copy(t))
                },
                reset: function() {
                    e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), l = {}, R = null, L = {}, c = {}, h = new WeakMap, u = [], d = null, p = !1, f = null, m = null, g = null, v = null, x = null, w = null, b = null, _ = !1, y = null, A = null, M = null, S = null, E = null, O.set(0, 0, e.canvas.width, e.canvas.height), k.set(0, 0, e.canvas.width, e.canvas.height), s.reset(), a.reset(), o.reset()
                }
            }
        }

        function os(e, t, n, i, r, s, a) {
            const A = r.isWebGL2,
                M = r.maxTextures,
                S = r.maxCubemapSize,
                E = r.maxTextureSize,
                T = r.maxSamples,
                C = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                D = /OculusBrowser/g.test(navigator.userAgent),
                L = new WeakMap;
            let I;
            const B = new WeakMap;
            let O = !1;
            try {
                O = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (e) {}

            function k(e, t) {
                return O ? new OffscreenCanvas(e, t) : ee("canvas")
            }

            function F(e, t, n, i) {
                let r = 1;
                if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const i = t ? q : Math.floor,
                            s = i(r * e.width),
                            a = i(r * e.height);
                        void 0 === I && (I = k(s, a));
                        const o = n ? k(s, a) : I;
                        return o.width = s, o.height = a, o.getContext("2d").drawImage(e, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."), o
                    }
                    return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                }
                return e
            }

            function U(e) {
                return X(e.width) && X(e.height)
            }

            function z(e, t) {
                return e.generateMipmaps && t && e.minFilter !== h && e.minFilter !== p
            }

            function V(t) {
                e.generateMipmap(t)
            }

            function H(n, i, r, s, a = !1) {
                if (!1 === A) return i;
                if (null !== n) {
                    if (void 0 !== e[n]) return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let o = i;
                return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 33319 === i && (5126 === r && (o = 33328), 5131 === r && (o = 33327), 5121 === r && (o = 33323)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = s === R && !1 === a ? 35907 : 32856), 32819 === r && (o = 32854), 32820 === r && (o = 32855)), 33325 !== o && 33326 !== o && 33327 !== o && 33328 !== o && 34842 !== o && 34836 !== o || t.get("EXT_color_buffer_float"), o
            }

            function G(e, t, n) {
                return !0 === z(e, n) || e.isFramebufferTexture && e.minFilter !== h && e.minFilter !== p ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }

            function W(e) {
                return e === h || e === u || e === d ? 9728 : 9729
            }

            function j(e) {
                const t = e.target;
                t.removeEventListener("dispose", j),
                    function(e) {
                        const t = i.get(e);
                        if (void 0 === t.__webglInit) return;
                        const n = e.source,
                            r = B.get(n);
                        if (r) {
                            const i = r[t.__cacheKey];
                            i.usedTimes--, 0 === i.usedTimes && Q(e), 0 === Object.keys(r).length && B.delete(n)
                        }
                        i.remove(e)
                    }(t), t.isVideoTexture && L.delete(t)
            }

            function Y(t) {
                const n = t.target;
                n.removeEventListener("dispose", Y),
                    function(t) {
                        const n = t.texture,
                            r = i.get(t),
                            s = i.get(n);
                        if (void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                            for (let t = 0; t < 6; t++) e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
                        else {
                            if (e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer)
                                for (let t = 0; t < r.__webglColorRenderbuffer.length; t++) r.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(r.__webglColorRenderbuffer[t]);
                            r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                        }
                        if (t.isWebGLMultipleRenderTargets)
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = i.get(n[t]);
                                r.__webglTexture && (e.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[t])
                            }
                        i.remove(n), i.remove(t)
                    }(n)
            }

            function Q(t) {
                const n = i.get(t);
                e.deleteTexture(n.__webglTexture);
                const r = t.source;
                delete B.get(r)[n.__cacheKey], a.memory.textures--
            }
            let K = 0;

            function Z(e, t) {
                const r = i.get(e);
                if (e.isVideoTexture && function(e) {
                        const t = a.render.frame;
                        L.get(e) !== t && (L.set(e, t), e.update())
                    }(e), !1 === e.isRenderTargetTexture && e.version > 0 && r.__version !== e.version) {
                    const n = e.image;
                    if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== n.complete) return void ie(r, e, t);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
            }
            const J = {
                    [o]: 10497,
                    [l]: 33071,
                    [c]: 33648
                },
                $ = {
                    [h]: 9728,
                    [u]: 9984,
                    [d]: 9986,
                    [p]: 9729,
                    1007: 9985,
                    [f]: 9987
                };

            function te(n, s, a) {
                if (a ? (e.texParameteri(n, 10242, J[s.wrapS]), e.texParameteri(n, 10243, J[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, J[s.wrapR]), e.texParameteri(n, 10240, $[s.magFilter]), e.texParameteri(n, 10241, $[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), s.wrapS === l && s.wrapT === l || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, W(s.magFilter)), e.texParameteri(n, 10241, W(s.minFilter)), s.minFilter !== h && s.minFilter !== p && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                    const a = t.get("EXT_texture_filter_anisotropic");
                    if (s.type === v && !1 === t.has("OES_texture_float_linear")) return;
                    if (!1 === A && s.type === x && !1 === t.has("OES_texture_half_float_linear")) return;
                    (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                }
            }

            function ne(t, n) {
                let i = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", j));
                const r = n.source;
                let s = B.get(r);
                void 0 === s && (s = {}, B.set(r, s));
                const o = function(e) {
                    const t = [];
                    return t.push(e.wrapS), t.push(e.wrapT), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join()
                }(n);
                if (o !== t.__cacheKey) {
                    void 0 === s[o] && (s[o] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    }, a.memory.textures++, i = !0), s[o].usedTimes++;
                    const r = s[t.__cacheKey];
                    void 0 !== r && (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && Q(n)), t.__cacheKey = o, t.__webglTexture = s[o].texture
                }
                return i
            }

            function ie(t, i, r) {
                let a = 3553;
                i.isDataArrayTexture && (a = 35866), i.isData3DTexture && (a = 32879);
                const o = ne(t, i),
                    c = i.source;
                if (n.activeTexture(33984 + r), n.bindTexture(a, t.__webglTexture), c.version !== c.__currentVersion || !0 === o) {
                    e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                    const t = function(e) {
                        return !A && (e.wrapS !== l || e.wrapT !== l || e.minFilter !== h && e.minFilter !== p)
                    }(i) && !1 === U(i.image);
                    let r = F(i.image, t, !1, E);
                    r = ce(i, r);
                    const u = U(r) || A,
                        d = s.convert(i.format, i.encoding);
                    let f, m = s.convert(i.type),
                        x = H(i.internalFormat, d, m, i.encoding, i.isVideoTexture);
                    te(a, i, u);
                    const M = i.mipmaps,
                        S = A && !0 !== i.isVideoTexture,
                        T = void 0 === c.__currentVersion || !0 === o,
                        C = G(i, r, u);
                    if (i.isDepthTexture) x = 6402, A ? x = i.type === v ? 36012 : i.type === g ? 33190 : i.type === w ? 35056 : 33189 : i.type === v && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === _ && 6402 === x && 1012 !== i.type && i.type !== g && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = g, m = s.convert(i.type)), i.format === y && 6402 === x && (x = 34041, i.type !== w && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = w, m = s.convert(i.type))), T && (S ? n.texStorage2D(3553, 1, x, r.width, r.height) : n.texImage2D(3553, 0, x, r.width, r.height, 0, d, m, null));
                    else if (i.isDataTexture)
                        if (M.length > 0 && u) {
                            S && T && n.texStorage2D(3553, C, x, M[0].width, M[0].height);
                            for (let e = 0, t = M.length; e < t; e++) f = M[e], S ? n.texSubImage2D(3553, e, 0, 0, f.width, f.height, d, m, f.data) : n.texImage2D(3553, e, x, f.width, f.height, 0, d, m, f.data);
                            i.generateMipmaps = !1
                        } else S ? (T && n.texStorage2D(3553, C, x, r.width, r.height), n.texSubImage2D(3553, 0, 0, 0, r.width, r.height, d, m, r.data)) : n.texImage2D(3553, 0, x, r.width, r.height, 0, d, m, r.data);
                    else if (i.isCompressedTexture) {
                        S && T && n.texStorage2D(3553, C, x, M[0].width, M[0].height);
                        for (let e = 0, t = M.length; e < t; e++) f = M[e], i.format !== b ? null !== d ? S ? n.compressedTexSubImage2D(3553, e, 0, 0, f.width, f.height, d, f.data) : n.compressedTexImage2D(3553, e, x, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : S ? n.texSubImage2D(3553, e, 0, 0, f.width, f.height, d, m, f.data) : n.texImage2D(3553, e, x, f.width, f.height, 0, d, m, f.data)
                    } else if (i.isDataArrayTexture) S ? (T && n.texStorage3D(35866, C, x, r.width, r.height, r.depth), n.texSubImage3D(35866, 0, 0, 0, 0, r.width, r.height, r.depth, d, m, r.data)) : n.texImage3D(35866, 0, x, r.width, r.height, r.depth, 0, d, m, r.data);
                    else if (i.isData3DTexture) S ? (T && n.texStorage3D(32879, C, x, r.width, r.height, r.depth), n.texSubImage3D(32879, 0, 0, 0, 0, r.width, r.height, r.depth, d, m, r.data)) : n.texImage3D(32879, 0, x, r.width, r.height, r.depth, 0, d, m, r.data);
                    else if (i.isFramebufferTexture) {
                        if (T)
                            if (S) n.texStorage2D(3553, C, x, r.width, r.height);
                            else {
                                let e = r.width,
                                    t = r.height;
                                for (let i = 0; i < C; i++) n.texImage2D(3553, i, x, e, t, 0, d, m, null), e >>= 1, t >>= 1
                            }
                    } else if (M.length > 0 && u) {
                        S && T && n.texStorage2D(3553, C, x, M[0].width, M[0].height);
                        for (let e = 0, t = M.length; e < t; e++) f = M[e], S ? n.texSubImage2D(3553, e, 0, 0, d, m, f) : n.texImage2D(3553, e, x, d, m, f);
                        i.generateMipmaps = !1
                    } else S ? (T && n.texStorage2D(3553, C, x, r.width, r.height), n.texSubImage2D(3553, 0, 0, 0, d, m, r)) : n.texImage2D(3553, 0, x, d, m, r);
                    z(i, u) && V(a), c.__currentVersion = c.version, i.onUpdate && i.onUpdate(i)
                }
                t.__version = i.version
            }

            function re(t, r, a, o, l) {
                const c = s.convert(a.format, a.encoding),
                    h = s.convert(a.type),
                    u = H(a.internalFormat, c, h, a.encoding);
                i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)), n.bindFramebuffer(36160, t), le(r) ? C.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, oe(r)) : e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
            }

            function se(t, n, i) {
                if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i || le(n)) {
                        const t = n.depthTexture;
                        t && t.isDepthTexture && (t.type === v ? r = 36012 : t.type === g && (r = 33190));
                        const i = oe(n);
                        le(n) ? C.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else e.renderbufferStorage(36161, r, n.width, n.height);
                    e.framebufferRenderbuffer(36160, 36096, 36161, t)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = oe(n);
                    i && !1 === le(n) ? e.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : le(n) ? C.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                } else {
                    const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let r = 0; r < t.length; r++) {
                        const a = t[r],
                            o = s.convert(a.format, a.encoding),
                            l = s.convert(a.type),
                            c = H(a.internalFormat, o, l, a.encoding),
                            h = oe(n);
                        i && !1 === le(n) ? e.renderbufferStorageMultisample(36161, h, c, n.width, n.height) : le(n) ? C.renderbufferStorageMultisampleEXT(36161, h, c, n.width, n.height) : e.renderbufferStorage(36161, c, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(36161, null)
            }

            function ae(t) {
                const r = i.get(t),
                    s = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(t, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), Z(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture,
                            a = oe(r);
                        if (r.depthTexture.format === _) le(r) ? C.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                        else {
                            if (r.depthTexture.format !== y) throw new Error("Unknown depthTexture format");
                            le(r) ? C.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                        }
                    }(r.__webglFramebuffer, t)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), se(r.__webglDepthbuffer[i], t, !1)
                } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), se(r.__webglDepthbuffer, t, !1);
                n.bindFramebuffer(36160, null)
            }

            function oe(e) {
                return Math.min(T, e.samples)
            }

            function le(e) {
                const n = i.get(e);
                return A && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function ce(e, n) {
                const i = e.encoding,
                    r = e.format,
                    s = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === N || i !== P && (i === R ? !1 === A ? !0 === t.has("EXT_sRGB") && r === b ? (e.format = N, e.minFilter = p, e.generateMipmaps = !1) : n = pe.sRGBToLinear(n) : r === b && s === m || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
            }
            this.allocateTextureUnit = function() {
                const e = K;
                return e >= M && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + M), K += 1, e
            }, this.resetTextureUnits = function() {
                K = 0
            }, this.setTexture2D = Z, this.setTexture2DArray = function(e, t) {
                const r = i.get(e);
                e.version > 0 && r.__version !== e.version ? ie(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture))
            }, this.setTexture3D = function(e, t) {
                const r = i.get(e);
                e.version > 0 && r.__version !== e.version ? ie(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture))
            }, this.setTextureCube = function(t, r) {
                const a = i.get(t);
                t.version > 0 && a.__version !== t.version ? function(t, i, r) {
                    if (6 !== i.image.length) return;
                    const a = ne(t, i),
                        o = i.source;
                    if (n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), o.version !== o.__currentVersion || !0 === a) {
                        e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                        const t = i.isCompressedTexture || i.image[0].isCompressedTexture,
                            r = i.image[0] && i.image[0].isDataTexture,
                            l = [];
                        for (let e = 0; e < 6; e++) l[e] = t || r ? r ? i.image[e].image : i.image[e] : F(i.image[e], !1, !0, S), l[e] = ce(i, l[e]);
                        const c = l[0],
                            h = U(c) || A,
                            u = s.convert(i.format, i.encoding),
                            d = s.convert(i.type),
                            p = H(i.internalFormat, u, d, i.encoding),
                            f = A && !0 !== i.isVideoTexture,
                            m = void 0 === o.__currentVersion || !0 === a;
                        let g, v = G(i, c, h);
                        if (te(34067, i, h), t) {
                            f && m && n.texStorage2D(34067, v, p, c.width, c.height);
                            for (let e = 0; e < 6; e++) {
                                g = l[e].mipmaps;
                                for (let t = 0; t < g.length; t++) {
                                    const r = g[t];
                                    i.format !== b ? null !== u ? f ? n.compressedTexSubImage2D(34069 + e, t, 0, 0, r.width, r.height, u, r.data) : n.compressedTexImage2D(34069 + e, t, p, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : f ? n.texSubImage2D(34069 + e, t, 0, 0, r.width, r.height, u, d, r.data) : n.texImage2D(34069 + e, t, p, r.width, r.height, 0, u, d, r.data)
                                }
                            }
                        } else {
                            g = i.mipmaps, f && m && (g.length > 0 && v++, n.texStorage2D(34067, v, p, l[0].width, l[0].height));
                            for (let e = 0; e < 6; e++)
                                if (r) {
                                    f ? n.texSubImage2D(34069 + e, 0, 0, 0, l[e].width, l[e].height, u, d, l[e].data) : n.texImage2D(34069 + e, 0, p, l[e].width, l[e].height, 0, u, d, l[e].data);
                                    for (let t = 0; t < g.length; t++) {
                                        const i = g[t].image[e].image;
                                        f ? n.texSubImage2D(34069 + e, t + 1, 0, 0, i.width, i.height, u, d, i.data) : n.texImage2D(34069 + e, t + 1, p, i.width, i.height, 0, u, d, i.data)
                                    }
                                } else {
                                    f ? n.texSubImage2D(34069 + e, 0, 0, 0, u, d, l[e]) : n.texImage2D(34069 + e, 0, p, u, d, l[e]);
                                    for (let t = 0; t < g.length; t++) {
                                        const i = g[t];
                                        f ? n.texSubImage2D(34069 + e, t + 1, 0, 0, u, d, i.image[e]) : n.texImage2D(34069 + e, t + 1, p, u, d, i.image[e])
                                    }
                                }
                        }
                        z(i, h) && V(34067), o.__currentVersion = o.version, i.onUpdate && i.onUpdate(i)
                    }
                    t.__version = i.version
                }(a, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture))
            }, this.rebindTextures = function(e, t, n) {
                const r = i.get(e);
                void 0 !== t && re(r.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && ae(e)
            }, this.setupRenderTarget = function(t) {
                const o = t.texture,
                    l = i.get(t),
                    c = i.get(o);
                t.addEventListener("dispose", Y), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = e.createTexture()), c.__version = o.version, a.memory.textures++);
                const h = !0 === t.isWebGLCubeRenderTarget,
                    u = !0 === t.isWebGLMultipleRenderTargets,
                    d = U(t) || A;
                if (h) {
                    l.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++) l.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (l.__webglFramebuffer = e.createFramebuffer(), u)
                        if (r.drawBuffers) {
                            const n = t.texture;
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = i.get(n[t]);
                                void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), a.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (A && t.samples > 0 && !1 === le(t)) {
                        const i = u ? o : [o];
                        l.__webglMultisampledFramebuffer = e.createFramebuffer(), l.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            const r = i[n];
                            l.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(36161, l.__webglColorRenderbuffer[n]);
                            const a = s.convert(r.format, r.encoding),
                                o = s.convert(r.type),
                                c = H(r.internalFormat, a, o, r.encoding),
                                h = oe(t);
                            e.renderbufferStorageMultisample(36161, h, c, t.width, t.height), e.framebufferRenderbuffer(36160, 36064 + n, 36161, l.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(36161, null), t.depthBuffer && (l.__webglDepthRenderbuffer = e.createRenderbuffer(), se(l.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
                    }
                }
                if (h) {
                    n.bindTexture(34067, c.__webglTexture), te(34067, o, d);
                    for (let e = 0; e < 6; e++) re(l.__webglFramebuffer[e], t, o, 36064, 34069 + e);
                    z(o, d) && V(34067), n.unbindTexture()
                } else if (u) {
                    const e = t.texture;
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r],
                            a = i.get(s);
                        n.bindTexture(3553, a.__webglTexture), te(3553, s, d), re(l.__webglFramebuffer, t, s, 36064 + r, 3553), z(s, d) && V(3553)
                    }
                    n.unbindTexture()
                } else {
                    let e = 3553;
                    (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (A ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(e, c.__webglTexture), te(e, o, d), re(l.__webglFramebuffer, t, o, 36064, e), z(o, d) && V(e), n.unbindTexture()
                }
                t.depthBuffer && ae(t)
            }, this.updateRenderTargetMipmap = function(e) {
                const t = U(e) || A,
                    r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                for (let s = 0, a = r.length; s < a; s++) {
                    const a = r[s];
                    if (z(a, t)) {
                        const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                            r = i.get(a).__webglTexture;
                        n.bindTexture(t, r), V(t), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function(t) {
                if (A && t.samples > 0 && !1 === le(t)) {
                    const r = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                        s = t.width,
                        a = t.height;
                    let o = 16384;
                    const l = [],
                        c = t.stencilBuffer ? 33306 : 36096,
                        h = i.get(t),
                        u = !0 === t.isWebGLMultipleRenderTargets;
                    if (u)
                        for (let t = 0; t < r.length; t++) n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, null), n.bindFramebuffer(36160, h.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
                    n.bindFramebuffer(36008, h.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, h.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        l.push(36064 + n), t.depthBuffer && l.push(c);
                        const d = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                        if (!1 === d && (t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024)), u && e.framebufferRenderbuffer(36008, 36064, 36161, h.__webglColorRenderbuffer[n]), !0 === d && (e.invalidateFramebuffer(36008, [c]), e.invalidateFramebuffer(36009, [c])), u) {
                            const t = i.get(r[n]).__webglTexture;
                            e.framebufferTexture2D(36009, 36064, 3553, t, 0)
                        }
                        e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728), D && e.invalidateFramebuffer(36008, l)
                    }
                    if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), u)
                        for (let t = 0; t < r.length; t++) {
                            n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, h.__webglColorRenderbuffer[t]);
                            const s = i.get(r[t]).__webglTexture;
                            n.bindFramebuffer(36160, h.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0)
                        }
                    n.bindFramebuffer(36009, h.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = ae, this.setupFrameBufferTexture = re, this.useMultisampledRTT = le
        }

        function ls(e, t, n) {
            const i = n.isWebGL2;
            return {
                convert: function(n, r = null) {
                    let s;
                    if (n === m) return 5121;
                    if (1017 === n) return 32819;
                    if (1018 === n) return 32820;
                    if (1010 === n) return 5120;
                    if (1011 === n) return 5122;
                    if (1012 === n) return 5123;
                    if (1013 === n) return 5124;
                    if (n === g) return 5125;
                    if (n === v) return 5126;
                    if (n === x) return i ? 5131 : (s = t.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
                    if (1021 === n) return 6406;
                    if (n === b) return 6408;
                    if (1024 === n) return 6409;
                    if (1025 === n) return 6410;
                    if (n === _) return 6402;
                    if (n === y) return 34041;
                    if (1028 === n) return 6403;
                    if (1022 === n) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                    if (n === N) return s = t.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
                    if (1029 === n) return 36244;
                    if (1030 === n) return 33319;
                    if (1031 === n) return 33320;
                    if (1033 === n) return 36249;
                    if (n === A || n === M || n === S || n === E)
                        if (r === R) {
                            if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
                            if (n === A) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === M) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === S) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === E) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (s = t.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
                            if (n === A) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === M) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === S) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === E) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                        if (s = t.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
                        if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === n) return s = t.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === n || 37496 === n) {
                        if (s = t.get("WEBGL_compressed_texture_etc"), null === s) return null;
                        if (37492 === n) return r === R ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                        if (37496 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (s = t.get("WEBGL_compressed_texture_astc"), null === s) return null;
                        if (37808 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n) return r === R ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (36492 === n) {
                        if (s = t.get("EXT_texture_compression_bptc"), null === s) return null;
                        if (36492 === n) return r === R ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    }
                    return n === w ? i ? 34042 : (s = t.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class cs extends Tn {
            constructor(e = []) {
                super(), this.isArrayCamera = !0, this.cameras = e
            }
        }
        class hs extends Et {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const us = {
            type: "move"
        };
        class ds {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new hs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new hs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Me, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Me), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new hs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Me, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Me), this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(e, t, n) {
                let i = null,
                    r = null,
                    s = null;
                const a = this._targetRay,
                    o = this._grip,
                    l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        s = !0;
                        for (const i of e.hand.values()) {
                            const e = t.getJointPose(i, n);
                            if (void 0 === l.joints[i.jointName]) {
                                const e = new hs;
                                e.matrixAutoUpdate = !1, e.visible = !1, l.joints[i.jointName] = e, l.add(e)
                            }
                            const r = l.joints[i.jointName];
                            null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e
                        }
                        const i = l.joints["index-finger-tip"],
                            r = l.joints["thumb-tip"],
                            a = i.position.distanceTo(r.position),
                            o = .02,
                            c = .005;
                        l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    null !== a && (i = t.getPose(e.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(us)))
                }
                return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
            }
        }
        class ps extends ve {
            constructor(e, t, n, i, r, s, a, o, l, c) {
                if ((c = void 0 !== c ? c : _) !== _ && c !== y) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === _ && (n = g), void 0 === n && c === y && (n = w), super(null, i, r, s, a, o, c, n, l), this.isDepthTexture = !0, this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== a ? a : h, this.minFilter = void 0 !== o ? o : h, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        class fs extends F {
            constructor(e, t) {
                super();
                const n = this;
                let i = null,
                    r = 1,
                    s = null,
                    a = "local-floor",
                    o = null,
                    l = null,
                    c = null,
                    h = null,
                    u = null,
                    d = null;
                const p = t.getContextAttributes();
                let f = null,
                    v = null;
                const x = [],
                    A = [],
                    M = new Tn;
                M.layers.enable(1), M.viewport = new xe;
                const S = new Tn;
                S.layers.enable(2), S.viewport = new xe;
                const E = [M, S],
                    T = new cs;
                T.layers.enable(1), T.layers.enable(2);
                let C = null,
                    D = null;

                function P(e) {
                    const t = A.indexOf(e.inputSource);
                    if (-1 === t) return;
                    const n = x[t];
                    void 0 !== n && n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    })
                }

                function R() {
                    i.removeEventListener("select", P), i.removeEventListener("selectstart", P), i.removeEventListener("selectend", P), i.removeEventListener("squeeze", P), i.removeEventListener("squeezestart", P), i.removeEventListener("squeezeend", P), i.removeEventListener("end", R), i.removeEventListener("inputsourceschange", L);
                    for (let e = 0; e < x.length; e++) {
                        const t = A[e];
                        null !== t && (A[e] = null, x[e].disconnect(t))
                    }
                    C = null, D = null, e.setRenderTarget(f), u = null, h = null, c = null, i = null, v = null, N.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function L(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t],
                            i = A.indexOf(n);
                        i >= 0 && (A[i] = null, x[i].dispatchEvent({
                            type: "disconnected",
                            data: n
                        }))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let i = A.indexOf(n);
                        if (-1 === i) {
                            for (let e = 0; e < x.length; e++) {
                                if (e >= A.length) {
                                    A.push(n), i = e;
                                    break
                                }
                                if (null === A[e]) {
                                    A[e] = n, i = e;
                                    break
                                }
                            }
                            if (-1 === i) break
                        }
                        const r = x[i];
                        r && r.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                    let t = x[e];
                    return void 0 === t && (t = new ds, x[e] = t), t.getTargetRaySpace()
                }, this.getControllerGrip = function(e) {
                    let t = x[e];
                    return void 0 === t && (t = new ds, x[e] = t), t.getGripSpace()
                }, this.getHand = function(e) {
                    let t = x[e];
                    return void 0 === t && (t = new ds, x[e] = t), t.getHandSpace()
                }, this.setFramebufferScaleFactor = function(e) {
                    r = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(e) {
                    a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return o || s
                }, this.setReferenceSpace = function(e) {
                    o = e
                }, this.getBaseLayer = function() {
                    return null !== h ? h : u
                }, this.getBinding = function() {
                    return c
                }, this.getFrame = function() {
                    return d
                }, this.getSession = function() {
                    return i
                }, this.setSession = async function(l) {
                    if (i = l, null !== i) {
                        if (f = e.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", R), i.addEventListener("inputsourceschange", L), !0 !== p.xrCompatible && await t.makeXRCompatible(), void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || p.antialias,
                                alpha: p.alpha,
                                depth: p.depth,
                                stencil: p.stencil,
                                framebufferScaleFactor: r
                            };
                            u = new XRWebGLLayer(i, t, n), i.updateRenderState({
                                baseLayer: u
                            }), v = new we(u.framebufferWidth, u.framebufferHeight, {
                                format: b,
                                type: m,
                                encoding: e.outputEncoding
                            })
                        } else {
                            let n = null,
                                s = null,
                                a = null;
                            p.depth && (a = p.stencil ? 35056 : 33190, n = p.stencil ? y : _, s = p.stencil ? w : g);
                            const o = {
                                colorFormat: 32856,
                                depthFormat: a,
                                scaleFactor: r
                            };
                            c = new XRWebGLBinding(i, t), h = c.createProjectionLayer(o), i.updateRenderState({
                                layers: [h]
                            }), v = new we(h.textureWidth, h.textureHeight, {
                                format: b,
                                type: m,
                                depthTexture: new ps(h.textureWidth, h.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: p.stencil,
                                encoding: e.outputEncoding,
                                samples: p.antialias ? 4 : 0
                            }), e.properties.get(v).__ignoreDepthValues = h.ignoreDepthValues
                        }
                        v.isXRRenderTarget = !0, this.setFoveation(1), o = null, s = await i.requestReferenceSpace(a), N.setContext(i), N.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                };
                const I = new Me,
                    B = new Me;

                function O(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === i) return;
                    T.near = S.near = M.near = e.near, T.far = S.far = M.far = e.far, C === T.near && D === T.far || (i.updateRenderState({
                        depthNear: T.near,
                        depthFar: T.far
                    }), C = T.near, D = T.far);
                    const t = e.parent,
                        n = T.cameras;
                    O(T, t);
                    for (let e = 0; e < n.length; e++) O(n[e], t);
                    T.matrixWorld.decompose(T.position, T.quaternion, T.scale), e.position.copy(T.position), e.quaternion.copy(T.quaternion), e.scale.copy(T.scale), e.matrix.copy(T.matrix), e.matrixWorld.copy(T.matrixWorld);
                    const r = e.children;
                    for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
                    2 === n.length ? function(e, t, n) {
                        I.setFromMatrixPosition(t.matrixWorld), B.setFromMatrixPosition(n.matrixWorld);
                        const i = I.distanceTo(B),
                            r = t.projectionMatrix.elements,
                            s = n.projectionMatrix.elements,
                            a = r[14] / (r[10] - 1),
                            o = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            c = (r[9] - 1) / r[5],
                            h = (r[8] - 1) / r[0],
                            u = (s[8] + 1) / s[0],
                            d = a * h,
                            p = a * u,
                            f = i / (-h + u),
                            m = f * -h;
                        t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                        const g = a + f,
                            v = o + f,
                            x = d - m,
                            w = p + (i - m),
                            b = l * o / v * g,
                            _ = c * o / v * g;
                        e.projectionMatrix.makePerspective(x, w, b, _, g, v)
                    }(T, M, S) : T.projectionMatrix.copy(M.projectionMatrix)
                }, this.getCamera = function() {
                    return T
                }, this.getFoveation = function() {
                    return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
                }, this.setFoveation = function(e) {
                    null !== h && (h.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
                };
                let k = null;
                const N = new Un;
                N.setAnimationLoop((function(t, n) {
                    if (l = n.getViewerPose(o || s), d = n, null !== l) {
                        const t = l.views;
                        null !== u && (e.setRenderTargetFramebuffer(v, u.framebuffer), e.setRenderTarget(v));
                        let n = !1;
                        t.length !== T.cameras.length && (T.cameras.length = 0, n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            let s = null;
                            if (null !== u) s = u.getViewport(r);
                            else {
                                const t = c.getViewSubImage(h, r);
                                s = t.viewport, 0 === i && (e.setRenderTargetTextures(v, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(v))
                            }
                            let a = E[i];
                            void 0 === a && (a = new Tn, a.layers.enable(i), a.viewport = new xe, E[i] = a), a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && T.matrix.copy(a.matrix), !0 === n && T.cameras.push(a)
                        }
                    }
                    for (let e = 0; e < x.length; e++) {
                        const t = A[e],
                            i = x[e];
                        null !== t && void 0 !== i && i.update(t, n, o || s)
                    }
                    k && k(t, n), d = null
                })), this.setAnimationLoop = function(e) {
                    k = e
                }, this.dispose = function() {}
            }
        }

        function ms(e, t) {
            function n(n, i) {
                n.opacity.value = i.opacity, i.color && n.diffuse.value.copy(i.color), i.emissive && n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (n.map.value = i.map), i.alphaMap && (n.alphaMap.value = i.alphaMap), i.bumpMap && (n.bumpMap.value = i.bumpMap, n.bumpScale.value = i.bumpScale, 1 === i.side && (n.bumpScale.value *= -1)), i.displacementMap && (n.displacementMap.value = i.displacementMap, n.displacementScale.value = i.displacementScale, n.displacementBias.value = i.displacementBias), i.emissiveMap && (n.emissiveMap.value = i.emissiveMap), i.normalMap && (n.normalMap.value = i.normalMap, n.normalScale.value.copy(i.normalScale), 1 === i.side && n.normalScale.value.negate()), i.specularMap && (n.specularMap.value = i.specularMap), i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest);
                const r = t.get(i).envMap;
                if (r && (n.envMap.value = r, n.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = i.reflectivity, n.ior.value = i.ior, n.refractionRatio.value = i.refractionRatio), i.lightMap) {
                    n.lightMap.value = i.lightMap;
                    const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
                    n.lightMapIntensity.value = i.lightMapIntensity * t
                }
                let s, a;
                i.aoMap && (n.aoMap.value = i.aoMap, n.aoMapIntensity.value = i.aoMapIntensity), i.map ? s = i.map : i.specularMap ? s = i.specularMap : i.displacementMap ? s = i.displacementMap : i.normalMap ? s = i.normalMap : i.bumpMap ? s = i.bumpMap : i.roughnessMap ? s = i.roughnessMap : i.metalnessMap ? s = i.metalnessMap : i.alphaMap ? s = i.alphaMap : i.emissiveMap ? s = i.emissiveMap : i.clearcoatMap ? s = i.clearcoatMap : i.clearcoatNormalMap ? s = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? s = i.clearcoatRoughnessMap : i.iridescenceMap ? s = i.iridescenceMap : i.iridescenceThicknessMap ? s = i.iridescenceThicknessMap : i.specularIntensityMap ? s = i.specularIntensityMap : i.specularColorMap ? s = i.specularColorMap : i.transmissionMap ? s = i.transmissionMap : i.thicknessMap ? s = i.thicknessMap : i.sheenColorMap ? s = i.sheenColorMap : i.sheenRoughnessMap && (s = i.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), n.uvTransform.value.copy(s.matrix)), i.aoMap ? a = i.aoMap : i.lightMap && (a = i.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), n.uv2Transform.value.copy(a.matrix))
            }
            return {
                refreshFogUniforms: function(e, t) {
                    e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                },
                refreshMaterialUniforms: function(e, i, r, s, a) {
                    i.isMeshBasicMaterial || i.isMeshLambertMaterial ? n(e, i) : i.isMeshToonMaterial ? (n(e, i), function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, i)) : i.isMeshPhongMaterial ? (n(e, i), function(e, t) {
                        e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, i)) : i.isMeshStandardMaterial ? (n(e, i), function(e, n) {
                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                    }(e, i), i.isMeshPhysicalMaterial && function(e, t, n) {
                        e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate())), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap)), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = n.texture, e.transmissionSamplerSize.value.set(n.width, n.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
                    }(e, i, a)) : i.isMeshMatcapMaterial ? (n(e, i), function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, i)) : i.isMeshDepthMaterial ? n(e, i) : i.isMeshDistanceMaterial ? (n(e, i), function(e, t) {
                        e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                    }(e, i)) : i.isMeshNormalMaterial ? n(e, i) : i.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                    }(e, i), i.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                    }(e, i)) : i.isPointsMaterial ? function(e, t, n, i) {
                        let r;
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? r = t.map : t.alphaMap && (r = t.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
                    }(e, i, r, s) : i.isSpriteMaterial ? function(e, t) {
                        let n;
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                    }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }

        function gs(e = {}) {
            this.isWebGLRenderer = !0;
            const t = void 0 !== e.canvas ? e.canvas : function() {
                    const e = ee("canvas");
                    return e.style.display = "block", e
                }(),
                n = void 0 !== e.context ? e.context : null,
                i = void 0 === e.depth || e.depth,
                r = void 0 === e.stencil || e.stencil,
                s = void 0 !== e.antialias && e.antialias,
                a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                o = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                l = void 0 !== e.powerPreference ? e.powerPreference : "default",
                c = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
            let h;
            h = null !== n ? n.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
            let u = null,
                d = null;
            const p = [],
                g = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = P, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, Object.defineProperties(this, {
                gammaFactor: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                    }
                }
            });
            const w = this;
            let _ = !1,
                y = 0,
                A = 0,
                M = null,
                S = -1,
                E = null;
            const T = new xe,
                C = new xe;
            let D = null,
                R = t.width,
                L = t.height,
                I = 1,
                B = null,
                O = null;
            const k = new xe(0, 0, R, L),
                N = new xe(0, 0, R, L);
            let F = !1;
            const U = new Fn;
            let z = !1,
                V = !1,
                H = null;
            const G = new tt,
                W = new Z,
                j = new Me,
                Y = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function X() {
                return null === M ? I : 1
            }
            let Q, K, J, $, te, ne, ie, re, se, ae, oe, le, ce, he, ue, de, pe, fe, me, ge, ve, be, _e, ye = n;

            function Ae(e, n) {
                for (let i = 0; i < e.length; i++) {
                    const r = e[i],
                        s = t.getContext(r, n);
                    if (null !== s) return s
                }
                return null
            }
            try {
                const e = {
                    alpha: !0,
                    depth: i,
                    stencil: r,
                    antialias: s,
                    premultipliedAlpha: a,
                    preserveDrawingBuffer: o,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: c
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", "three.js r142"), t.addEventListener("webglcontextlost", Te, !1), t.addEventListener("webglcontextrestored", Ce, !1), t.addEventListener("webglcontextcreationerror", De, !1), null === ye) {
                    const t = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === w.isWebGL1Renderer && t.shift(), ye = Ae(t, e), null === ye) throw Ae(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === ye.getShaderPrecisionFormat && (ye.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (e) {
                throw console.error("THREE.WebGLRenderer: " + e.message), e
            }

            function Se() {
                Q = new ui(ye), K = new Qn(ye, Q, e), Q.init(K), be = new ls(ye, Q, K), J = new as(ye, Q, K), $ = new fi, te = new Yr, ne = new os(ye, Q, J, te, K, be, $), ie = new Kn(w), re = new hi(w), se = new zn(ye, K), _e = new Yn(ye, Q, se, K), ae = new di(ye, se, $, _e), oe = new wi(ye, ae, se, $), me = new xi(ye, K, ne), de = new qn(te), le = new jr(w, ie, re, Q, K, _e, de), ce = new ms(w, te), he = new Kr, ue = new ns(Q, K), fe = new jn(w, ie, J, oe, h, a), pe = new ss(w, oe, K), ge = new Xn(ye, Q, $, K), ve = new pi(ye, Q, $, K), $.programs = le.programs, w.capabilities = K, w.extensions = Q, w.properties = te, w.renderLists = he, w.shadowMap = pe, w.state = J, w.info = $
            }
            Se();
            const Ee = new fs(w, ye);

            function Te(e) {
                e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
            }

            function Ce() {
                console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
                const e = $.autoReset,
                    t = pe.enabled,
                    n = pe.autoUpdate,
                    i = pe.needsUpdate,
                    r = pe.type;
                Se(), $.autoReset = e, pe.enabled = t, pe.autoUpdate = n, pe.needsUpdate = i, pe.type = r
            }

            function De(e) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
            }

            function Pe(e) {
                const t = e.target;
                t.removeEventListener("dispose", Pe),
                    function(e) {
                        (function(e) {
                            const t = te.get(e).programs;
                            void 0 !== t && (t.forEach((function(e) {
                                le.releaseProgram(e)
                            })), e.isShaderMaterial && le.releaseShaderCache(e))
                        })(e), te.remove(e)
                    }(t)
            }
            this.xr = Ee, this.getContext = function() {
                return ye
            }, this.getContextAttributes = function() {
                return ye.getContextAttributes()
            }, this.forceContextLoss = function() {
                const e = Q.get("WEBGL_lose_context");
                e && e.loseContext()
            }, this.forceContextRestore = function() {
                const e = Q.get("WEBGL_lose_context");
                e && e.restoreContext()
            }, this.getPixelRatio = function() {
                return I
            }, this.setPixelRatio = function(e) {
                void 0 !== e && (I = e, this.setSize(R, L, !1))
            }, this.getSize = function(e) {
                return e.set(R, L)
            }, this.setSize = function(e, n, i) {
                Ee.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e, L = n, t.width = Math.floor(e * I), t.height = Math.floor(n * I), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
            }, this.getDrawingBufferSize = function(e) {
                return e.set(R * I, L * I).floor()
            }, this.setDrawingBufferSize = function(e, n, i) {
                R = e, L = n, I = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
            }, this.getCurrentViewport = function(e) {
                return e.copy(T)
            }, this.getViewport = function(e) {
                return e.copy(k)
            }, this.setViewport = function(e, t, n, i) {
                e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, n, i), J.viewport(T.copy(k).multiplyScalar(I).floor())
            }, this.getScissor = function(e) {
                return e.copy(N)
            }, this.setScissor = function(e, t, n, i) {
                e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, i), J.scissor(C.copy(N).multiplyScalar(I).floor())
            }, this.getScissorTest = function() {
                return F
            }, this.setScissorTest = function(e) {
                J.setScissorTest(F = e)
            }, this.setOpaqueSort = function(e) {
                B = e
            }, this.setTransparentSort = function(e) {
                O = e
            }, this.getClearColor = function(e) {
                return e.copy(fe.getClearColor())
            }, this.setClearColor = function() {
                fe.setClearColor.apply(fe, arguments)
            }, this.getClearAlpha = function() {
                return fe.getClearAlpha()
            }, this.setClearAlpha = function() {
                fe.setClearAlpha.apply(fe, arguments)
            }, this.clear = function(e = !0, t = !0, n = !0) {
                let i = 0;
                e && (i |= 16384), t && (i |= 256), n && (i |= 1024), ye.clear(i)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", Te, !1), t.removeEventListener("webglcontextrestored", Ce, !1), t.removeEventListener("webglcontextcreationerror", De, !1), he.dispose(), ue.dispose(), te.dispose(), ie.dispose(), re.dispose(), oe.dispose(), _e.dispose(), le.dispose(), Ee.dispose(), Ee.removeEventListener("sessionstart", Le), Ee.removeEventListener("sessionend", Ie), H && (H.dispose(), H = null), Be.stop()
            }, this.renderBufferDirect = function(e, t, n, i, r, s) {
                null === t && (t = Y);
                const a = r.isMesh && r.matrixWorld.determinant() < 0,
                    o = function(e, t, n, i, r) {
                        !0 !== t.isScene && (t = Y), ne.resetTextureUnits();
                        const s = t.fog,
                            a = i.isMeshStandardMaterial ? t.environment : null,
                            o = null === M ? w.outputEncoding : !0 === M.isXRRenderTarget ? M.texture.encoding : P,
                            l = (i.isMeshStandardMaterial ? re : ie).get(i.envMap || a),
                            c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                            h = !!i.normalMap && !!n.attributes.tangent,
                            u = !!n.morphAttributes.position,
                            p = !!n.morphAttributes.normal,
                            f = !!n.morphAttributes.color,
                            m = i.toneMapped ? w.toneMapping : 0,
                            g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                            v = void 0 !== g ? g.length : 0,
                            x = te.get(i),
                            b = d.state.lights;
                        if (!0 === z && (!0 === V || e !== E)) {
                            const t = e === E && i.id === S;
                            de.setState(i, e, t)
                        }
                        let _ = !1;
                        i.version === x.__version ? x.needsLights && x.lightsStateVersion !== b.state.version || x.outputEncoding !== o || r.isInstancedMesh && !1 === x.instancing ? _ = !0 : r.isInstancedMesh || !0 !== x.instancing ? r.isSkinnedMesh && !1 === x.skinning ? _ = !0 : r.isSkinnedMesh || !0 !== x.skinning ? x.envMap !== l || !0 === i.fog && x.fog !== s ? _ = !0 : void 0 === x.numClippingPlanes || x.numClippingPlanes === de.numPlanes && x.numIntersection === de.numIntersection ? (x.vertexAlphas !== c || x.vertexTangents !== h || x.morphTargets !== u || x.morphNormals !== p || x.morphColors !== f || x.toneMapping !== m || !0 === K.isWebGL2 && x.morphTargetsCount !== v) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : (_ = !0, x.__version = i.version);
                        let y = x.currentProgram;
                        !0 === _ && (y = Ue(i, t, r));
                        let A = !1,
                            T = !1,
                            C = !1;
                        const D = y.getUniforms(),
                            R = x.uniforms;
                        if (J.useProgram(y.program) && (A = !0, T = !0, C = !0), i.id !== S && (S = i.id, T = !0), A || E !== e) {
                            if (D.setValue(ye, "projectionMatrix", e.projectionMatrix), K.logarithmicDepthBuffer && D.setValue(ye, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), E !== e && (E = e, T = !0, C = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                                const t = D.map.cameraPosition;
                                void 0 !== t && t.setValue(ye, j.setFromMatrixPosition(e.matrixWorld))
                            }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && D.setValue(ye, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && D.setValue(ye, "viewMatrix", e.matrixWorldInverse)
                        }
                        if (r.isSkinnedMesh) {
                            D.setOptional(ye, r, "bindMatrix"), D.setOptional(ye, r, "bindMatrixInverse");
                            const e = r.skeleton;
                            e && (K.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), D.setValue(ye, "boneTexture", e.boneTexture, ne), D.setValue(ye, "boneTextureSize", e.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        const B = n.morphAttributes;
                        var O, k;
                        return (void 0 !== B.position || void 0 !== B.normal || void 0 !== B.color && !0 === K.isWebGL2) && me.update(r, n, i, y), (T || x.receiveShadow !== r.receiveShadow) && (x.receiveShadow = r.receiveShadow, D.setValue(ye, "receiveShadow", r.receiveShadow)), T && (D.setValue(ye, "toneMappingExposure", w.toneMappingExposure), x.needsLights && (k = C, (O = R).ambientLightColor.needsUpdate = k, O.lightProbe.needsUpdate = k, O.directionalLights.needsUpdate = k, O.directionalLightShadows.needsUpdate = k, O.pointLights.needsUpdate = k, O.pointLightShadows.needsUpdate = k, O.spotLights.needsUpdate = k, O.spotLightShadows.needsUpdate = k, O.rectAreaLights.needsUpdate = k, O.hemisphereLights.needsUpdate = k), s && !0 === i.fog && ce.refreshFogUniforms(R, s), ce.refreshMaterialUniforms(R, i, I, L, H), Ar.upload(ye, x.uniformsList, R, ne)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ar.upload(ye, x.uniformsList, R, ne), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && D.setValue(ye, "center", r.center), D.setValue(ye, "modelViewMatrix", r.modelViewMatrix), D.setValue(ye, "normalMatrix", r.normalMatrix), D.setValue(ye, "modelMatrix", r.matrixWorld), y
                    }(e, t, n, i, r);
                J.setMaterial(i, a);
                let l = n.index;
                const c = n.attributes.position;
                if (null === l) {
                    if (void 0 === c || 0 === c.count) return
                } else if (0 === l.count) return;
                let h, u = 1;
                !0 === i.wireframe && (l = ae.getWireframeAttribute(n), u = 2), _e.setup(r, i, o, n, l);
                let p = ge;
                null !== l && (h = se.get(l), p = ve, p.setIndex(h));
                const f = null !== l ? l.count : c.count,
                    m = n.drawRange.start * u,
                    g = n.drawRange.count * u,
                    v = null !== s ? s.start * u : 0,
                    x = null !== s ? s.count * u : 1 / 0,
                    b = Math.max(m, v),
                    _ = Math.min(f, m + g, v + x) - 1,
                    y = Math.max(0, _ - b + 1);
                if (0 !== y) {
                    if (r.isMesh) !0 === i.wireframe ? (J.setLineWidth(i.wireframeLinewidth * X()), p.setMode(1)) : p.setMode(4);
                    else if (r.isLine) {
                        let e = i.linewidth;
                        void 0 === e && (e = 1), J.setLineWidth(e * X()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                    } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                    if (r.isInstancedMesh) p.renderInstances(b, y, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = Math.min(n.instanceCount, n._maxInstanceCount);
                        p.renderInstances(b, y, e)
                    } else p.render(b, y)
                }
            }, this.compile = function(e, t) {
                d = ue.get(e), d.init(), g.push(d), e.traverseVisible((function(e) {
                    e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e))
                })), d.setupLights(w.physicallyCorrectLights), e.traverse((function(t) {
                    const n = t.material;
                    if (n)
                        if (Array.isArray(n))
                            for (let i = 0; i < n.length; i++) Ue(n[i], e, t);
                        else Ue(n, e, t)
                })), g.pop(), d = null
            };
            let Re = null;

            function Le() {
                Be.stop()
            }

            function Ie() {
                Be.start()
            }
            const Be = new Un;

            function Oe(e, t, n, i) {
                if (!1 === e.visible) return;
                if (e.layers.test(t.layers))
                    if (e.isGroup) n = e.renderOrder;
                    else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || U.intersectsSprite(e)) {
                        i && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G);
                        const t = oe.update(e),
                            r = e.material;
                        r.visible && u.push(e, t, r, n, j.z, null)
                    }
                } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== $.render.frame && (e.skeleton.update(), e.skeleton.frame = $.render.frame), !e.frustumCulled || U.intersectsObject(e))) {
                    i && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G);
                    const t = oe.update(e),
                        r = e.material;
                    if (Array.isArray(r)) {
                        const i = t.groups;
                        for (let s = 0, a = i.length; s < a; s++) {
                            const a = i[s],
                                o = r[a.materialIndex];
                            o && o.visible && u.push(e, t, o, n, j.z, a)
                        }
                    } else r.visible && u.push(e, t, r, n, j.z, null)
                }
                const r = e.children;
                for (let e = 0, s = r.length; e < s; e++) Oe(r[e], t, n, i)
            }

            function ke(e, t, n, i) {
                const r = e.opaque,
                    a = e.transmissive,
                    o = e.transparent;
                d.setupLightsView(n), a.length > 0 && function(e, t, n) {
                    const i = K.isWebGL2;
                    null === H && (H = new we(1, 1, {
                        generateMipmaps: !0,
                        type: Q.has("EXT_color_buffer_half_float") ? x : m,
                        minFilter: f,
                        samples: i && !0 === s ? 4 : 0
                    })), w.getDrawingBufferSize(W), i ? H.setSize(W.x, W.y) : H.setSize(q(W.x), q(W.y));
                    const r = w.getRenderTarget();
                    w.setRenderTarget(H), w.clear();
                    const a = w.toneMapping;
                    w.toneMapping = 0, Ne(e, t, n), w.toneMapping = a, ne.updateMultisampleRenderTarget(H), ne.updateRenderTargetMipmap(H), w.setRenderTarget(r)
                }(r, t, n), i && J.viewport(T.copy(i)), r.length > 0 && Ne(r, t, n), a.length > 0 && Ne(a, t, n), o.length > 0 && Ne(o, t, n), J.buffers.depth.setTest(!0), J.buffers.depth.setMask(!0), J.buffers.color.setMask(!0), J.setPolygonOffset(!1)
            }

            function Ne(e, t, n) {
                const i = !0 === t.isScene ? t.overrideMaterial : null;
                for (let r = 0, s = e.length; r < s; r++) {
                    const s = e[r],
                        a = s.object,
                        o = s.geometry,
                        l = null === i ? s.material : i,
                        c = s.group;
                    a.layers.test(n.layers) && Fe(a, t, n, o, l, c)
                }
            }

            function Fe(e, t, n, i, r, s) {
                e.onBeforeRender(w, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(w, t, n, i, e, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, w.renderBufferDirect(n, t, i, r, e, s), r.side = 0, r.needsUpdate = !0, w.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : w.renderBufferDirect(n, t, i, r, e, s), e.onAfterRender(w, t, n, i, r, s)
            }

            function Ue(e, t, n) {
                !0 !== t.isScene && (t = Y);
                const i = te.get(e),
                    r = d.state.lights,
                    s = d.state.shadowsArray,
                    a = r.state.version,
                    o = le.getParameters(e, r.state, s, t, n),
                    l = le.getProgramCacheKey(o);
                let c = i.programs;
                i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? re : ie).get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", Pe), c = new Map, i.programs = c);
                let h = c.get(l);
                if (void 0 !== h) {
                    if (i.currentProgram === h && i.lightsStateVersion === a) return ze(e, o), h
                } else o.uniforms = le.getUniforms(e), e.onBuild(n, o, w), e.onBeforeCompile(o, w), h = le.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                const u = i.uniforms;
                (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = de.uniform), ze(e, o), i.needsLights = function(e) {
                    return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                }(e), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = h.getUniforms(),
                    f = Ar.seqWithValue(p.seq, u);
                return i.currentProgram = h, i.uniformsList = f, h
            }

            function ze(e, t) {
                const n = te.get(e);
                n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
            }
            Be.setAnimationLoop((function(e) {
                Re && Re(e)
            })), "undefined" != typeof self && Be.setContext(self), this.setAnimationLoop = function(e) {
                Re = e, Ee.setAnimationLoop(e), null === e ? Be.stop() : Be.start()
            }, Ee.addEventListener("sessionstart", Le), Ee.addEventListener("sessionend", Ie), this.render = function(e, t) {
                if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === _) return;
                !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === Ee.enabled && !0 === Ee.isPresenting && (!0 === Ee.cameraAutoUpdate && Ee.updateCamera(t), t = Ee.getCamera()), !0 === e.isScene && e.onBeforeRender(w, e, t, M), d = ue.get(e, g.length), d.init(), g.push(d), G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), U.setFromProjectionMatrix(G), V = this.localClippingEnabled, z = de.init(this.clippingPlanes, V, t), u = he.get(e, p.length), u.init(), p.push(u), Oe(e, t, 0, w.sortObjects), u.finish(), !0 === w.sortObjects && u.sort(B, O), !0 === z && de.beginShadows();
                const n = d.state.shadowsArray;
                if (pe.render(n, e, t), !0 === z && de.endShadows(), !0 === this.info.autoReset && this.info.reset(), fe.render(u, e), d.setupLights(w.physicallyCorrectLights), t.isArrayCamera) {
                    const n = t.cameras;
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        ke(u, e, i, i.viewport)
                    }
                } else ke(u, e, t);
                null !== M && (ne.updateMultisampleRenderTarget(M), ne.updateRenderTargetMipmap(M)), !0 === e.isScene && e.onAfterRender(w, e, t), _e.resetDefaultState(), S = -1, E = null, g.pop(), d = g.length > 0 ? g[g.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
            }, this.getActiveCubeFace = function() {
                return y
            }, this.getActiveMipmapLevel = function() {
                return A
            }, this.getRenderTarget = function() {
                return M
            }, this.setRenderTargetTextures = function(e, t, n) {
                te.get(e.texture).__webglTexture = t, te.get(e.depthTexture).__webglTexture = n;
                const i = te.get(e);
                i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === Q.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1))
            }, this.setRenderTargetFramebuffer = function(e, t) {
                const n = te.get(e);
                n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
            }, this.setRenderTarget = function(e, t = 0, n = 0) {
                M = e, y = t, A = n;
                let i = !0;
                if (e) {
                    const t = te.get(e);
                    void 0 !== t.__useDefaultFramebuffer ? (J.bindFramebuffer(36160, null), i = !1) : void 0 === t.__webglFramebuffer ? ne.setupRenderTarget(e) : t.__hasExternalTextures && ne.rebindTextures(e, te.get(e.texture).__webglTexture, te.get(e.depthTexture).__webglTexture)
                }
                let r = null,
                    s = !1,
                    a = !1;
                if (e) {
                    const n = e.texture;
                    (n.isData3DTexture || n.isDataArrayTexture) && (a = !0);
                    const i = te.get(e).__webglFramebuffer;
                    e.isWebGLCubeRenderTarget ? (r = i[t], s = !0) : r = K.isWebGL2 && e.samples > 0 && !1 === ne.useMultisampledRTT(e) ? te.get(e).__webglMultisampledFramebuffer : i, T.copy(e.viewport), C.copy(e.scissor), D = e.scissorTest
                } else T.copy(k).multiplyScalar(I).floor(), C.copy(N).multiplyScalar(I).floor(), D = F;
                if (J.bindFramebuffer(36160, r) && K.drawBuffers && i && J.drawBuffers(e, r), J.viewport(T), J.scissor(C), J.setScissorTest(D), s) {
                    const i = te.get(e.texture);
                    ye.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n)
                } else if (a) {
                    const i = te.get(e.texture),
                        r = t || 0;
                    ye.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                }
                S = -1
            }, this.readRenderTargetPixels = function(e, t, n, i, r, s, a) {
                if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let o = te.get(e).__webglFramebuffer;
                if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                    J.bindFramebuffer(36160, o);
                    try {
                        const a = e.texture,
                            o = a.format,
                            l = a.type;
                        if (o !== b && be.convert(o) !== ye.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const c = l === x && (Q.has("EXT_color_buffer_half_float") || K.isWebGL2 && Q.has("EXT_color_buffer_float"));
                        if (!(l === m || be.convert(l) === ye.getParameter(35738) || l === v && (K.isWebGL2 || Q.has("OES_texture_float") || Q.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && ye.readPixels(t, n, i, r, be.convert(o), be.convert(l), s)
                    } finally {
                        const e = null !== M ? te.get(M).__webglFramebuffer : null;
                        J.bindFramebuffer(36160, e)
                    }
                }
            }, this.copyFramebufferToTexture = function(e, t, n = 0) {
                const i = Math.pow(2, -n),
                    r = Math.floor(t.image.width * i),
                    s = Math.floor(t.image.height * i);
                ne.setTexture2D(t, 0), ye.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, r, s), J.unbindTexture()
            }, this.copyTextureToTexture = function(e, t, n, i = 0) {
                const r = t.image.width,
                    s = t.image.height,
                    a = be.convert(n.format),
                    o = be.convert(n.type);
                ne.setTexture2D(n, 0), ye.pixelStorei(37440, n.flipY), ye.pixelStorei(37441, n.premultiplyAlpha), ye.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ye.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? ye.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ye.texSubImage2D(3553, i, e.x, e.y, a, o, t.image), 0 === i && n.generateMipmaps && ye.generateMipmap(3553), J.unbindTexture()
            }, this.copyTextureToTexture3D = function(e, t, n, i, r = 0) {
                if (w.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const s = e.max.x - e.min.x + 1,
                    a = e.max.y - e.min.y + 1,
                    o = e.max.z - e.min.z + 1,
                    l = be.convert(i.format),
                    c = be.convert(i.type);
                let h;
                if (i.isData3DTexture) ne.setTexture3D(i, 0), h = 32879;
                else {
                    if (!i.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    ne.setTexture2DArray(i, 0), h = 35866
                }
                ye.pixelStorei(37440, i.flipY), ye.pixelStorei(37441, i.premultiplyAlpha), ye.pixelStorei(3317, i.unpackAlignment);
                const u = ye.getParameter(3314),
                    d = ye.getParameter(32878),
                    p = ye.getParameter(3316),
                    f = ye.getParameter(3315),
                    m = ye.getParameter(32877),
                    g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                ye.pixelStorei(3314, g.width), ye.pixelStorei(32878, g.height), ye.pixelStorei(3316, e.min.x), ye.pixelStorei(3315, e.min.y), ye.pixelStorei(32877, e.min.z), n.isDataTexture || n.isData3DTexture ? ye.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ye.compressedTexSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, g.data)) : ye.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, g), ye.pixelStorei(3314, u), ye.pixelStorei(32878, d), ye.pixelStorei(3316, p), ye.pixelStorei(3315, f), ye.pixelStorei(32877, m), 0 === r && i.generateMipmaps && ye.generateMipmap(h), J.unbindTexture()
            }, this.initTexture = function(e) {
                e.isCubeTexture ? ne.setTextureCube(e, 0) : e.isData3DTexture ? ne.setTexture3D(e, 0) : e.isDataArrayTexture ? ne.setTexture2DArray(e, 0) : ne.setTexture2D(e, 0), J.unbindTexture()
            }, this.resetState = function() {
                y = 0, A = 0, M = null, J.reset(), _e.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }(class extends gs {}).prototype.isWebGL1Renderer = !0;
        class vs extends Et {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
            }
        }
        class xs {
            constructor(e, t) {
                this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = O, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = G()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setUsage(e) {
                return this.usage = e, this
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
            }
            copyAt(e, t, n) {
                e *= this.stride, n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            }
            set(e, t = 0) {
                return this.array.set(e, t), this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = G()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(t, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = G()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const ws = new Me;
        class bs {
            constructor(e, t, n, i = !1) {
                this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++) ws.fromBufferAttribute(this, t), ws.applyMatrix4(e), this.setXYZ(t, ws.x, ws.y, ws.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) ws.fromBufferAttribute(this, t), ws.applyNormalMatrix(e), this.setXYZ(t, ws.x, ws.y, ws.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) ws.fromBufferAttribute(this, t), ws.transformDirection(e), this.setXYZ(t, ws.x, ws.y, ws.z);
                return this
            }
            setX(e, t) {
                return this.data.array[e * this.data.stride + this.offset] = t, this
            }
            setY(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 1] = t, this
            }
            setZ(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 2] = t, this
            }
            setW(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 3] = t, this
            }
            getX(e) {
                return this.data.array[e * this.data.stride + this.offset]
            }
            getY(e) {
                return this.data.array[e * this.data.stride + this.offset + 1]
            }
            getZ(e) {
                return this.data.array[e * this.data.stride + this.offset + 2]
            }
            getW(e) {
                return this.data.array[e * this.data.stride + this.offset + 3]
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            }
            setXYZ(e, t, n, i) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
            }
            setXYZW(e, t, n, i, r) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                    }
                    return new Gt(new this.array.constructor(e), this.itemSize, this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new bs(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const _s = new Me,
            ys = new xe,
            As = new xe,
            Ms = new Me,
            Ss = new tt;
        class Es extends wn {
            constructor(e, t) {
                super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new tt, this.bindMatrixInverse = new tt
            }
            copy(e, t) {
                return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
            }
            bind(e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new xe,
                    t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    e.fromBufferAttribute(t, n);
                    const i = 1 / e.manhattanLength();
                    i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(e, t) {
                const n = this.skeleton,
                    i = this.geometry;
                ys.fromBufferAttribute(i.attributes.skinIndex, e), As.fromBufferAttribute(i.attributes.skinWeight, e), _s.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                for (let e = 0; e < 4; e++) {
                    const i = As.getComponent(e);
                    if (0 !== i) {
                        const r = ys.getComponent(e);
                        Ss.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Ms.copy(_s).applyMatrix4(Ss), i)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class Ts extends Et {
            constructor() {
                super(), this.isBone = !0, this.type = "Bone"
            }
        }
        class Cs extends ve {
            constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, h, u) {
                super(null, s, a, o, l, c, i, r, h, u), this.isDataTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        const Ds = new tt,
            Ps = new tt;
        class Rs {
            constructor(e = [], t = []) {
                this.uuid = G(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
            }
            init() {
                const e = this.bones,
                    t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new tt)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new tt;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones,
                    t = this.boneInverses,
                    n = this.boneMatrices,
                    i = this.boneTexture;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i] ? e[i].matrixWorld : Ps;
                    Ds.multiplyMatrices(r, t[i]), Ds.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Rs(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = Q(e), e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new Cs(t, e, e, b, v);
                return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e) return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, i = e.bones.length; n < i; n++) {
                    const i = e.bones[n];
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Ts), this.bones.push(r), this.boneInverses.push((new tt).fromArray(e.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones,
                    n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    e.bones.push(r.uuid);
                    const s = n[i];
                    e.boneInverses.push(s.toArray())
                }
                return e
            }
        }
        class Ls extends Ut {
            constructor(e) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ue(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
            }
        }
        const Is = new Me,
            Bs = new Me,
            Os = new tt,
            ks = new et,
            Ns = new Ye;
        class Fs extends Et {
            constructor(e = new en, t = new Ls) {
                super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position,
                        n = [0];
                    for (let e = 1, i = t.count; e < i; e++) Is.fromBufferAttribute(t, e - 1), Bs.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += Is.distanceTo(Bs);
                    e.setAttribute("lineDistance", new Yt(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Line.threshold,
                    s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Ns.copy(n.boundingSphere), Ns.applyMatrix4(i), Ns.radius += r, !1 === e.ray.intersectsSphere(Ns)) return;
                Os.copy(i).invert(), ks.copy(e.ray).applyMatrix4(Os);
                const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = a * a,
                    l = new Me,
                    c = new Me,
                    h = new Me,
                    u = new Me,
                    d = this.isLineSegments ? 2 : 1,
                    p = n.index,
                    f = n.attributes.position;
                if (null !== p)
                    for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) {
                        const i = p.getX(n),
                            r = p.getX(n + 1);
                        if (l.fromBufferAttribute(f, i), c.fromBufferAttribute(f, r), ks.distanceSqToSegment(l, c, u, h) > o) continue;
                        u.applyMatrix4(this.matrixWorld);
                        const s = e.ray.origin.distanceTo(u);
                        s < e.near || s > e.far || t.push({
                            distance: s,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    } else
                        for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) {
                            if (l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1), ks.distanceSqToSegment(l, c, u, h) > o) continue;
                            u.applyMatrix4(this.matrixWorld);
                            const i = e.ray.origin.distanceTo(u);
                            i < e.near || i > e.far || t.push({
                                distance: i,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        const Us = new Me,
            zs = new Me;
        class Vs extends Fs {
            constructor(e, t) {
                super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position,
                        n = [];
                    for (let e = 0, i = t.count; e < i; e += 2) Us.fromBufferAttribute(t, e), zs.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + Us.distanceTo(zs);
                    e.setAttribute("lineDistance", new Yt(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class Hs extends Fs {
            constructor(e, t) {
                super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
            }
        }
        class Gs extends Ut {
            constructor(e) {
                super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ue(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
            }
        }
        const Ws = new tt,
            js = new et,
            Ys = new Ye,
            Xs = new Me;
        class Qs extends Et {
            constructor(e = new en, t = new Gs) {
                super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Points.threshold,
                    s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Ys.copy(n.boundingSphere), Ys.applyMatrix4(i), Ys.radius += r, !1 === e.ray.intersectsSphere(Ys)) return;
                Ws.copy(i).invert(), js.copy(e.ray).applyMatrix4(Ws);
                const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = a * a,
                    l = n.index,
                    c = n.attributes.position;
                if (null !== l)
                    for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                        const r = l.getX(n);
                        Xs.fromBufferAttribute(c, r), qs(Xs, r, o, i, e, t, this)
                    } else
                        for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++) Xs.fromBufferAttribute(c, n), qs(Xs, n, o, i, e, t, this)
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }

        function qs(e, t, n, i, r, s, a) {
            const o = js.distanceSqToPoint(e);
            if (o < n) {
                const n = new Me;
                js.closestPointToPoint(e, n), n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far) return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(o),
                    point: n,
                    index: t,
                    face: null,
                    object: a
                })
            }
        }
        class Ks extends ve {
            constructor(e, t, n, i, r, s, a, o, l) {
                super(e, t, n, i, r, s, a, o, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : p, this.magFilter = void 0 !== r ? r : p, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                    c.needsUpdate = !0, e.requestVideoFrameCallback(t)
                }))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class Zs extends ve {
            constructor(e, t, n) {
                super({
                    width: e,
                    height: t
                }), this.isFramebufferTexture = !0, this.format = n, this.magFilter = h, this.minFilter = h, this.generateMipmaps = !1, this.needsUpdate = !0
            }
        }
        class Js extends Ut {
            constructor(e) {
                super(), this.isMeshStandardMaterial = !0, this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new ue(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Z(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class $s extends Js {
            constructor(e) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Z(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return W(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ue(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new ue(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ue(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e)
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++, this._sheen = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++, this._transmission = e
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
            }
        }
        const ea = {
            arraySlice: function(e, t, n) {
                return ea.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            },
            convertArray: function(e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function(e) {
                const t = e.length,
                    n = new Array(t);
                for (let e = 0; e !== t; ++e) n[e] = e;
                return n.sort((function(t, n) {
                    return e[t] - e[n]
                })), n
            },
            sortedArray: function(e, t, n) {
                const i = e.length,
                    r = new e.constructor(i);
                for (let s = 0, a = 0; a !== i; ++s) {
                    const i = n[s] * t;
                    for (let n = 0; n !== t; ++n) r[a++] = e[i + n]
                }
                return r
            },
            flattenJSON: function(e, t, n, i) {
                let r = 1,
                    s = e[0];
                for (; void 0 !== s && void 0 === s[i];) s = e[r++];
                if (void 0 === s) return;
                let a = s[i];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            a = s[i], void 0 !== a && (t.push(s.time), n.push.apply(n, a)), s = e[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                    do {
                        a = s[i], void 0 !== a && (t.push(s.time), a.toArray(n, n.length)), s = e[r++]
                    } while (void 0 !== s);
                else
                    do {
                        a = s[i], void 0 !== a && (t.push(s.time), n.push(a)), s = e[r++]
                    } while (void 0 !== s)
            },
            subclip: function(e, t, n, i, r = 30) {
                const s = e.clone();
                s.name = t;
                const a = [];
                for (let e = 0; e < s.tracks.length; ++e) {
                    const t = s.tracks[e],
                        o = t.getValueSize(),
                        l = [],
                        c = [];
                    for (let e = 0; e < t.times.length; ++e) {
                        const s = t.times[e] * r;
                        if (!(s < n || s >= i)) {
                            l.push(t.times[e]);
                            for (let n = 0; n < o; ++n) c.push(t.values[e * o + n])
                        }
                    }
                    0 !== l.length && (t.times = ea.convertArray(l, t.times.constructor), t.values = ea.convertArray(c, t.values.constructor), a.push(t))
                }
                s.tracks = a;
                let o = 1 / 0;
                for (let e = 0; e < s.tracks.length; ++e) o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
                for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
                return s.resetDuration(), s
            },
            makeClipAdditive: function(e, t = 0, n = e, i = 30) {
                i <= 0 && (i = 30);
                const r = n.tracks.length,
                    s = t / i;
                for (let t = 0; t < r; ++t) {
                    const i = n.tracks[t],
                        r = i.ValueTypeName;
                    if ("bool" === r || "string" === r) continue;
                    const a = e.tracks.find((function(e) {
                        return e.name === i.name && e.ValueTypeName === r
                    }));
                    if (void 0 === a) continue;
                    let o = 0;
                    const l = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                    let c = 0;
                    const h = a.getValueSize();
                    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                    const u = i.times.length - 1;
                    let d;
                    if (s <= i.times[0]) {
                        const e = o,
                            t = l - o;
                        d = ea.arraySlice(i.values, e, t)
                    } else if (s >= i.times[u]) {
                        const e = u * l + o,
                            t = e + l - o;
                        d = ea.arraySlice(i.values, e, t)
                    } else {
                        const e = i.createInterpolant(),
                            t = o,
                            n = l - o;
                        e.evaluate(s), d = ea.arraySlice(e.resultBuffer, t, n)
                    }
                    "quaternion" === r && (new Ae).fromArray(d).normalize().conjugate().toArray(d);
                    const p = a.times.length;
                    for (let e = 0; e < p; ++e) {
                        const t = e * h + c;
                        if ("quaternion" === r) Ae.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
                        else {
                            const e = h - 2 * c;
                            for (let n = 0; n < e; ++n) a.values[t + n] -= d[n]
                        }
                    }
                }
                return e.blendMode = 2501, e
            }
        };
        class ta {
            constructor(e, t, n, i) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex,
                    i = t[n],
                    r = t[n - 1];
                e: {
                    t: {
                        let s;n: {
                            i: if (!(e < i)) {
                                for (let s = n + 2;;) {
                                    if (void 0 === i) {
                                        if (e < r) break i;
                                        return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === s) break;
                                    if (r = i, i = t[++n], e < i) break t
                                }
                                s = t.length;
                                break n
                            }if (e >= r) break e; {
                                const a = t[1];
                                e < a && (n = 2, r = a);
                                for (let s = n - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === s) break;
                                    if (i = r, r = t[--n - 1], e >= r) break t
                                }
                                s = n, n = 0
                            }
                        }
                        for (; n < s;) {
                            const i = n + s >>> 1;
                            e < t[i] ? s = i : n = i + 1
                        }
                        if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (void 0 === i) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = e * i;
                for (let e = 0; e !== i; ++e) t[e] = n[r + e];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class na extends ta {
            constructor(e, t, n, i) {
                super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: 2400,
                    endingEnd: 2400
                }
            }
            intervalChanged_(e, t, n) {
                const i = this.parameterPositions;
                let r = e - 2,
                    s = e + 1,
                    a = i[r],
                    o = i[s];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = e, a = 2 * t - n;
                        break;
                    case 2402:
                        r = i.length - 2, a = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e, a = n
                }
                if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        s = e, o = 2 * n - t;
                        break;
                    case 2402:
                        s = 1, o = n + i[1] - i[0];
                        break;
                    default:
                        s = e - 1, o = t
                }
                const l = .5 * (n - t),
                    c = this.valueSize;
                this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = e * a,
                    l = o - a,
                    c = this._offsetPrev,
                    h = this._offsetNext,
                    u = this._weightPrev,
                    d = this._weightNext,
                    p = (n - t) / (i - t),
                    f = p * p,
                    m = f * p,
                    g = -u * m + 2 * u * f - u * p,
                    v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1,
                    x = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                    w = d * m - d * f;
                for (let e = 0; e !== a; ++e) r[e] = g * s[c + e] + v * s[l + e] + x * s[o + e] + w * s[h + e];
                return r
            }
        }
        class ia extends ta {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = e * a,
                    l = o - a,
                    c = (n - t) / (i - t),
                    h = 1 - c;
                for (let e = 0; e !== a; ++e) r[e] = s[l + e] * h + s[o + e] * c;
                return r
            }
        }
        class ra extends ta {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class sa {
            constructor(e, t, n, i) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = ea.convertArray(t, this.TimeBufferType), this.values = ea.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: ea.convertArray(e.times, Array),
                        values: ea.convertArray(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new ra(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new ia(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new na(this.times, this.values, this.getValueSize(), e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                    case T:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case C:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case D:
                        t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t), this
                }
                return this.createInterpolant = t, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return T;
                    case this.InterpolantFactoryMethodLinear:
                        return C;
                    case this.InterpolantFactoryMethodSmooth:
                        return D
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    s = i - 1;
                for (; r !== i && n[r] < e;) ++r;
                for (; - 1 !== s && n[s] > t;) --s;
                if (++s, 0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1), r = s - 1);
                    const e = this.getValueSize();
                    this.times = ea.arraySlice(n, r, s), this.values = ea.arraySlice(this.values, r * e, s * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                let s = null;
                for (let t = 0; t !== r; t++) {
                    const i = n[t];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s), e = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && ea.isTypedArray(i))
                    for (let t = 0, n = i.length; t !== n; ++t) {
                        const n = i[t];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = ea.arraySlice(this.times),
                    t = ea.arraySlice(this.values),
                    n = this.getValueSize(),
                    i = this.getInterpolation() === D,
                    r = e.length - 1;
                let s = 1;
                for (let a = 1; a < r; ++a) {
                    let r = !1;
                    const o = e[a];
                    if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                        if (i) r = !0;
                        else {
                            const e = a * n,
                                i = e - n,
                                s = e + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = t[e + a];
                                if (n !== t[i + a] || n !== t[s + a]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (a !== s) {
                            e[s] = e[a];
                            const i = a * n,
                                r = s * n;
                            for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                        }++s
                    }
                }
                if (r > 0) {
                    e[s] = e[r];
                    for (let e = r * n, i = s * n, a = 0; a !== n; ++a) t[i + a] = t[e + a];
                    ++s
                }
                return s !== e.length ? (this.times = ea.arraySlice(e, 0, s), this.values = ea.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this
            }
            clone() {
                const e = ea.arraySlice(this.times, 0),
                    t = ea.arraySlice(this.values, 0),
                    n = new(0, this.constructor)(this.name, e, t);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        sa.prototype.TimeBufferType = Float32Array, sa.prototype.ValueBufferType = Float32Array, sa.prototype.DefaultInterpolation = C;
        class aa extends sa {}
        aa.prototype.ValueTypeName = "bool", aa.prototype.ValueBufferType = Array, aa.prototype.DefaultInterpolation = T, aa.prototype.InterpolantFactoryMethodLinear = void 0, aa.prototype.InterpolantFactoryMethodSmooth = void 0;
        class oa extends sa {}
        oa.prototype.ValueTypeName = "color";
        class la extends sa {}
        la.prototype.ValueTypeName = "number";
        class ca extends ta {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = (n - t) / (i - t);
                let l = e * a;
                for (let e = l + a; l !== e; l += 4) Ae.slerpFlat(r, 0, s, l - a, s, l, o);
                return r
            }
        }
        class ha extends sa {
            InterpolantFactoryMethodLinear(e) {
                return new ca(this.times, this.values, this.getValueSize(), e)
            }
        }
        ha.prototype.ValueTypeName = "quaternion", ha.prototype.DefaultInterpolation = C, ha.prototype.InterpolantFactoryMethodSmooth = void 0;
        class ua extends sa {}
        ua.prototype.ValueTypeName = "string", ua.prototype.ValueBufferType = Array, ua.prototype.DefaultInterpolation = T, ua.prototype.InterpolantFactoryMethodLinear = void 0, ua.prototype.InterpolantFactoryMethodSmooth = void 0;
        class da extends sa {}
        da.prototype.ValueTypeName = "vector";
        class pa {
            constructor(e, t = -1, n, i = 2500) {
                this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = G(), this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = [],
                    n = e.tracks,
                    i = 1 / (e.fps || 1);
                for (let e = 0, r = n.length; e !== r; ++e) t.push(fa(n[e]).scale(i));
                const r = new this(e.name, e.duration, t, e.blendMode);
                return r.uuid = e.uuid, r
            }
            static toJSON(e) {
                const t = [],
                    n = e.tracks,
                    i = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid,
                        blendMode: e.blendMode
                    };
                for (let e = 0, i = n.length; e !== i; ++e) t.push(sa.toJSON(n[e]));
                return i
            }
            static CreateFromMorphTargetSequence(e, t, n, i) {
                const r = t.length,
                    s = [];
                for (let e = 0; e < r; e++) {
                    let a = [],
                        o = [];
                    a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
                    const l = ea.getKeyframeOrder(a);
                    a = ea.sortedArray(a, 1, l), o = ea.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new la(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / n))
                }
                return new this(e, -1, s)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let e = 0; e < n.length; e++)
                    if (n[e].name === t) return n[e];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const i = {},
                    r = /^([\w-]*?)([\d]+)$/;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t],
                        s = n.name.match(r);
                    if (s && s.length > 1) {
                        const e = s[1];
                        let t = i[e];
                        t || (i[e] = t = []), t.push(n)
                    }
                }
                const s = [];
                for (const e in i) s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                return s
            }
            static parseAnimation(e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function(e, t, n, i, r) {
                        if (0 !== n.length) {
                            const s = [],
                                a = [];
                            ea.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a))
                        }
                    },
                    i = [],
                    r = e.name || "default",
                    s = e.fps || 30,
                    a = e.blendMode;
                let o = e.length || -1;
                const l = e.hierarchy || [];
                for (let e = 0; e < l.length; e++) {
                    const r = l[e].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const e = {};
                            let t;
                            for (t = 0; t < r.length; t++)
                                if (r[t].morphTargets)
                                    for (let n = 0; n < r[t].morphTargets.length; n++) e[r[t].morphTargets[n]] = -1;
                            for (const n in e) {
                                const e = [],
                                    s = [];
                                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                    const i = r[t];
                                    e.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new la(".morphTargetInfluence[" + n + "]", e, s))
                            }
                            o = e.length * s
                        } else {
                            const s = ".bones[" + t[e].name + "]";
                            n(da, s + ".position", r, "pos", i), n(ha, s + ".quaternion", r, "rot", i), n(da, s + ".scale", r, "scl", i)
                        }
                }
                return 0 === i.length ? null : new this(r, o, i, a)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e, this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new this.constructor(this.name, this.duration, e, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function fa(e) {
            if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return la;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return da;
                    case "color":
                        return oa;
                    case "quaternion":
                        return ha;
                    case "bool":
                    case "boolean":
                        return aa;
                    case "string":
                        return ua
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = [],
                    n = [];
                ea.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        }
        const ma = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class ga {
            constructor(e, t, n) {
                const i = this;
                let r, s = !1,
                    a = 0,
                    o = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                    o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), s = !0
                }, this.itemEnd = function(e) {
                    a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(e) {
                    void 0 !== i.onError && i.onError(e)
                }, this.resolveURL = function(e) {
                    return r ? r(e) : e
                }, this.setURLModifier = function(e) {
                    return r = e, this
                }, this.addHandler = function(e, t) {
                    return l.push(e, t), this
                }, this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2), this
                }, this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t],
                            i = l[t + 1];
                        if (n.global && (n.lastIndex = 0), n.test(e)) return i
                    }
                    return null
                }
            }
        }
        const va = new ga;
        class xa {
            constructor(e) {
                this.manager = void 0 !== e ? e : va, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(e, i, t, r)
                }))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e, this
            }
            setWithCredentials(e) {
                return this.withCredentials = e, this
            }
            setPath(e) {
                return this.path = e, this
            }
            setResourcePath(e) {
                return this.resourcePath = e, this
            }
            setRequestHeader(e) {
                return this.requestHeader = e, this
            }
        }
        const wa = {};
        class ba extends xa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = ma.get(e);
                if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                    t && t(r), this.manager.itemEnd(e)
                }), 0), r;
                if (void 0 !== wa[e]) return void wa[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                wa[e] = [], wa[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                const s = new Request(e, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    }),
                    a = this.mimeType,
                    o = this.responseType;
                fetch(s).then((t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                        const n = wa[e],
                            i = t.body.getReader(),
                            r = t.headers.get("Content-Length"),
                            s = r ? parseInt(r) : 0,
                            a = 0 !== s;
                        let o = 0;
                        const l = new ReadableStream({
                            start(e) {
                                ! function t() {
                                    i.read().then((({
                                        done: i,
                                        value: r
                                    }) => {
                                        if (i) e.close();
                                        else {
                                            o += r.byteLength;
                                            const i = new ProgressEvent("progress", {
                                                lengthComputable: a,
                                                loaded: o,
                                                total: s
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(i)
                                            }
                                            e.enqueue(r), t()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
                })).then((e => {
                    switch (o) {
                        case "arraybuffer":
                            return e.arrayBuffer();
                        case "blob":
                            return e.blob();
                        case "document":
                            return e.text().then((e => (new DOMParser).parseFromString(e, a)));
                        case "json":
                            return e.json();
                        default:
                            if (void 0 === a) return e.text(); {
                                const t = /charset="?([^;"\s]*)"?/i.exec(a),
                                    n = t && t[1] ? t[1].toLowerCase() : void 0,
                                    i = new TextDecoder(n);
                                return e.arrayBuffer().then((e => i.decode(e)))
                            }
                    }
                })).then((t => {
                    ma.add(e, t);
                    const n = wa[e];
                    delete wa[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onLoad && i.onLoad(t)
                    }
                })).catch((t => {
                    const n = wa[e];
                    if (void 0 === n) throw this.manager.itemError(e), t;
                    delete wa[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    this.manager.itemError(e)
                })).finally((() => {
                    this.manager.itemEnd(e)
                })), this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e, this
            }
            setMimeType(e) {
                return this.mimeType = e, this
            }
        }
        class _a extends xa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    s = ma.get(e);
                if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
                    t && t(s), r.manager.itemEnd(e)
                }), 0), s;
                const a = ee("img");

                function o() {
                    c(), ma.add(e, this), t && t(this), r.manager.itemEnd(e)
                }

                function l(t) {
                    c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                }

                function c() {
                    a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                }
                return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
            }
        }
        class ya extends xa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this,
                    s = new Cs,
                    a = new ba(this.manager);
                return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, (function(e) {
                    const n = r.parse(e);
                    n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : l, s.wrapT = void 0 !== n.wrapT ? n.wrapT : l, s.magFilter = void 0 !== n.magFilter ? n.magFilter : p, s.minFilter = void 0 !== n.minFilter ? n.minFilter : p, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = f), 1 === n.mipmapCount && (s.minFilter = p), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n))
                }), n, i), s
            }
        }
        class Aa extends xa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new ve,
                    s = new _a(this.manager);
                return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function(e) {
                    r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
                }), n, i), r
            }
        }
        class Ma extends Et {
            constructor(e, t = 1) {
                super(), this.isLight = !0, this.type = "Light", this.color = new ue(e), this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }
        const Sa = new tt,
            Ea = new Me,
            Ta = new Me;
        class Ca {
            constructor(e) {
                this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Z(512, 512), this.map = null, this.mapPass = null, this.matrix = new tt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Fn, this._frameExtents = new Z(1, 1), this._viewportCount = 1, this._viewports = [new xe(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = this.matrix;
                Ea.setFromMatrixPosition(e.matrixWorld), t.position.copy(Ea), Ta.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Ta), t.updateMatrixWorld(), Sa.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Sa), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }
        class Da extends Ca {
            constructor() {
                super(new Tn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = 2 * H * e.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    r = e.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e), this.focus = e.focus, this
            }
        }
        class Pa extends Ma {
            constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
                super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Et.DefaultUp), this.updateMatrix(), this.target = new Et, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Da
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        const Ra = new tt,
            La = new Me,
            Ia = new Me;
        class Ba extends Ca {
            constructor() {
                super(new Tn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Z(4, 2), this._viewportCount = 6, this._viewports = [new xe(2, 1, 1, 1), new xe(0, 1, 1, 1), new xe(3, 1, 1, 1), new xe(1, 1, 1, 1), new xe(3, 0, 1, 1), new xe(1, 0, 1, 1)], this._cubeDirections = [new Me(1, 0, 0), new Me(-1, 0, 0), new Me(0, 0, 1), new Me(0, 0, -1), new Me(0, 1, 0), new Me(0, -1, 0)], this._cubeUps = [new Me(0, 1, 0), new Me(0, 1, 0), new Me(0, 1, 0), new Me(0, 1, 0), new Me(0, 0, 1), new Me(0, 0, -1)]
            }
            updateMatrices(e, t = 0) {
                const n = this.camera,
                    i = this.matrix,
                    r = e.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), La.setFromMatrixPosition(e.matrixWorld), n.position.copy(La), Ia.copy(n.position), Ia.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Ia), n.updateMatrixWorld(), i.makeTranslation(-La.x, -La.y, -La.z), Ra.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ra)
            }
        }
        class Oa extends Ma {
            constructor(e, t, n = 0, i = 1) {
                super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Ba
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }
        class ka extends Ca {
            constructor() {
                super(new Zn(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
            }
        }
        class Na extends Ma {
            constructor(e, t) {
                super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Et.DefaultUp), this.updateMatrix(), this.target = new Et, this.shadow = new ka
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        class Fa {
            static decodeText(e) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                let t = "";
                for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class Ua extends xa {
            constructor(e) {
                super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e, this
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    s = ma.get(e);
                if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
                    t && t(s), r.manager.itemEnd(e)
                }), 0), s;
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then((function(e) {
                    return e.blob()
                })).then((function(e) {
                    return createImageBitmap(e, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function(n) {
                    ma.add(e, n), t && t(n), r.manager.itemEnd(e)
                })).catch((function(t) {
                    i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                })), r.manager.itemStart(e)
            }
        }
        let za;
        const Va = function() {
            return void 0 === za && (za = new(window.AudioContext || window.webkitAudioContext)), za
        };
        class Ha extends xa {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this,
                    s = new ba(this.manager);
                s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
                    try {
                        const e = n.slice(0);
                        Va().decodeAudioData(e, (function(e) {
                            t(e)
                        }))
                    } catch (t) {
                        i ? i(t) : console.error(t), r.manager.itemError(e)
                    }
                }), n, i)
            }
        }
        class Ga {
            constructor(e = !0) {
                this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Wa(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const t = Wa();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        }

        function Wa() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        const ja = new Me,
            Ya = new Ae,
            Xa = new Me,
            Qa = new Me;
        class qa extends Et {
            constructor(e) {
                super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            }
            setMediaElementSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
            }
            setMediaStreamSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
            }
            setBuffer(e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play(e = 0) {
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + e;
                const t = this.context.createBufferSource();
                return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }
            getFilters() {
                return this.filters
            }
            setFilters(e) {
                return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
            }
            setDetune(e) {
                if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(e) {
                return this.setFilters(e ? [e] : [])
            }
            setPlaybackRate(e) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }
            setLoop(e) {
                if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(e) {
                return this.loopStart = e, this
            }
            setLoopEnd(e) {
                return this.loopEnd = e, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
        }
        const Ka = new Me,
            Za = new Ae,
            Ja = new Me,
            $a = new Me;
        class eo extends qa {
            constructor(e) {
                super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }
            disconnect() {
                super.disconnect(), this.panner.disconnect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(e) {
                return this.panner.refDistance = e, this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(e) {
                return this.panner.rolloffFactor = e, this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(e) {
                return this.panner.distanceModel = e, this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(e) {
                return this.panner.maxDistance = e, this
            }
            setDirectionalCone(e, t, n) {
                return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
            }
            updateMatrixWorld(e) {
                if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                this.matrixWorld.decompose(Ka, Za, Ja), $a.set(0, 0, 1).applyQuaternion(Za);
                const t = this.panner;
                if (t.positionX) {
                    const e = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(Ka.x, e), t.positionY.linearRampToValueAtTime(Ka.y, e), t.positionZ.linearRampToValueAtTime(Ka.z, e), t.orientationX.linearRampToValueAtTime($a.x, e), t.orientationY.linearRampToValueAtTime($a.y, e), t.orientationZ.linearRampToValueAtTime($a.z, e)
                } else t.setPosition(Ka.x, Ka.y, Ka.z), t.setOrientation($a.x, $a.y, $a.z)
            }
        }
        const to = new RegExp("[\\[\\]\\.:\\/]", "g"),
            no = "[^\\[\\]\\.:\\/]",
            io = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
            ro = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", no) + /(WCOD+)?/.source.replace("WCOD", io) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", no) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", no) + "$"),
            so = ["material", "materials", "bones"];
        class ao {
            constructor(e, t, n) {
                this.path = t, this.parsedPath = n || ao.parseTrackName(t), this.node = ao.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new ao.Composite(e, t, n) : new ao(e, t, n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(to, "")
            }
            static parseTrackName(e) {
                const t = ro.exec(e);
                if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const e = n.nodeName.substring(i + 1); - 1 !== so.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n) return n
                }
                if (e.children) {
                    const n = function(e) {
                            for (let i = 0; i < e.length; i++) {
                                const r = e[i];
                                if (r.name === t || r.uuid === t) return r;
                                const s = n(r.children);
                                if (s) return s
                            }
                            return null
                        },
                        i = n(e.children);
                    if (i) return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(), this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(), this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath,
                    n = t.objectName,
                    i = t.propertyName;
                let r = t.propertyIndex;
                if (e || (e = ao.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let i = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].name === i) {
                                    i = t;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[i]
                    }
                }
                const s = e[i];
                if (void 0 === s) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                }
                let a = this.Versioning.None;
                this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        ao.Composite = class {
            constructor(e, t, n) {
                const i = n || ao.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, i)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }, ao.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, ao.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, ao.prototype.GetterByBindingType = [ao.prototype._getValue_direct, ao.prototype._getValue_array, ao.prototype._getValue_arrayElement, ao.prototype._getValue_toArray], ao.prototype.SetterByBindingTypeAndVersioning = [
            [ao.prototype._setValue_direct, ao.prototype._setValue_direct_setNeedsUpdate, ao.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [ao.prototype._setValue_array, ao.prototype._setValue_array_setNeedsUpdate, ao.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [ao.prototype._setValue_arrayElement, ao.prototype._setValue_arrayElement_setNeedsUpdate, ao.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [ao.prototype._setValue_fromArray, ao.prototype._setValue_fromArray_setNeedsUpdate, ao.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        class oo {
            constructor(e) {
                "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
            }
            clone() {
                return new oo(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        class lo {
            constructor(e, t, n = 0, i = 1 / 0) {
                this.ray = new et(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new dt, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            intersectObject(e, t = !0, n = []) {
                return ho(e, this, n, t), n.sort(co), n
            }
            intersectObjects(e, t = !0, n = []) {
                for (let i = 0, r = e.length; i < r; i++) ho(e[i], this, n, t);
                return n.sort(co), n
            }
        }

        function co(e, t) {
            return e.distance - t.distance
        }

        function ho(e, t, n, i) {
            if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) {
                const i = e.children;
                for (let e = 0, r = i.length; e < r; e++) ho(i[e], t, n, !0)
            }
        }
        class uo {
            constructor(e = 1, t = 0, n = 0) {
                return this.radius = e, this.phi = t, this.theta = n, this
            }
            set(e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            }
            copy(e) {
                return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
            }
            makeSafe() {
                const e = 1e-6;
                return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(W(t / this.radius, -1, 1))), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const {
            floatView: po,
            uint32View: fo,
            baseTable: mo,
            shiftTable: go,
            mantissaTable: vo,
            exponentTable: xo,
            offsetTable: wo
        } = bo();

        function bo() {
            const e = new ArrayBuffer(4),
                t = new Float32Array(e),
                n = new Uint32Array(e),
                i = new Uint32Array(512),
                r = new Uint32Array(512);
            for (let e = 0; e < 256; ++e) {
                const t = e - 127;
                t < -27 ? (i[e] = 0, i[256 | e] = 32768, r[e] = 24, r[256 | e] = 24) : t < -14 ? (i[e] = 1024 >> -t - 14, i[256 | e] = 1024 >> -t - 14 | 32768, r[e] = -t - 1, r[256 | e] = -t - 1) : t <= 15 ? (i[e] = t + 15 << 10, i[256 | e] = t + 15 << 10 | 32768, r[e] = 13, r[256 | e] = 13) : t < 128 ? (i[e] = 31744, i[256 | e] = 64512, r[e] = 24, r[256 | e] = 24) : (i[e] = 31744, i[256 | e] = 64512, r[e] = 13, r[256 | e] = 13)
            }
            const s = new Uint32Array(2048),
                a = new Uint32Array(64),
                o = new Uint32Array(64);
            for (let e = 1; e < 1024; ++e) {
                let t = e << 13,
                    n = 0;
                for (; 0 == (8388608 & t);) t <<= 1, n -= 8388608;
                t &= -8388609, n += 947912704, s[e] = t | n
            }
            for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);
            for (let e = 1; e < 31; ++e) a[e] = e << 23;
            a[31] = 1199570944, a[32] = 2147483648;
            for (let e = 33; e < 63; ++e) a[e] = 2147483648 + (e - 32 << 23);
            a[63] = 3347054592;
            for (let e = 1; e < 64; ++e) 32 !== e && (o[e] = 1024);
            return {
                floatView: t,
                uint32View: n,
                baseTable: i,
                shiftTable: r,
                mantissaTable: s,
                exponentTable: a,
                offsetTable: o
            }
        }
        var _o = Object.freeze({
            __proto__: null,
            toHalfFloat: function(e) {
                Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = W(e, -65504, 65504), po[0] = e;
                const t = fo[0],
                    n = t >> 23 & 511;
                return mo[n] + ((8388607 & t) >> go[n])
            },
            fromHalfFloat: function(e) {
                const t = e >> 10;
                return fo[0] = vo[wo[t] + (1023 & e)] + xo[t], po[0]
            }
        });
        class yo extends we {
            constructor(e, t, n) {
                console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, n), this.samples = 4
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: t
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = t);
        const Ao = {
                type: "change"
            },
            Mo = {
                type: "start"
            },
            So = {
                type: "end"
            };
        class Eo extends F {
            constructor(e, t) {
                super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new Me, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                }, this.mouseButtons = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                }, this.touches = {
                    ONE: 0,
                    TWO: 2
                }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.mapMode = !1, this.getPolarAngle = function() {
                    return a.phi
                }, this.getAzimuthalAngle = function() {
                    return a.theta
                }, this.getDistance = function() {
                    return this.object.position.distanceTo(this.target)
                }, this.listenToKeyEvents = function(e) {
                    e.addEventListener("keydown", G), this._domElementKeyEvents = e
                }, this.saveState = function() {
                    n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                }, this.reset = function() {
                    n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Ao), n.update(), r = i.NONE
                }, this.update = function() {
                    const t = new Me,
                        u = (new Ae).setFromUnitVectors(e.up, new Me(0, 1, 0)),
                        d = u.clone().invert(),
                        p = new Me,
                        f = new Ae,
                        m = 2 * Math.PI;
                    return function() {
                        const e = n.object.position;
                        t.copy(e).sub(n.target), t.applyQuaternion(u), a.setFromVector3(t), n.autoRotate && r === i.NONE && A(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (a.theta += o.theta * n.dampingFactor, a.phi += o.phi * n.dampingFactor) : (a.theta += o.theta, a.phi += o.phi);
                        let g = n.minAzimuthAngle,
                            v = n.maxAzimuthAngle;
                        return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += m : g > Math.PI && (g -= m), v < -Math.PI ? v += m : v > Math.PI && (v -= m), a.theta = g <= v ? Math.max(g, Math.min(v, a.theta)) : a.theta > (g + v) / 2 ? Math.max(g, a.theta) : Math.min(v, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= l, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), t.setFromSpherical(a), t.applyQuaternion(d), e.copy(n.target).add(t), n.object.lookAt(n.target), !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor, o.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - f.dot(n.object.quaternion)) > s) && (n.dispatchEvent(Ao), p.copy(n.object.position), f.copy(n.object.quaternion), h = !1, !0)
                    }
                }(), this.dispose = function() {
                    n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", F), n.domElement.removeEventListener("pointercancel", V), n.domElement.removeEventListener("wheel", H), n.domElement.removeEventListener("pointermove", U), n.domElement.removeEventListener("pointerup", z), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", G)
                };
                const n = this,
                    i = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    };
                let r = i.NONE;
                const s = 1e-6,
                    a = new uo,
                    o = new uo;
                let l = 1;
                const c = new Me;
                let h = !1;
                const u = new Z,
                    d = new Z,
                    p = new Z,
                    f = new Z,
                    m = new Z,
                    g = new Z,
                    v = new Z,
                    x = new Z,
                    w = new Z,
                    b = [],
                    _ = {};

                function y() {
                    return Math.pow(.95, n.zoomSpeed)
                }

                function A(e) {
                    o.theta -= e
                }

                function M(e) {
                    o.phi -= e
                }
                const S = function() {
                        const e = new Me;
                        return function(t, n) {
                            e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), c.add(e)
                        }
                    }(),
                    E = function() {
                        const e = new Me;
                        return function(t, i) {
                            !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), c.add(e)
                        }
                    }(),
                    T = function() {
                        const e = new Me;
                        return function(t, i) {
                            const r = n.domElement;
                            if (n.object.isPerspectiveCamera) {
                                const s = n.object.position;
                                e.copy(s).sub(n.target);
                                let a = e.length();
                                a *= Math.tan(n.object.fov / 2 * Math.PI / 180), S(2 * t * a / r.clientHeight, n.object.matrix), E(2 * i * a / r.clientHeight, n.object.matrix)
                            } else n.object.isOrthographicCamera ? (S(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), E(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                        }
                    }();

                function C(e) {
                    n.object.isPerspectiveCamera ? l /= e : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * e)), n.object.updateProjectionMatrix(), h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                }

                function D(e) {
                    n.object.isPerspectiveCamera ? l *= e : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / e)), n.object.updateProjectionMatrix(), h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                }

                function P(e) {
                    u.set(e.clientX, e.clientY), 0 == n.mapMode && f.set(e.clientX, e.clientY)
                }

                function R(e) {
                    f.set(e.clientX, e.clientY), 0 == n.mapMode && u.set(e.clientX, e.clientY)
                }

                function L() {
                    if (1 === b.length) u.set(b[0].pageX, b[0].pageY);
                    else {
                        const e = .5 * (b[0].pageX + b[1].pageX),
                            t = .5 * (b[0].pageY + b[1].pageY);
                        u.set(e, t)
                    }
                }

                function I() {
                    if (1 === b.length) 0 == n.mapMode && u.set(b[0].pageX, b[0].pageY), f.set(b[0].pageX, b[0].pageY);
                    else {
                        const e = .5 * (b[0].pageX + b[1].pageX),
                            t = .5 * (b[0].pageY + b[1].pageY);
                        f.set(e, t)
                    }
                }

                function B() {
                    const e = b[0].pageX - b[1].pageX,
                        t = b[0].pageY - b[1].pageY,
                        n = Math.sqrt(e * e + t * t);
                    v.set(0, n)
                }

                function O(e) {
                    if (1 == b.length) d.set(e.pageX, e.pageY);
                    else {
                        const t = X(e),
                            n = .5 * (e.pageX + t.x),
                            i = .5 * (e.pageY + t.y);
                        d.set(n, i)
                    }
                    p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
                    const t = n.domElement;
                    A(2 * Math.PI * p.x / t.clientHeight), M(2 * Math.PI * p.y / t.clientHeight), u.copy(d)
                }

                function k(e) {
                    if (1 === b.length) m.set(e.pageX, e.pageY), 0 == n.mapMode && d.set(e.pageX, e.pageY);
                    else {
                        const t = X(e),
                            n = .5 * (e.pageX + t.x),
                            i = .5 * (e.pageY + t.y);
                        m.set(n, i)
                    }
                    p.subVectors(u, d).multiplyScalar(n.rotateSpeed);
                    const t = n.domElement;
                    g.subVectors(m, f).multiplyScalar(n.panSpeed), A(2 * Math.PI / 4 * p.x / t.clientHeight), T(g.x, g.y), u.copy(d), f.copy(m)
                }

                function N(e) {
                    const t = X(e),
                        i = e.pageX - t.x,
                        r = e.pageY - t.y,
                        s = Math.sqrt(i * i + r * r);
                    x.set(0, s), w.set(0, Math.pow(x.y / v.y, n.zoomSpeed)), C(w.y), v.copy(x)
                }

                function F(e) {
                    !1 !== n.enabled && (0 === b.length && (n.domElement.setPointerCapture(e.pointerId), n.domElement.addEventListener("pointermove", U), n.domElement.addEventListener("pointerup", z)), function(e) {
                        b.push(e)
                    }(e), "touch" === e.pointerType ? function(e) {
                        switch (Y(e), b.length) {
                            case 1:
                                switch (n.touches.ONE) {
                                    case 0:
                                        if (!1 === n.enableRotate) return;
                                        L(), r = i.TOUCH_ROTATE;
                                        break;
                                    case 1:
                                        if (!1 === n.enablePan) return;
                                        I(), r = i.TOUCH_PAN;
                                        break;
                                    default:
                                        r = i.NONE
                                }
                                break;
                            case 2:
                                switch (n.touches.TWO) {
                                    case 2:
                                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                        n.enableZoom && B(), n.enablePan && I(), r = i.TOUCH_DOLLY_PAN;
                                        break;
                                    case 3:
                                        if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                        n.enableZoom && B(), n.enableRotate && L(), r = i.TOUCH_DOLLY_ROTATE;
                                        break;
                                    default:
                                        r = i.NONE
                                }
                                break;
                            default:
                                r = i.NONE
                        }
                        r !== i.NONE && n.dispatchEvent(Mo)
                    }(e) : function(e) {
                        let t;
                        switch (e.button) {
                            case 0:
                                t = n.mouseButtons.LEFT;
                                break;
                            case 1:
                                t = n.mouseButtons.MIDDLE;
                                break;
                            case 2:
                                t = n.mouseButtons.RIGHT;
                                break;
                            default:
                                t = -1
                        }
                        switch (t) {
                            case 1:
                                if (!1 === n.enableZoom) return;
                                ! function(e) {
                                    v.set(e.clientX, e.clientY)
                                }(e), r = i.DOLLY;
                                break;
                            case 0:
                                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                    if (!1 === n.enablePan) return;
                                    R(e), r = i.PAN
                                } else {
                                    if (!1 === n.enableRotate) return;
                                    P(e), r = i.ROTATE
                                }
                                break;
                            case 2:
                                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                    if (!1 === n.enableRotate) return;
                                    P(e), r = i.ROTATE
                                } else {
                                    if (!1 === n.enablePan) return;
                                    R(e), r = i.PAN
                                }
                                break;
                            default:
                                r = i.NONE
                        }
                        r !== i.NONE && n.dispatchEvent(Mo)
                    }(e))
                }

                function U(e) {
                    !1 !== n.enabled && ("touch" === e.pointerType ? function(e) {
                        switch (Y(e), r) {
                            case i.TOUCH_ROTATE:
                                if (!1 === n.enableRotate) return;
                                O(e), n.update();
                                break;
                            case i.TOUCH_PAN:
                                if (!1 === n.enablePan) return;
                                k(e), n.update();
                                break;
                            case i.TOUCH_DOLLY_PAN:
                                if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                ! function(e) {
                                    n.enableZoom && N(e), n.enablePan && k(e)
                                }(e), n.update();
                                break;
                            case i.TOUCH_DOLLY_ROTATE:
                                if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                ! function(e) {
                                    n.enableZoom && N(e), n.enableRotate && O(e)
                                }(e), n.update();
                                break;
                            default:
                                r = i.NONE
                        }
                    }(e) : function(e) {
                        if (!1 !== n.enabled) switch (r) {
                            case i.ROTATE:
                                if (!1 === n.enableRotate) return;
                                ! function(e) {
                                    d.set(e.clientX, e.clientY), p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
                                    const t = n.domElement;
                                    A(2 * Math.PI * p.x / t.clientHeight), M(2 * Math.PI * p.y / t.clientHeight), u.copy(d), n.update()
                                }(e);
                                break;
                            case i.DOLLY:
                                if (!1 === n.enableZoom) return;
                                ! function(e) {
                                    x.set(e.clientX, e.clientY), w.subVectors(x, v), w.y > 0 ? C(y()) : w.y < 0 && D(y()), v.copy(x), n.update()
                                }(e);
                                break;
                            case i.PAN:
                                if (!1 === n.enablePan) return;
                                ! function(e) {
                                    const t = n.domElement;
                                    m.set(e.clientX, e.clientY), 0 == n.mapMode && d.set(e.clientX, e.clientY), g.subVectors(m, f).multiplyScalar(n.panSpeed), 0 == n.mapMode && p.subVectors(d, u).multiplyScalar(n.rotateSpeed), 0 == n.mapMode && A(-4 / Math.PI * p.x / t.clientHeight), T(g.x, g.y), 0 == n.mapMode && u.copy(d), f.copy(m), n.update()
                                }(e)
                        }
                    }(e))
                }

                function z(e) {
                    !1 !== n.enabled && (e.pointerType, n.dispatchEvent(So), r = i.NONE, j(e), 0 === b.length && (n.domElement.releasePointerCapture(e.pointerId), n.domElement.removeEventListener("pointermove", U), n.domElement.removeEventListener("pointerup", z)))
                }

                function V(e) {
                    j(e)
                }

                function H(e) {
                    !1 === n.enabled || !1 === n.enableZoom || r !== i.NONE && r !== i.ROTATE || (e.preventDefault(), n.dispatchEvent(Mo), function(e) {
                        e.deltaY < 0 ? D(y()) : e.deltaY > 0 && C(y()), n.update()
                    }(e), n.dispatchEvent(So))
                }

                function G(e) {
                    !1 !== n.enabled && !1 !== n.enablePan && function(e) {
                        let t = !1;
                        switch (e.code) {
                            case n.keys.UP:
                                T(0, n.keyPanSpeed), t = !0;
                                break;
                            case n.keys.BOTTOM:
                                T(0, -n.keyPanSpeed), t = !0;
                                break;
                            case n.keys.LEFT:
                                T(n.keyPanSpeed, 0), t = !0;
                                break;
                            case n.keys.RIGHT:
                                T(-n.keyPanSpeed, 0), t = !0
                        }
                        t && (e.preventDefault(), n.update())
                    }(e)
                }

                function W(e) {
                    !1 !== n.enabled && e.preventDefault()
                }

                function j(e) {
                    delete _[e.pointerId];
                    for (let t = 0; t < b.length; t++)
                        if (b[t].pointerId == e.pointerId) return void b.splice(t, 1)
                }

                function Y(e) {
                    let t = _[e.pointerId];
                    void 0 === t && (t = new Z, _[e.pointerId] = t), t.set(e.pageX, e.pageY)
                }

                function X(e) {
                    const t = e.pointerId === b[0].pointerId ? b[1] : b[0];
                    return _[t.pointerId]
                }
                n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", F), n.domElement.addEventListener("pointercancel", V), n.domElement.addEventListener("wheel", H, {
                    passive: !1
                }), this.update()
            }
        }
        class To extends xa {
            constructor(e) {
                super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                    return new Io(e)
                })), this.register((function(e) {
                    return new zo(e)
                })), this.register((function(e) {
                    return new Vo(e)
                })), this.register((function(e) {
                    return new Oo(e)
                })), this.register((function(e) {
                    return new ko(e)
                })), this.register((function(e) {
                    return new No(e)
                })), this.register((function(e) {
                    return new Fo(e)
                })), this.register((function(e) {
                    return new Lo(e)
                })), this.register((function(e) {
                    return new Uo(e)
                })), this.register((function(e) {
                    return new Bo(e)
                })), this.register((function(e) {
                    return new Po(e)
                })), this.register((function(e) {
                    return new Ho(e)
                }))
            }
            load(e, t, n, i) {
                const r = this;
                let s;
                s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Fa.extractUrlBase(e), this.manager.itemStart(e);
                const a = function(t) {
                        i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    },
                    o = new ba(this.manager);
                o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                    try {
                        r.parse(n, s, (function(n) {
                            t(n), r.manager.itemEnd(e)
                        }), a)
                    } catch (e) {
                        a(e)
                    }
                }), n, a)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e, this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e, this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            parse(e, t, n, i) {
                let r;
                const s = {},
                    a = {};
                if ("string" == typeof e) r = e;
                else if (Fa.decodeText(new Uint8Array(e, 0, 4)) === Go) {
                    try {
                        s[Do.KHR_BINARY_GLTF] = new Wo(e)
                    } catch (e) {
                        return void(i && i(e))
                    }
                    r = s[Do.KHR_BINARY_GLTF].content
                } else r = Fa.decodeText(new Uint8Array(e));
                const o = JSON.parse(r);
                if (void 0 === o.asset || o.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new dl(o, {
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let e = 0; e < this.pluginCallbacks.length; e++) {
                    const t = this.pluginCallbacks[e](l);
                    a[t.name] = t, s[t.name] = !0
                }
                if (o.extensionsUsed)
                    for (let e = 0; e < o.extensionsUsed.length; ++e) {
                        const t = o.extensionsUsed[e],
                            n = o.extensionsRequired || [];
                        switch (t) {
                            case Do.KHR_MATERIALS_UNLIT:
                                s[t] = new Ro;
                                break;
                            case Do.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                s[t] = new Qo;
                                break;
                            case Do.KHR_DRACO_MESH_COMPRESSION:
                                s[t] = new jo(o, this.dracoLoader);
                                break;
                            case Do.KHR_TEXTURE_TRANSFORM:
                                s[t] = new Yo;
                                break;
                            case Do.KHR_MESH_QUANTIZATION:
                                s[t] = new qo;
                                break;
                            default:
                                n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                        }
                    }
                l.setExtensions(s), l.setPlugins(a), l.parse(n, i)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(e, t, i, r)
                }))
            }
        }

        function Co() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const Do = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        };
        class Po {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser,
                    t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser,
                    n = "light:" + e;
                let i = t.cache.get(n);
                if (i) return i;
                const r = t.json,
                    s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                let a;
                const o = new ue(16777215);
                void 0 !== s.color && o.fromArray(s.color);
                const l = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                    case "directional":
                        a = new Na(o), a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    case "point":
                        a = new Oa(o), a.distance = l;
                        break;
                    case "spot":
                        a = new Pa(o), a.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                }
                return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(a), t.cache.add(n, i), i
            }
            createNodeAttachment(e) {
                const t = this,
                    n = this.parser,
                    i = n.json.nodes[e],
                    r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(e) {
                    return n._getNodeRef(t.cache, r, e)
                }))
            }
        }
        class Ro {
            constructor() {
                this.name = Do.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return zt
            }
            extendParams(e, t, n) {
                const i = [];
                e.color = new ue(1, 1, 1), e.opacity = 1;
                const r = t.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const t = r.baseColorFactor;
                        e.color.fromArray(t), e.opacity = t[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, R))
                }
                return Promise.all(i)
            }
        }
        class Lo {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve()
            }
        }
        class Io {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                    const e = s.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new Z(e, e)
                }
                return Promise.all(r)
            }
        }
        class Bo {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(r)
            }
        }
        class Oo {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [];
                t.sheenColor = new ue(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                const s = i.extensions[this.name];
                return void 0 !== s.sheenColorFactor && t.sheenColor.fromArray(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, R)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r)
            }
        }
        class ko {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r)
            }
        }
        class No {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 0;
                const a = s.attenuationColor || [1, 1, 1];
                return t.attenuationColor = new ue(a[0], a[1], a[2]), Promise.all(r)
            }
        }
        class Fo {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name];
                return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
            }
        }
        class Uo {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? $s : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
                const a = s.specularColorFactor || [1, 1, 1];
                return t.specularColor = new ue(a[0], a[1], a[2]), void 0 !== s.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, R)), Promise.all(r)
            }
        }
        class zo {
            constructor(e) {
                this.parser = e, this.name = Do.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser,
                    n = t.json,
                    i = n.textures[e];
                if (!i.extensions || !i.extensions[this.name]) return null;
                const r = i.extensions[this.name],
                    s = t.options.ktx2Loader;
                if (!s) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, r.source, s)
            }
        }
        class Vo {
            constructor(e) {
                this.parser = e, this.name = Do.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[e];
                if (!r.extensions || !r.extensions[t]) return null;
                const s = r.extensions[t],
                    a = i.images[s.source];
                let o = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r) return n.loadTextureImage(e, s.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class Ho {
            constructor(e) {
                this.name = Do.EXT_MESHOPT_COMPRESSION, this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json,
                    n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name],
                        i = this.parser.getDependency("buffer", e.buffer),
                        r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return Promise.all([i, r.ready]).then((function(t) {
                        const n = e.byteOffset || 0,
                            i = e.byteLength || 0,
                            s = e.count,
                            a = e.byteStride,
                            o = new ArrayBuffer(s * a),
                            l = new Uint8Array(t[0], n, i);
                        return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o
                    }))
                }
                return null
            }
        }
        const Go = "glTF";
        class Wo {
            constructor(e) {
                this.name = Do.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const t = new DataView(e, 0, 12);
                if (this.header = {
                        magic: Fa.decodeText(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== Go) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - 12,
                    i = new DataView(e, 12);
                let r = 0;
                for (; r < n;) {
                    const t = i.getUint32(r, !0);
                    r += 4;
                    const n = i.getUint32(r, !0);
                    if (r += 4, 1313821514 === n) {
                        const n = new Uint8Array(e, 12 + r, t);
                        this.content = Fa.decodeText(n)
                    } else if (5130562 === n) {
                        const n = 12 + r;
                        this.body = e.slice(n, n + t)
                    }
                    r += t
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class jo {
            constructor(e, t) {
                if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = Do.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json,
                    i = this.dracoLoader,
                    r = e.extensions[this.name].bufferView,
                    s = e.extensions[this.name].attributes,
                    a = {},
                    o = {},
                    l = {};
                for (const e in s) {
                    const t = il[e] || e.toLowerCase();
                    a[t] = s[e]
                }
                for (const t in e.attributes) {
                    const i = il[t] || t.toLowerCase();
                    if (void 0 !== s[t]) {
                        const r = n.accessors[e.attributes[t]],
                            s = $o[r.componentType];
                        l[i] = s, o[i] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", r).then((function(e) {
                    return new Promise((function(t) {
                        i.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t],
                                    i = o[t];
                                void 0 !== i && (n.normalized = i)
                            }
                            t(e)
                        }), a, l)
                    }))
                }))
            }
        }
        class Yo {
            constructor() {
                this.name = Do.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
            }
        }
        class Xo extends Js {
            constructor(e) {
                super(), this.isGLTFSpecularGlossinessMaterial = !0;
                const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                    n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                    i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                    r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                    s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                    a = {
                        specular: {
                            value: (new ue).setHex(16777215)
                        },
                        glossiness: {
                            value: 1
                        },
                        specularMap: {
                            value: null
                        },
                        glossinessMap: {
                            value: null
                        }
                    };
                this._extraUniforms = a, this.onBeforeCompile = function(e) {
                    for (const t in a) e.uniforms[t] = a[t];
                    e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
                }, Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return a.specular.value
                        },
                        set: function(e) {
                            a.specular.value = e
                        }
                    },
                    specularMap: {
                        get: function() {
                            return a.specularMap.value
                        },
                        set: function(e) {
                            a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function() {
                            return a.glossiness.value
                        },
                        set: function(e) {
                            a.glossiness.value = e
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return a.glossinessMap.value
                        },
                        set: function(e) {
                            a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                        }
                    }
                }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
            }
        }
        class Qo {
            constructor() {
                this.name = Do.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
            }
            getMaterialType() {
                return Xo
            }
            extendParams(e, t, n) {
                const i = t.extensions[this.name];
                e.color = new ue(1, 1, 1), e.opacity = 1;
                const r = [];
                if (Array.isArray(i.diffuseFactor)) {
                    const t = i.diffuseFactor;
                    e.color.fromArray(t), e.opacity = t[3]
                }
                if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture, R)), e.emissive = new ue(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new ue(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                    const t = i.specularGlossinessTexture;
                    r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t, R))
                }
                return Promise.all(r)
            }
            createMaterial(e) {
                const t = new Xo(e);
                return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t
            }
        }
        class qo {
            constructor() {
                this.name = Do.KHR_MESH_QUANTIZATION
            }
        }
        class Ko extends ta {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = e * i * 3 + i;
                for (let e = 0; e !== i; e++) t[e] = n[r + e];
                return t
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = 2 * a,
                    l = 3 * a,
                    c = i - t,
                    h = (n - t) / c,
                    u = h * h,
                    d = u * h,
                    p = e * l,
                    f = p - l,
                    m = -2 * d + 3 * u,
                    g = d - u,
                    v = 1 - m,
                    x = g - u + h;
                for (let e = 0; e !== a; e++) {
                    const t = s[f + e + a],
                        n = s[f + e + o] * c,
                        i = s[p + e + a],
                        l = s[p + e] * c;
                    r[e] = v * t + x * n + m * i + g * l
                }
                return r
            }
        }
        const Zo = new Ae;
        class Jo extends Ko {
            interpolate_(e, t, n, i) {
                const r = super.interpolate_(e, t, n, i);
                return Zo.fromArray(r).normalize().toArray(r), r
            }
        }
        const $o = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            el = {
                9728: h,
                9729: p,
                9984: u,
                9985: 1007,
                9986: d,
                9987: f
            },
            tl = {
                33071: l,
                33648: c,
                10497: o
            },
            nl = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            il = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            rl = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            sl = {
                CUBICSPLINE: void 0,
                LINEAR: C,
                STEP: T
            };

        function al(e, t, n) {
            for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
        }

        function ol(e, t) {
            void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }

        function ll(e, t) {
            if (e.updateMorphTargets(), void 0 !== t.weights)
                for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function cl(e) {
            const t = e.extensions && e.extensions[Do.KHR_DRACO_MESH_COMPRESSION];
            let n;
            return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + hl(t.attributes) : e.indices + ":" + hl(e.attributes) + ":" + e.mode, n
        }

        function hl(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
            return t
        }

        function ul(e) {
            switch (e) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        class dl {
            constructor(e = {}, t = {}) {
                this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Co, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                    i = navigator.userAgent.indexOf("Firefox") > -1,
                    r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
                "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new Aa(this.options.manager) : this.textureLoader = new Ua(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ba(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this,
                    i = this.json,
                    r = this.extensions;
                this.cache.removeAll(), this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                })), Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function(t) {
                    const s = {
                        scene: t[0][i.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    al(r, s, i), ol(s, i), Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(s)
                    }))).then((function() {
                        e(s)
                    }))
                })).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || [],
                    t = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n].joints;
                    for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0
                }
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1) return n;
                const i = n.clone(),
                    r = (e, t) => {
                        const n = this.associations.get(e);
                        null != n && this.associations.set(t, n);
                        for (const [n, i] of e.children.entries()) r(i, t.children[n])
                    };
                return r(n, i), i.name += "_instance_" + e.uses[t]++, i
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = e(t[n]);
                    if (i) return i
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (e) {
                        case "scene":
                            i = this.loadScene(t);
                            break;
                        case "node":
                            i = this.loadNode(t);
                            break;
                        case "mesh":
                            i = this._invokeOne((function(e) {
                                return e.loadMesh && e.loadMesh(t)
                            }));
                            break;
                        case "accessor":
                            i = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            i = this._invokeOne((function(e) {
                                return e.loadBufferView && e.loadBufferView(t)
                            }));
                            break;
                        case "buffer":
                            i = this.loadBuffer(t);
                            break;
                        case "material":
                            i = this._invokeOne((function(e) {
                                return e.loadMaterial && e.loadMaterial(t)
                            }));
                            break;
                        case "texture":
                            i = this._invokeOne((function(e) {
                                return e.loadTexture && e.loadTexture(t)
                            }));
                            break;
                        case "skin":
                            i = this.loadSkin(t);
                            break;
                        case "animation":
                            i = this._invokeOne((function(e) {
                                return e.loadAnimation && e.loadAnimation(t)
                            }));
                            break;
                        case "camera":
                            i = this.loadCamera(t);
                            break;
                        default:
                            throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this,
                        i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(i.map((function(t, i) {
                        return n.getDependency(e, i)
                    }))), this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e],
                    n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Do.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function(e, r) {
                    n.load(Fa.resolveURL(t.uri, i.path), e, void 0, (function() {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }))
                }))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0,
                        i = t.byteOffset || 0;
                    return e.slice(i, i + n)
                }))
            }
            loadAccessor(e) {
                const t = this,
                    n = this.json,
                    i = this.json.accessors[e];
                if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(e) {
                    const r = e[0],
                        s = nl[i.type],
                        a = $o[i.componentType],
                        o = a.BYTES_PER_ELEMENT,
                        l = o * s,
                        c = i.byteOffset || 0,
                        h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                        u = !0 === i.normalized;
                    let d, p;
                    if (h && h !== l) {
                        const e = Math.floor(c / h),
                            n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                        let l = t.cache.get(n);
                        l || (d = new a(r, e * h, i.count * h / o), l = new xs(d, h / o), t.cache.add(n, l)), p = new bs(l, s, c % h / o, u)
                    } else d = null === r ? new a(i.count * s) : new a(r, c, i.count * s), p = new Gt(d, s, u);
                    if (void 0 !== i.sparse) {
                        const t = nl.SCALAR,
                            n = $o[i.sparse.indices.componentType],
                            o = i.sparse.indices.byteOffset || 0,
                            l = i.sparse.values.byteOffset || 0,
                            c = new n(e[1], o, i.sparse.count * t),
                            h = new a(e[2], l, i.sparse.count * s);
                        null !== r && (p = new Gt(p.array.slice(), p.itemSize, p.normalized));
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            if (p.setX(t, h[e * s]), s >= 2 && p.setY(t, h[e * s + 1]), s >= 3 && p.setZ(t, h[e * s + 2]), s >= 4 && p.setW(t, h[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }))
            }
            loadTexture(e) {
                const t = this.json,
                    n = this.options,
                    i = t.textures[e].source,
                    r = t.images[i];
                let s = this.textureLoader;
                if (r.uri) {
                    const e = n.manager.getHandler(r.uri);
                    null !== e && (s = e)
                }
                return this.loadTextureImage(e, i, s)
            }
            loadTextureImage(e, t, n) {
                const i = this,
                    r = this.json,
                    s = r.textures[e],
                    a = r.images[t],
                    l = (a.uri || a.bufferView) + ":" + s.sampler;
                if (this.textureCache[l]) return this.textureCache[l];
                const c = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1, s.name && (t.name = s.name);
                    const n = (r.samplers || {})[s.sampler] || {};
                    return t.magFilter = el[n.magFilter] || p, t.minFilter = el[n.minFilter] || f, t.wrapS = tl[n.wrapS] || o, t.wrapT = tl[n.wrapT] || o, i.associations.set(t, {
                        textures: e
                    }), t
                })).catch((function() {
                    return null
                }));
                return this.textureCache[l] = c, c
            }
            loadImageSource(e, t) {
                const n = this.json,
                    i = this.options;
                if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
                const r = n.images[e],
                    s = self.URL || self.webkitURL;
                let a = r.uri || "",
                    o = !1;
                if (void 0 !== r.bufferView) a = this.getDependency("bufferView", r.bufferView).then((function(e) {
                    o = !0;
                    const t = new Blob([e], {
                        type: r.mimeType
                    });
                    return a = s.createObjectURL(t), a
                }));
                else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const l = Promise.resolve(a).then((function(e) {
                    return new Promise((function(n, r) {
                        let s = n;
                        !0 === t.isImageBitmapLoader && (s = function(e) {
                            const t = new ve(e);
                            t.needsUpdate = !0, n(t)
                        }), t.load(Fa.resolveURL(e, i.path), s, void 0, r)
                    }))
                })).then((function(e) {
                    var t;
                    return !0 === o && s.revokeObjectURL(a), e.userData.mimeType = r.mimeType || ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                })).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e
                }));
                return this.sourceCache[e] = l, l
            }
            assignTexture(e, t, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(s) {
                    if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), r.extensions[Do.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[Do.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = r.associations.get(s);
                            s = r.extensions[Do.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), r.associations.set(s, t)
                        }
                    }
                    return void 0 !== i && (s.encoding = i), e[t] = s, s
                }))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const i = void 0 === t.attributes.tangent,
                    r = void 0 !== t.attributes.color,
                    s = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new Gs, Ut.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new Ls, Ut.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t
                }
                if (i || r || s) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                }
                n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
            }
            getMaterialType() {
                return Js
            }
            loadMaterial(e) {
                const t = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.materials[e];
                let s;
                const a = {},
                    o = r.extensions || {},
                    l = [];
                if (o[Do.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    const e = i[Do.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    s = e.getMaterialType(), l.push(e.extendParams(a, r, t))
                } else if (o[Do.KHR_MATERIALS_UNLIT]) {
                    const e = i[Do.KHR_MATERIALS_UNLIT];
                    s = e.getMaterialType(), l.push(e.extendParams(a, r, t))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (a.color = new ue(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        a.color.fromArray(e), a.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && l.push(t.assignTexture(a, "map", n.baseColorTexture, R)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    })), l.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, a)
                    }))))
                }!0 === r.doubleSided && (a.side = 2);
                const c = r.alphaMode || "OPAQUE";
                if ("BLEND" === c ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === c && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== zt && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new Z(1, 1), void 0 !== r.normalTexture.scale)) {
                    const e = r.normalTexture.scale;
                    a.normalScale.set(e, e)
                }
                return void 0 !== r.occlusionTexture && s !== zt && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== zt && (a.emissive = (new ue).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== zt && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, R)), Promise.all(l).then((function() {
                    let n;
                    return n = s === Xo ? i[Do.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a), r.name && (n.name = r.name), ol(n, r), t.associations.set(n, {
                        materials: e
                    }), r.extensions && al(i, n, r), n
                }))
            }
            createUniqueName(e) {
                const t = ao.sanitizeNodeName(e || "");
                let n = t;
                for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
                return this.nodeNamesUsed[n] = !0, n
            }
            loadGeometries(e) {
                const t = this,
                    n = this.extensions,
                    i = this.primitiveCache;

                function r(e) {
                    return n[Do.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return fl(n, e, t)
                    }))
                }
                const s = [];
                for (let n = 0, a = e.length; n < a; n++) {
                    const a = e[n],
                        o = cl(a),
                        l = i[o];
                    if (l) s.push(l.promise);
                    else {
                        let e;
                        e = a.extensions && a.extensions[Do.KHR_DRACO_MESH_COMPRESSION] ? r(a) : fl(new en, a, t), i[o] = {
                            primitive: a,
                            promise: e
                        }, s.push(e)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(e) {
                const t = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.meshes[e],
                    s = r.primitives,
                    a = [];
                for (let e = 0, t = s.length; e < t; e++) {
                    const t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new Js({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0
                    })), o.DefaultMaterial) : this.getDependency("material", s[e].material);
                    a.push(t)
                }
                var o;
                return a.push(t.loadGeometries(s)), Promise.all(a).then((function(n) {
                    const a = n.slice(0, n.length - 1),
                        o = n[n.length - 1],
                        l = [];
                    for (let n = 0, c = o.length; n < c; n++) {
                        const c = o[n],
                            h = s[n];
                        let u;
                        const d = a[n];
                        if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode) u = !0 === r.isSkinnedMesh ? new Es(c, d) : new wn(c, d), !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), 5 === h.mode ? u.geometry = ml(u.geometry, 1) : 6 === h.mode && (u.geometry = ml(u.geometry, 2));
                        else if (1 === h.mode) u = new Vs(c, d);
                        else if (3 === h.mode) u = new Fs(c, d);
                        else if (2 === h.mode) u = new Hs(c, d);
                        else {
                            if (0 !== h.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                            u = new Qs(c, d)
                        }
                        Object.keys(u.geometry.morphAttributes).length > 0 && ll(u, r), u.name = t.createUniqueName(r.name || "mesh_" + e), ol(u, r), h.extensions && al(i, u, h), t.assignFinalMaterial(u), l.push(u)
                    }
                    for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {
                        meshes: e,
                        primitives: n
                    });
                    if (1 === l.length) return l[0];
                    const c = new hs;
                    t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                    return c
                }))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e],
                    i = n[n.type];
                if (i) return "perspective" === n.type ? t = new Tn(K.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new Zn(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), ol(t, n), Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e],
                    n = {
                        joints: t.joints
                    };
                return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                    return n.inverseBindMatrices = e, n
                }))
            }
            loadAnimation(e) {
                const t = this.json.animations[e],
                    n = [],
                    i = [],
                    r = [],
                    s = [],
                    a = [];
                for (let e = 0, o = t.channels.length; e < o; e++) {
                    const o = t.channels[e],
                        l = t.samplers[o.sampler],
                        c = o.target,
                        h = void 0 !== c.node ? c.node : c.id,
                        u = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
                        d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                    n.push(this.getDependency("node", h)), i.push(this.getDependency("accessor", u)), r.push(this.getDependency("accessor", d)), s.push(l), a.push(c)
                }
                return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a)]).then((function(n) {
                    const i = n[0],
                        r = n[1],
                        s = n[2],
                        a = n[3],
                        o = n[4],
                        l = [];
                    for (let e = 0, t = i.length; e < t; e++) {
                        const t = i[e],
                            n = r[e],
                            c = s[e],
                            h = a[e],
                            u = o[e];
                        if (void 0 === t) continue;
                        let d;
                        switch (t.updateMatrix(), t.matrixAutoUpdate = !0, rl[u.path]) {
                            case rl.weights:
                                d = la;
                                break;
                            case rl.rotation:
                                d = ha;
                                break;
                            default:
                                d = da
                        }
                        const p = t.name ? t.name : t.uuid,
                            f = void 0 !== h.interpolation ? sl[h.interpolation] : C,
                            m = [];
                        rl[u.path] === rl.weights ? t.traverse((function(e) {
                            e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
                        })) : m.push(p);
                        let g = c.array;
                        if (c.normalized) {
                            const e = ul(g.constructor),
                                t = new Float32Array(g.length);
                            for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
                            g = t
                        }
                        for (let e = 0, t = m.length; e < t; e++) {
                            const t = new d(m[e] + "." + rl[u.path], n.array, g, f);
                            "CUBICSPLINE" === h.interpolation && (t.createInterpolant = function(e) {
                                return new(this instanceof ha ? Jo : Ko)(this.times, this.values, this.getValueSize() / 3, e)
                            }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t)
                        }
                    }
                    const c = t.name ? t.name : "animation_" + e;
                    return new pa(c, void 0, l)
                }))
            }
            createNodeMesh(e) {
                const t = this.json,
                    n = this,
                    i = t.nodes[e];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, i.mesh, e);
                    return void 0 !== i.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                    })), t
                }))
            }
            loadNode(e) {
                const t = this.json,
                    n = this.extensions,
                    i = this,
                    r = t.nodes[e],
                    s = r.name ? i.createUniqueName(r.name) : "";
                return function() {
                    const t = [],
                        n = i._invokeOne((function(t) {
                            return t.createNodeMesh && t.createNodeMesh(e)
                        }));
                    return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function(e) {
                        return i._getNodeRef(i.cameraCache, r.camera, e)
                    }))), i._invokeAll((function(t) {
                        return t.createNodeAttachment && t.createNodeAttachment(e)
                    })).forEach((function(e) {
                        t.push(e)
                    })), Promise.all(t)
                }().then((function(t) {
                    let a;
                    if (a = !0 === r.isBone ? new Ts : t.length > 1 ? new hs : 1 === t.length ? t[0] : new Et, a !== t[0])
                        for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
                    if (r.name && (a.userData.name = r.name, a.name = s), ol(a, r), r.extensions && al(n, a, r), void 0 !== r.matrix) {
                        const e = new tt;
                        e.fromArray(r.matrix), a.applyMatrix4(e)
                    } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
                    return i.associations.has(a) || i.associations.set(a, {}), i.associations.get(a).nodes = e, a
                }))
            }
            loadScene(e) {
                const t = this.json,
                    n = this.extensions,
                    i = this.json.scenes[e],
                    r = this,
                    s = new hs;
                i.name && (s.name = r.createUniqueName(i.name)), ol(s, i), i.extensions && al(n, s, i);
                const a = i.nodes || [],
                    o = [];
                for (let e = 0, n = a.length; e < n; e++) o.push(pl(a[e], s, t, r));
                return Promise.all(o).then((function() {
                    return r.associations = (e => {
                        const t = new Map;
                        for (const [e, n] of r.associations)(e instanceof Ut || e instanceof ve) && t.set(e, n);
                        return e.traverse((e => {
                            const n = r.associations.get(e);
                            null != n && t.set(e, n)
                        })), t
                    })(s), s
                }))
            }
        }

        function pl(e, t, n, i) {
            const r = n.nodes[e];
            return i.getDependency("node", e).then((function(e) {
                if (void 0 === r.skin) return e;
                let t;
                return i.getDependency("skin", r.skin).then((function(e) {
                    t = e;
                    const n = [];
                    for (let e = 0, r = t.joints.length; e < r; e++) n.push(i.getDependency("node", t.joints[e]));
                    return Promise.all(n)
                })).then((function(n) {
                    return e.traverse((function(e) {
                        if (!e.isMesh) return;
                        const i = [],
                            r = [];
                        for (let e = 0, s = n.length; e < s; e++) {
                            const s = n[e];
                            if (s) {
                                i.push(s);
                                const n = new tt;
                                void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), r.push(n)
                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                        }
                        e.bind(new Rs(i, r), e.matrixWorld)
                    })), e
                }))
            })).then((function(e) {
                t.add(e);
                const s = [];
                if (r.children) {
                    const t = r.children;
                    for (let r = 0, a = t.length; r < a; r++) {
                        const a = t[r];
                        s.push(pl(a, e, n, i))
                    }
                }
                return Promise.all(s)
            }))
        }

        function fl(e, t, n) {
            const i = t.attributes,
                r = [];

            function s(t, i) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(i, t)
                }))
            }
            for (const t in i) {
                const n = il[t] || t.toLowerCase();
                n in e.attributes || r.push(s(i[t], n))
            }
            if (void 0 !== t.indices && !e.index) {
                const i = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }));
                r.push(i)
            }
            return ol(e, t),
                function(e, t, n) {
                    const i = t.attributes,
                        r = new Te;
                    if (void 0 === i.POSITION) return; {
                        const e = n.json.accessors[i.POSITION],
                            t = e.min,
                            s = e.max;
                        if (void 0 === t || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (r.set(new Me(t[0], t[1], t[2]), new Me(s[0], s[1], s[2])), e.normalized) {
                            const t = ul($o[e.componentType]);
                            r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                        }
                    }
                    const s = t.targets;
                    if (void 0 !== s) {
                        const e = new Me,
                            t = new Me;
                        for (let i = 0, r = s.length; i < r; i++) {
                            const r = s[i];
                            if (void 0 !== r.POSITION) {
                                const i = n.json.accessors[r.POSITION],
                                    s = i.min,
                                    a = i.max;
                                if (void 0 !== s && void 0 !== a) {
                                    if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), i.normalized) {
                                        const e = ul($o[i.componentType]);
                                        t.multiplyScalar(e)
                                    }
                                    e.max(t)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        r.expandByVector(e)
                    }
                    e.boundingBox = r;
                    const a = new Ye;
                    r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a
                }(e, t, n), Promise.all(r).then((function() {
                    return void 0 !== t.targets ? function(e, t, n) {
                        let i = !1,
                            r = !1,
                            s = !1;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break
                        }
                        if (!i && !r && !s) return Promise.resolve(e);
                        const a = [],
                            o = [],
                            l = [];
                        for (let c = 0, h = t.length; c < h; c++) {
                            const h = t[c];
                            if (i) {
                                const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                                a.push(t)
                            }
                            if (r) {
                                const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                                o.push(t)
                            }
                            if (s) {
                                const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                                l.push(t)
                            }
                        }
                        return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then((function(t) {
                            const n = t[0],
                                a = t[1],
                                o = t[2];
                            return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = a), s && (e.morphAttributes.color = o), e.morphTargetsRelative = !0, e
                        }))
                    }(e, t.targets, n) : e
                }))
        }

        function ml(e, t) {
            let n = e.getIndex();
            if (null === n) {
                const t = [],
                    i = e.getAttribute("position");
                if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                for (let e = 0; e < i.count; e++) t.push(e);
                e.setIndex(t), n = e.getIndex()
            }
            const i = n.count - 2,
                r = [];
            if (2 === t)
                for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
            else
                for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
            r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const s = e.clone();
            return s.setIndex(r), s
        }
        const gl = new WeakMap;

        function vl() {
            let e, t;

            function n(e, t, n, i, r, s) {
                const a = s.num_components(),
                    o = n.num_points() * a,
                    l = o * r.BYTES_PER_ELEMENT,
                    c = function(e, t) {
                        switch (t) {
                            case Float32Array:
                                return e.DT_FLOAT32;
                            case Int8Array:
                                return e.DT_INT8;
                            case Int16Array:
                                return e.DT_INT16;
                            case Int32Array:
                                return e.DT_INT32;
                            case Uint8Array:
                                return e.DT_UINT8;
                            case Uint16Array:
                                return e.DT_UINT16;
                            case Uint32Array:
                                return e.DT_UINT32
                        }
                    }(e, r),
                    h = e._malloc(l);
                t.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
                const u = new r(e.HEAPF32.buffer, h, o).slice();
                return e._free(h), {
                    name: i,
                    array: u,
                    itemSize: a
                }
            }
            onmessage = function(i) {
                const r = i.data;
                switch (r.type) {
                    case "init":
                        e = r.decoderConfig, t = new Promise((function(t) {
                            e.onModuleLoaded = function(e) {
                                t({
                                    draco: e
                                })
                            }, DracoDecoderModule(e)
                        }));
                        break;
                    case "decode":
                        const i = r.buffer,
                            s = r.taskConfig;
                        t.then((e => {
                            const t = e.draco,
                                a = new t.Decoder,
                                o = new t.DecoderBuffer;
                            o.Init(new Int8Array(i), i.byteLength);
                            try {
                                const e = function(e, t, i, r) {
                                        const s = r.attributeIDs,
                                            a = r.attributeTypes;
                                        let o, l;
                                        const c = t.GetEncodedGeometryType(i);
                                        if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeBufferToMesh(i, o);
                                        else {
                                            if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            o = new e.PointCloud, l = t.DecodeBufferToPointCloud(i, o)
                                        }
                                        if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                        const h = {
                                            index: null,
                                            attributes: []
                                        };
                                        for (const i in s) {
                                            const l = self[a[i]];
                                            let c, u;
                                            if (r.useUniqueIDs) u = s[i], c = t.GetAttributeByUniqueId(o, u);
                                            else {
                                                if (u = t.GetAttributeId(o, e[s[i]]), -1 === u) continue;
                                                c = t.GetAttribute(o, u)
                                            }
                                            h.attributes.push(n(e, t, o, i, l, c))
                                        }
                                        return c === e.TRIANGULAR_MESH && (h.index = function(e, t, n) {
                                            const i = 3 * n.num_faces(),
                                                r = 4 * i,
                                                s = e._malloc(r);
                                            t.GetTrianglesUInt32Array(n, r, s);
                                            const a = new Uint32Array(e.HEAPF32.buffer, s, i).slice();
                                            return e._free(s), {
                                                array: a,
                                                itemSize: 1
                                            }
                                        }(e, t, o)), e.destroy(o), h
                                    }(t, a, o, s),
                                    i = e.attributes.map((e => e.array.buffer));
                                e.index && i.push(e.index.array.buffer), self.postMessage({
                                    type: "decode",
                                    id: r.id,
                                    geometry: e
                                }, i)
                            } catch (e) {
                                console.error(e), self.postMessage({
                                    type: "error",
                                    id: r.id,
                                    error: e.message
                                })
                            } finally {
                                t.destroy(o), t.destroy(a)
                            }
                        }))
                }
            }
        }
        var xl = function() {
            this._tweens = {}, this._tweensAddedDuringUpdate = {}
        };
        xl.prototype = {
            getAll: function() {
                return Object.keys(this._tweens).map(function(e) {
                    return this._tweens[e]
                }.bind(this))
            },
            removeAll: function() {
                this._tweens = {}
            },
            add: function(e) {
                this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
            },
            remove: function(e) {
                delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
            },
            update: function(e, t) {
                var n = Object.keys(this._tweens);
                if (0 === n.length) return !1;
                for (e = void 0 !== e ? e : wl.now(); 0 < n.length;) {
                    this._tweensAddedDuringUpdate = {};
                    for (var i = 0; i < n.length; i++) {
                        var r = this._tweens[n[i]];
                        r && !1 === r.update(e) && (r._isPlaying = !1, t || delete this._tweens[n[i]])
                    }
                    n = Object.keys(this._tweensAddedDuringUpdate)
                }
                return !0
            }
        };
        var wl = new xl;
        wl.Group = xl, wl._nextId = 0, wl.nextId = function() {
            return wl._nextId++
        }, "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? wl.now = function() {
            var e = process.hrtime();
            return 1e3 * e[0] + e[1] / 1e6
        } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? wl.now = self.performance.now.bind(self.performance) : void 0 !== Date.now ? wl.now = Date.now : wl.now = function() {
            return (new Date).getTime()
        }, wl.Tween = function(e, t) {
            this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = wl.Easing.Linear.None, this._interpolationFunction = wl.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = t || wl, this._id = wl.nextId()
        }, wl.Tween.prototype = {
            getId: function() {
                return this._id
            },
            isPlaying: function() {
                return this._isPlaying
            },
            to: function(e, t) {
                return this._valuesEnd = Object.create(e), void 0 !== t && (this._duration = t), this
            },
            duration: function(e) {
                return this._duration = e, this
            },
            start: function(e) {
                for (var t in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== e ? "string" == typeof e ? wl.now() + parseFloat(e) : e : wl.now(), this._startTime += this._delayTime, this._valuesEnd) {
                    if (this._valuesEnd[t] instanceof Array) {
                        if (0 === this._valuesEnd[t].length) continue;
                        this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
                    }
                    void 0 !== this._object[t] && (this._valuesStart[t] = this._object[t], this._valuesStart[t] instanceof Array == 0 && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0)
                }
                return this
            },
            stop: function() {
                return this._isPlaying && (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens()), this
            },
            end: function() {
                return this.update(1 / 0), this
            },
            stopChainedTweens: function() {
                for (var e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].stop()
            },
            group: function(e) {
                return this._group = e, this
            },
            delay: function(e) {
                return this._delayTime = e, this
            },
            repeat: function(e) {
                return this._repeat = e, this
            },
            repeatDelay: function(e) {
                return this._repeatDelayTime = e, this
            },
            yoyo: function(e) {
                return this._yoyo = e, this
            },
            easing: function(e) {
                return this._easingFunction = e, this
            },
            interpolation: function(e) {
                return this._interpolationFunction = e, this
            },
            chain: function() {
                return this._chainedTweens = arguments, this
            },
            onStart: function(e) {
                return this._onStartCallback = e, this
            },
            onUpdate: function(e) {
                return this._onUpdateCallback = e, this
            },
            onComplete: function(e) {
                return this._onCompleteCallback = e, this
            },
            onStop: function(e) {
                return this._onStopCallback = e, this
            },
            update: function(e) {
                var t, n, i;
                if (e < this._startTime) return !0;
                for (t in !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), n = (e - this._startTime) / this._duration, n = 0 === this._duration || 1 < n ? 1 : n, i = this._easingFunction(n), this._valuesEnd)
                    if (void 0 !== this._valuesStart[t]) {
                        var r = this._valuesStart[t] || 0,
                            s = this._valuesEnd[t];
                        s instanceof Array ? this._object[t] = this._interpolationFunction(s, i) : ("string" == typeof s && (s = "+" === s.charAt(0) || "-" === s.charAt(0) ? r + parseFloat(s) : parseFloat(s)), "number" == typeof s && (this._object[t] = r + (s - r) * i))
                    }
                if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object), 1 !== n) return !0;
                if (0 < this._repeat) {
                    for (t in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                        if ("string" == typeof this._valuesEnd[t] && (this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(this._valuesEnd[t])), this._yoyo) {
                            var a = this._valuesStartRepeat[t];
                            this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = a
                        }
                        this._valuesStart[t] = this._valuesStartRepeat[t]
                    }
                    return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, !0
                }
                null !== this._onCompleteCallback && this._onCompleteCallback(this._object);
                for (var o = 0, l = this._chainedTweens.length; o < l; o++) this._chainedTweens[o].start(this._startTime + this._duration);
                return !1
            }
        }, wl.Easing = {
            Linear: {
                None: function(e) {
                    return e
                }
            },
            Quadratic: {
                In: function(e) {
                    return e * e
                },
                Out: function(e) {
                    return e * (2 - e)
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                }
            },
            Cubic: {
                In: function(e) {
                    return e * e * e
                },
                Out: function(e) {
                    return --e * e * e + 1
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                }
            },
            Quartic: {
                In: function(e) {
                    return e * e * e * e
                },
                Out: function(e) {
                    return 1 - --e * e * e * e
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                }
            },
            Quintic: {
                In: function(e) {
                    return e * e * e * e * e
                },
                Out: function(e) {
                    return --e * e * e * e * e + 1
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                }
            },
            Sinusoidal: {
                In: function(e) {
                    return 1 - Math.cos(e * Math.PI / 2)
                },
                Out: function(e) {
                    return Math.sin(e * Math.PI / 2)
                },
                InOut: function(e) {
                    return .5 * (1 - Math.cos(Math.PI * e))
                }
            },
            Exponential: {
                In: function(e) {
                    return 0 === e ? 0 : Math.pow(1024, e - 1)
                },
                Out: function(e) {
                    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                },
                InOut: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                }
            },
            Circular: {
                In: function(e) {
                    return 1 - Math.sqrt(1 - e * e)
                },
                Out: function(e) {
                    return Math.sqrt(1 - --e * e)
                },
                InOut: function(e) {
                    return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                }
            },
            Elastic: {
                In: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
                },
                Out: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
                },
                InOut: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
                }
            },
            Back: {
                In: function(e) {
                    return e * e * (2.70158 * e - 1.70158)
                },
                Out: function(e) {
                    return --e * e * (2.70158 * e + 1.70158) + 1
                },
                InOut: function(e) {
                    var t = 2.5949095;
                    return (e *= 2) < 1 ? e * e * ((1 + t) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + t) * e + t) + 2)
                }
            },
            Bounce: {
                In: function(e) {
                    return 1 - wl.Easing.Bounce.Out(1 - e)
                },
                Out: function(e) {
                    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                },
                InOut: function(e) {
                    return e < .5 ? .5 * wl.Easing.Bounce.In(2 * e) : .5 * wl.Easing.Bounce.Out(2 * e - 1) + .5
                }
            }
        }, wl.Interpolation = {
            Linear: function(e, t) {
                var n = e.length - 1,
                    i = n * t,
                    r = Math.floor(i),
                    s = wl.Interpolation.Utils.Linear;
                return t < 0 ? s(e[0], e[1], i) : 1 < t ? s(e[n], e[n - 1], n - i) : s(e[r], e[n < r + 1 ? n : r + 1], i - r)
            },
            Bezier: function(e, t) {
                for (var n = 0, i = e.length - 1, r = Math.pow, s = wl.Interpolation.Utils.Bernstein, a = 0; a <= i; a++) n += r(1 - t, i - a) * r(t, a) * e[a] * s(i, a);
                return n
            },
            CatmullRom: function(e, t) {
                var n = e.length - 1,
                    i = n * t,
                    r = Math.floor(i),
                    s = wl.Interpolation.Utils.CatmullRom;
                return e[0] === e[n] ? (t < 0 && (r = Math.floor(i = n * (1 + t))), s(e[(r - 1 + n) % n], e[r], e[(r + 1) % n], e[(r + 2) % n], i - r)) : t < 0 ? e[0] - (s(e[0], e[0], e[1], e[1], -i) - e[0]) : 1 < t ? e[n] - (s(e[n], e[n], e[n - 1], e[n - 1], i - n) - e[n]) : s(e[r ? r - 1 : 0], e[r], e[n < r + 1 ? n : r + 1], e[n < r + 2 ? n : r + 2], i - r)
            },
            Utils: {
                Linear: function(e, t, n) {
                    return (t - e) * n + e
                },
                Bernstein: function(e, t) {
                    var n = wl.Interpolation.Utils.Factorial;
                    return n(e) / n(t) / n(e - t)
                },
                Factorial: function() {
                    var e = [1];
                    return function(t) {
                        var n = 1;
                        if (e[t]) return e[t];
                        for (var i = t; 1 < i; i--) n *= i;
                        return e[t] = n
                    }
                }(),
                CatmullRom: function(e, t, n, i, r) {
                    var s = .5 * (n - e),
                        a = .5 * (i - t),
                        o = r * r;
                    return (2 * t - 2 * n + s + a) * (r * o) + (-3 * t + 3 * n - 2 * s - a) * o + s * r + t
                }
            }
        }, "function" == typeof define && define.amd ? define([], (function() {
            return wl
        })) : "undefined" != typeof module && "object" == typeof exports && (module.exports = wl);
        class bl {
            constructor(e, t, n, i, r = "div") {
                this.parent = e, this.object = t, this.property = n, this._disabled = !1, this.initialValue = this.getValue(), this.domElement = document.createElement("div"), this.domElement.classList.add("controller"), this.domElement.classList.add(i), this.$name = document.createElement("div"), this.$name.classList.add("name"), bl.nextNameID = bl.nextNameID || 0, this.$name.id = "lil-gui-name-" + ++bl.nextNameID, this.$widget = document.createElement(r), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(n)
            }
            name(e) {
                return this._name = e, this.$name.innerHTML = e, this
            }
            onChange(e) {
                return this._onChange = e, this
            }
            _callOnChange() {
                this.parent._callOnChange(this), void 0 !== this._onChange && this._onChange.call(this, this.getValue()), this._changed = !0
            }
            onFinishChange(e) {
                return this._onFinishChange = e, this
            }
            _callOnFinishChange() {
                this._changed && (this.parent._callOnFinishChange(this), void 0 !== this._onFinishChange && this._onFinishChange.call(this, this.getValue())), this._changed = !1
            }
            reset() {
                return this.setValue(this.initialValue), this._callOnFinishChange(), this
            }
            enable(e = !0) {
                return this.disable(!e)
            }
            disable(e = !0) {
                return e === this._disabled || (this._disabled = e, this.domElement.classList.toggle("disabled", e), this.$disable.toggleAttribute("disabled", e)), this
            }
            options(e) {
                const t = this.parent.add(this.object, this.property, e);
                return t.name(this._name), this.destroy(), t
            }
            min(e) {
                return this
            }
            max(e) {
                return this
            }
            step(e) {
                return this
            }
            listen(e = !0) {
                return this._listening = e, void 0 !== this._listenCallbackID && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this
            }
            _listenCallback() {
                this._listenCallbackID = requestAnimationFrame(this._listenCallback), this.updateDisplay()
            }
            getValue() {
                return this.object[this.property]
            }
            setValue(e) {
                return this.object[this.property] = e, this._callOnChange(), this.updateDisplay(), this
            }
            updateDisplay() {
                return this
            }
            load(e) {
                return this.setValue(e), this._callOnFinishChange(), this
            }
            save() {
                return this.getValue()
            }
            destroy() {
                this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement)
            }
        }
        class _l extends bl {
            constructor(e, t, n) {
                super(e, t, n, "boolean", "label"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "checkbox"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$input.addEventListener("change", (() => {
                    this.setValue(this.$input.checked), this._callOnFinishChange()
                })), this.$disable = this.$input, this.updateDisplay()
            }
            updateDisplay() {
                return this.$input.checked = this.getValue(), this
            }
        }

        function yl(e) {
            let t, n;
            return (t = e.match(/(#|0x)?([a-f0-9]{6})/i)) ? n = t[2] : (t = e.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? n = parseInt(t[1]).toString(16).padStart(2, 0) + parseInt(t[2]).toString(16).padStart(2, 0) + parseInt(t[3]).toString(16).padStart(2, 0) : (t = e.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (n = t[1] + t[1] + t[2] + t[2] + t[3] + t[3]), !!n && "#" + n
        }
        const Al = {
                isPrimitive: !0,
                match: e => "string" == typeof e,
                fromHexString: yl,
                toHexString: yl
            },
            Ml = {
                isPrimitive: !0,
                match: e => "number" == typeof e,
                fromHexString: e => parseInt(e.substring(1), 16),
                toHexString: e => "#" + e.toString(16).padStart(6, 0)
            },
            Sl = {
                isPrimitive: !1,
                match: Array.isArray,
                fromHexString(e, t, n = 1) {
                    const i = Ml.fromHexString(e);
                    t[0] = (i >> 16 & 255) / 255 * n, t[1] = (i >> 8 & 255) / 255 * n, t[2] = (255 & i) / 255 * n
                },
                toHexString: ([e, t, n], i = 1) => Ml.toHexString(e * (i = 255 / i) << 16 ^ t * i << 8 ^ n * i << 0)
            },
            El = {
                isPrimitive: !1,
                match: e => Object(e) === e,
                fromHexString(e, t, n = 1) {
                    const i = Ml.fromHexString(e);
                    t.r = (i >> 16 & 255) / 255 * n, t.g = (i >> 8 & 255) / 255 * n, t.b = (255 & i) / 255 * n
                },
                toHexString: ({
                    r: e,
                    g: t,
                    b: n
                }, i = 1) => Ml.toHexString(e * (i = 255 / i) << 16 ^ t * i << 8 ^ n * i << 0)
            },
            Tl = [Al, Ml, Sl, El];
        class Cl extends bl {
            constructor(e, t, n, i) {
                var r;
                super(e, t, n, "color"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "color"), this.$input.setAttribute("tabindex", -1), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$text = document.createElement("input"), this.$text.setAttribute("type", "text"), this.$text.setAttribute("spellcheck", "false"), this.$text.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$display.appendChild(this.$input), this.$widget.appendChild(this.$display), this.$widget.appendChild(this.$text), this._format = (r = this.initialValue, Tl.find((e => e.match(r)))), this._rgbScale = i, this._initialValueHexString = this.save(), this._textFocused = !1, this.$input.addEventListener("input", (() => {
                    this._setValueFromHexString(this.$input.value)
                })), this.$input.addEventListener("blur", (() => {
                    this._callOnFinishChange()
                })), this.$text.addEventListener("input", (() => {
                    const e = yl(this.$text.value);
                    e && this._setValueFromHexString(e)
                })), this.$text.addEventListener("focus", (() => {
                    this._textFocused = !0, this.$text.select()
                })), this.$text.addEventListener("blur", (() => {
                    this._textFocused = !1, this.updateDisplay(), this._callOnFinishChange()
                })), this.$disable = this.$text, this.updateDisplay()
            }
            reset() {
                return this._setValueFromHexString(this._initialValueHexString), this
            }
            _setValueFromHexString(e) {
                if (this._format.isPrimitive) {
                    const t = this._format.fromHexString(e);
                    this.setValue(t)
                } else this._format.fromHexString(e, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay()
            }
            save() {
                return this._format.toHexString(this.getValue(), this._rgbScale)
            }
            load(e) {
                return this._setValueFromHexString(e), this._callOnFinishChange(), this
            }
            updateDisplay() {
                return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this
            }
        }
        class Dl extends bl {
            constructor(e, t, n) {
                super(e, t, n, "function"), this.$button = document.createElement("button"), this.$button.appendChild(this.$name), this.$widget.appendChild(this.$button), this.$button.addEventListener("click", (e => {
                    e.preventDefault(), this.getValue().call(this.object)
                })), this.$button.addEventListener("touchstart", (() => {})), this.$disable = this.$button
            }
        }
        class Pl extends bl {
            constructor(e, t, n, i, r, s) {
                super(e, t, n, "number"), this._initInput(), this.min(i), this.max(r);
                const a = void 0 !== s;
                this.step(a ? s : this._getImplicitStep(), a), this.updateDisplay()
            }
            min(e) {
                return this._min = e, this._onUpdateMinMax(), this
            }
            max(e) {
                return this._max = e, this._onUpdateMinMax(), this
            }
            step(e, t = !0) {
                return this._step = e, this._stepExplicit = t, this
            }
            updateDisplay() {
                const e = this.getValue();
                if (this._hasSlider) {
                    let t = (e - this._min) / (this._max - this._min);
                    t = Math.max(0, Math.min(t, 1)), this.$fill.style.width = 100 * t + "%"
                }
                return this._inputFocused || (this.$input.value = e), this
            }
            _initInput() {
                this.$input = document.createElement("input"), this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$disable = this.$input;
                const e = e => {
                    const t = parseFloat(this.$input.value);
                    isNaN(t) || (this._snapClampSetValue(t + e), this.$input.value = this.getValue())
                };
                let t, n, i, r, s, a = !1;
                const o = e => {
                        if (a) {
                            const i = e.clientX - t,
                                r = e.clientY - n;
                            Math.abs(r) > 5 ? (e.preventDefault(), this.$input.blur(), a = !1, this._setDraggingStyle(!0, "vertical")) : Math.abs(i) > 5 && l()
                        }
                        if (!a) {
                            const t = e.clientY - i;
                            s -= t * this._step * this._arrowKeyMultiplier(e), r + s > this._max ? s = this._max - r : r + s < this._min && (s = this._min - r), this._snapClampSetValue(r + s)
                        }
                        i = e.clientY
                    },
                    l = () => {
                        this._setDraggingStyle(!1, "vertical"), this._callOnFinishChange(), window.removeEventListener("mousemove", o), window.removeEventListener("mouseup", l)
                    };
                this.$input.addEventListener("input", (() => {
                    const e = parseFloat(this.$input.value);
                    isNaN(e) || this.setValue(this._clamp(e))
                })), this.$input.addEventListener("keydown", (t => {
                    "Enter" === t.code && this.$input.blur(), "ArrowUp" === t.code && (t.preventDefault(), e(this._step * this._arrowKeyMultiplier(t))), "ArrowDown" === t.code && (t.preventDefault(), e(this._step * this._arrowKeyMultiplier(t) * -1))
                })), this.$input.addEventListener("wheel", (t => {
                    this._inputFocused && (t.preventDefault(), e(this._step * this._normalizeMouseWheel(t)))
                })), this.$input.addEventListener("mousedown", (e => {
                    t = e.clientX, n = i = e.clientY, a = !0, r = this.getValue(), s = 0, window.addEventListener("mousemove", o), window.addEventListener("mouseup", l)
                })), this.$input.addEventListener("focus", (() => {
                    this._inputFocused = !0
                })), this.$input.addEventListener("blur", (() => {
                    this._inputFocused = !1, this.updateDisplay(), this._callOnFinishChange()
                }))
            }
            _initSlider() {
                this._hasSlider = !0, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
                const e = e => {
                        const t = this.$slider.getBoundingClientRect();
                        let n = (i = e, r = t.left, s = t.right, a = this._min, (i - r) / (s - r) * (this._max - a) + a);
                        var i, r, s, a;
                        this._snapClampSetValue(n)
                    },
                    t = t => {
                        e(t.clientX)
                    },
                    n = () => {
                        this._callOnFinishChange(), this._setDraggingStyle(!1), window.removeEventListener("mousemove", t), window.removeEventListener("mouseup", n)
                    };
                let i, r, s = !1;
                const a = t => {
                        t.preventDefault(), this._setDraggingStyle(!0), e(t.touches[0].clientX), s = !1
                    },
                    o = t => {
                        if (s) {
                            const e = t.touches[0].clientX - i,
                                n = t.touches[0].clientY - r;
                            Math.abs(e) > Math.abs(n) ? a(t) : (window.removeEventListener("touchmove", o), window.removeEventListener("touchend", l))
                        } else t.preventDefault(), e(t.touches[0].clientX)
                    },
                    l = () => {
                        this._callOnFinishChange(), this._setDraggingStyle(!1), window.removeEventListener("touchmove", o), window.removeEventListener("touchend", l)
                    },
                    c = this._callOnFinishChange.bind(this);
                let h;
                this.$slider.addEventListener("mousedown", (i => {
                    this._setDraggingStyle(!0), e(i.clientX), window.addEventListener("mousemove", t), window.addEventListener("mouseup", n)
                })), this.$slider.addEventListener("touchstart", (e => {
                    e.touches.length > 1 || (this._hasScrollBar ? (i = e.touches[0].clientX, r = e.touches[0].clientY, s = !0) : a(e), window.addEventListener("touchmove", o), window.addEventListener("touchend", l))
                })), this.$slider.addEventListener("wheel", (e => {
                    if (Math.abs(e.deltaX) < Math.abs(e.deltaY) && this._hasScrollBar) return;
                    e.preventDefault();
                    const t = this._normalizeMouseWheel(e) * this._step;
                    this._snapClampSetValue(this.getValue() + t), this.$input.value = this.getValue(), clearTimeout(h), h = setTimeout(c, 400)
                }))
            }
            _setDraggingStyle(e, t = "horizontal") {
                this.$slider && this.$slider.classList.toggle("active", e), document.body.classList.toggle("lil-gui-dragging", e), document.body.classList.toggle("lil-gui-" + t, e)
            }
            _getImplicitStep() {
                return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : .1
            }
            _onUpdateMinMax() {
                !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), !1), this._initSlider(), this.updateDisplay())
            }
            _normalizeMouseWheel(e) {
                let {
                    deltaX: t,
                    deltaY: n
                } = e;
                return Math.floor(e.deltaY) !== e.deltaY && e.wheelDelta && (t = 0, n = -e.wheelDelta / 120, n *= this._stepExplicit ? 1 : 10), t + -n
            }
            _arrowKeyMultiplier(e) {
                let t = this._stepExplicit ? 1 : 10;
                return e.shiftKey ? t *= 10 : e.altKey && (t /= 10), t
            }
            _snap(e) {
                const t = Math.round(e / this._step) * this._step;
                return parseFloat(t.toPrecision(15))
            }
            _clamp(e) {
                return e < this._min && (e = this._min), e > this._max && (e = this._max), e
            }
            _snapClampSetValue(e) {
                this.setValue(this._clamp(this._snap(e)))
            }
            get _hasScrollBar() {
                const e = this.parent.root.$children;
                return e.scrollHeight > e.clientHeight
            }
            get _hasMin() {
                return void 0 !== this._min
            }
            get _hasMax() {
                return void 0 !== this._max
            }
        }
        class Rl extends bl {
            constructor(e, t, n, i) {
                super(e, t, n, "option"), this.$select = document.createElement("select"), this.$select.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this._values = Array.isArray(i) ? i : Object.values(i), this._names = Array.isArray(i) ? i : Object.keys(i), this._names.forEach((e => {
                    const t = document.createElement("option");
                    t.innerHTML = e, this.$select.appendChild(t)
                })), this.$select.addEventListener("change", (() => {
                    this.setValue(this._values[this.$select.selectedIndex]), this._callOnFinishChange()
                })), this.$select.addEventListener("focus", (() => {
                    this.$display.classList.add("focus")
                })), this.$select.addEventListener("blur", (() => {
                    this.$display.classList.remove("focus")
                })), this.$widget.appendChild(this.$select), this.$widget.appendChild(this.$display), this.$disable = this.$select, this.updateDisplay()
            }
            updateDisplay() {
                const e = this.getValue(),
                    t = this._values.indexOf(e);
                return this.$select.selectedIndex = t, this.$display.innerHTML = -1 === t ? e : this._names[t], this
            }
        }
        class Ll extends bl {
            constructor(e, t, n) {
                super(e, t, n, "string"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$input.addEventListener("input", (() => {
                    this.setValue(this.$input.value)
                })), this.$input.addEventListener("keydown", (e => {
                    "Enter" === e.code && this.$input.blur()
                })), this.$input.addEventListener("blur", (() => {
                    this._callOnFinishChange()
                })), this.$widget.appendChild(this.$input), this.$disable = this.$input, this.updateDisplay()
            }
            updateDisplay() {
                return this.$input.value = this.getValue(), this
            }
        }
        let Il = !1;
        class Bl {
            constructor({
                parent: e,
                autoPlace: t = void 0 === e,
                container: n,
                width: i,
                title: r = "Controls",
                injectStyles: s = !0,
                touchStyles: a = !0
            } = {}) {
                if (this.parent = e, this.root = e ? e.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = !1, this._hidden = !1, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", !0), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", (() => this.openAnimated(this._closed))), this.$title.addEventListener("keydown", (e => {
                        "Enter" !== e.code && "Space" !== e.code || (e.preventDefault(), this.$title.click())
                    })), this.$title.addEventListener("touchstart", (() => {})), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(r), a && this.domElement.classList.add("allow-touch-styles"), this.parent) return this.parent.children.push(this), this.parent.folders.push(this), void this.parent.$children.appendChild(this.domElement);
                this.domElement.classList.add("root"), !Il && s && (function(e) {
                    const t = document.createElement("style");
                    t.innerHTML = '.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}';
                    const n = document.querySelector("head link[rel=stylesheet], head style");
                    n ? document.head.insertBefore(t, n) : document.head.appendChild(t)
                }(), Il = !0), n ? n.appendChild(this.domElement) : t && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), i && this.domElement.style.setProperty("--width", i + "px"), this.domElement.addEventListener("keydown", (e => e.stopPropagation())), this.domElement.addEventListener("keyup", (e => e.stopPropagation()))
            }
            add(e, t, n, i, r) {
                if (Object(n) === n) return new Rl(this, e, t, n);
                const s = e[t];
                switch (typeof s) {
                    case "number":
                        return new Pl(this, e, t, n, i, r);
                    case "boolean":
                        return new _l(this, e, t);
                    case "string":
                        return new Ll(this, e, t);
                    case "function":
                        return new Dl(this, e, t)
                }
                console.error("gui.add failed\n\tproperty:", t, "\n\tobject:", e, "\n\tvalue:", s)
            }
            addColor(e, t, n = 1) {
                return new Cl(this, e, t, n)
            }
            addFolder(e) {
                return new Bl({
                    parent: this,
                    title: e
                })
            }
            load(e, t = !0) {
                return e.controllers && this.controllers.forEach((t => {
                    t instanceof Dl || t._name in e.controllers && t.load(e.controllers[t._name])
                })), t && e.folders && this.folders.forEach((t => {
                    t._title in e.folders && t.load(e.folders[t._title])
                })), this
            }
            save(e = !0) {
                const t = {
                    controllers: {},
                    folders: {}
                };
                return this.controllers.forEach((e => {
                    if (!(e instanceof Dl)) {
                        if (e._name in t.controllers) throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);
                        t.controllers[e._name] = e.save()
                    }
                })), e && this.folders.forEach((e => {
                    if (e._title in t.folders) throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);
                    t.folders[e._title] = e.save()
                })), t
            }
            open(e = !0) {
                return this._closed = !e, this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this
            }
            close() {
                return this.open(!1)
            }
            show(e = !0) {
                return this._hidden = !e, this.domElement.style.display = this._hidden ? "none" : "", this
            }
            hide() {
                return this.show(!1)
            }
            openAnimated(e = !0) {
                return this._closed = !e, this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame((() => {
                    const t = this.$children.clientHeight;
                    this.$children.style.height = t + "px", this.domElement.classList.add("transition");
                    const n = e => {
                        e.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", n))
                    };
                    this.$children.addEventListener("transitionend", n);
                    const i = e ? this.$children.scrollHeight : 0;
                    this.domElement.classList.toggle("closed", !e), requestAnimationFrame((() => {
                        this.$children.style.height = i + "px"
                    }))
                })), this
            }
            title(e) {
                return this._title = e, this.$title.innerHTML = e, this
            }
            reset(e = !0) {
                return (e ? this.controllersRecursive() : this.controllers).forEach((e => e.reset())), this
            }
            onChange(e) {
                return this._onChange = e, this
            }
            _callOnChange(e) {
                this.parent && this.parent._callOnChange(e), void 0 !== this._onChange && this._onChange.call(this, {
                    object: e.object,
                    property: e.property,
                    value: e.getValue(),
                    controller: e
                })
            }
            onFinishChange(e) {
                return this._onFinishChange = e, this
            }
            _callOnFinishChange(e) {
                this.parent && this.parent._callOnFinishChange(e), void 0 !== this._onFinishChange && this._onFinishChange.call(this, {
                    object: e.object,
                    property: e.property,
                    value: e.getValue(),
                    controller: e
                })
            }
            destroy() {
                this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach((e => e.destroy()))
            }
            controllersRecursive() {
                let e = Array.from(this.controllers);
                return this.folders.forEach((t => {
                    e = e.concat(t.controllersRecursive())
                })), e
            }
            foldersRecursive() {
                let e = Array.from(this.folders);
                return this.folders.forEach((t => {
                    e = e.concat(t.foldersRecursive())
                })), e
            }
        }
        var Ol = function() {
            var e = 0,
                t = document.createElement("div");

            function n(e) {
                return t.appendChild(e.dom), e
            }

            function i(n) {
                for (var i = 0; i < t.children.length; i++) t.children[i].style.display = i === n ? "block" : "none";
                e = n
            }
            t.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", t.addEventListener("click", (function(n) {
                n.preventDefault(), i(++e % t.children.length)
            }), !1);
            var r = (performance || Date).now(),
                s = r,
                a = 0,
                o = n(new Ol.Panel("FPS", "#0ff", "#002")),
                l = n(new Ol.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory) var c = n(new Ol.Panel("MB", "#f08", "#201"));
            return i(0), {
                REVISION: 16,
                dom: t,
                addPanel: n,
                showPanel: i,
                begin: function() {
                    r = (performance || Date).now()
                },
                end: function() {
                    a++;
                    var e = (performance || Date).now();
                    if (l.update(e - r, 200), e >= s + 1e3 && (o.update(1e3 * a / (e - s), 100), s = e, a = 0, c)) {
                        var t = performance.memory;
                        c.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576)
                    }
                    return e
                },
                update: function() {
                    r = this.end()
                },
                domElement: t,
                setMode: i
            }
        };
        Ol.Panel = function(e, t, n) {
            var i = 1 / 0,
                r = 0,
                s = Math.round,
                a = s(window.devicePixelRatio || 1),
                o = 80 * a,
                l = 48 * a,
                c = 3 * a,
                h = 2 * a,
                u = 3 * a,
                d = 15 * a,
                p = 74 * a,
                f = 30 * a,
                m = document.createElement("canvas");
            m.width = o, m.height = l, m.style.cssText = "width:80px;height:48px";
            var g = m.getContext("2d");
            return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, o, l), g.fillStyle = t, g.fillText(e, c, h), g.fillRect(u, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u, d, p, f), {
                dom: m,
                update: function(l, v) {
                    i = Math.min(i, l), r = Math.max(r, l), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, o, d), g.fillStyle = t, g.fillText(s(l) + " " + e + " (" + s(i) + "-" + s(r) + ")", c, h), g.drawImage(m, u + a, d, p - a, f, u, d, p - a, f), g.fillRect(u + p - a, d, a, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u + p - a, d, a, s((1 - l / v) * f))
                }
            }
        };
        const kl = Ol;
        var Nl = {
                FRAGMENT_HEAD: "FRAGMENT_HEAD",
                FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                VERTEX_HEAD: "VERTEX_HEAD",
                VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
            },
            Fl = (new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]), class extends Sn {
                constructor() {
                    super({
                        name: "CopyMaterial",
                        uniforms: {
                            inputBuffer: new oo(null),
                            opacity: new oo(1)
                        },
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n#include <dithering_fragment>\n}",
                        vertexShader: "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.toneMapped = !1
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                getOpacity(e) {
                    return this.uniforms.opacity.value
                }
                setOpacity(e) {
                    this.uniforms.opacity.value = e
                }
            }),
            Ul = class extends Sn {
                constructor(e = new Z, t = 2) {
                    super({
                        name: "EdgeDetectionMaterial",
                        defines: {
                            LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                            EDGE_THRESHOLD: "0.1",
                            DEPTH_THRESHOLD: "0.01",
                            PREDICATION_MODE: "0",
                            PREDICATION_THRESHOLD: "0.01",
                            PREDICATION_SCALE: "2.0",
                            PREDICATION_STRENGTH: "1.0",
                            DEPTH_PACKING: "0"
                        },
                        uniforms: {
                            inputBuffer: new oo(null),
                            depthBuffer: new oo(null),
                            predicationBuffer: new oo(null),
                            texelSize: new oo(e)
                        },
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                        vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.toneMapped = !1, this.edgeDetectionMode = t
                }
                set depthBuffer(e) {
                    this.uniforms.depthBuffer.value = e
                }
                set depthPacking(e) {
                    this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                }
                setDepthBuffer(e, t = 3200) {
                    this.depthBuffer = e, this.depthPacking = t
                }
                get edgeDetectionMode() {
                    return Number(this.defines.EDGE_DETECTION_MODE)
                }
                set edgeDetectionMode(e) {
                    this.defines.EDGE_DETECTION_MODE = e.toFixed(0), this.needsUpdate = !0
                }
                getEdgeDetectionMode() {
                    return this.edgeDetectionMode
                }
                setEdgeDetectionMode(e) {
                    this.edgeDetectionMode = e
                }
                get localContrastAdaptationFactor() {
                    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
                }
                set localContrastAdaptationFactor(e) {
                    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"), this.needsUpdate = !0
                }
                getLocalContrastAdaptationFactor() {
                    return this.localContrastAdaptationFactor
                }
                setLocalContrastAdaptationFactor(e) {
                    this.localContrastAdaptationFactor = e
                }
                get edgeDetectionThreshold() {
                    return Number(this.defines.EDGE_THRESHOLD)
                }
                set edgeDetectionThreshold(e) {
                    this.defines.EDGE_THRESHOLD = e.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"), this.needsUpdate = !0
                }
                getEdgeDetectionThreshold() {
                    return this.edgeDetectionThreshold
                }
                setEdgeDetectionThreshold(e) {
                    this.edgeDetectionThreshold = e
                }
                get predicationMode() {
                    return Number(this.defines.PREDICATION_MODE)
                }
                set predicationMode(e) {
                    this.defines.PREDICATION_MODE = e.toFixed(0), this.needsUpdate = !0
                }
                getPredicationMode() {
                    return this.predicationMode
                }
                setPredicationMode(e) {
                    this.predicationMode = e
                }
                set predicationBuffer(e) {
                    this.uniforms.predicationBuffer.value = e
                }
                setPredicationBuffer(e) {
                    this.uniforms.predicationBuffer.value = e
                }
                get predicationThreshold() {
                    return Number(this.defines.PREDICATION_THRESHOLD)
                }
                set predicationThreshold(e) {
                    this.defines.PREDICATION_THRESHOLD = e.toFixed("6"), this.needsUpdate = !0
                }
                getPredicationThreshold() {
                    return this.predicationThreshold
                }
                setPredicationThreshold(e) {
                    this.predicationThreshold = e
                }
                get predicationScale() {
                    return Number(this.defines.PREDICATION_SCALE)
                }
                set predicationScale(e) {
                    this.defines.PREDICATION_SCALE = e.toFixed("6"), this.needsUpdate = !0
                }
                getPredicationScale() {
                    return this.predicationScale
                }
                setPredicationScale(e) {
                    this.predicationScale = e
                }
                get predicationStrength() {
                    return Number(this.defines.PREDICATION_STRENGTH)
                }
                set predicationStrength(e) {
                    this.defines.PREDICATION_STRENGTH = e.toFixed("6"), this.needsUpdate = !0
                }
                getPredicationStrength() {
                    return this.predicationStrength
                }
                setPredicationStrength(e) {
                    this.predicationStrength = e
                }
                setSize(e, t) {
                    this.uniforms.texelSize.value.set(1 / e, 1 / t)
                }
            },
            zl = class extends Sn {
                constructor(e, n, i, r, s = !1) {
                    super({
                        name: "EffectMaterial",
                        defines: {
                            THREE_REVISION: t.replace(/\D+/g, ""),
                            DEPTH_PACKING: "0",
                            ENCODE_OUTPUT: "1"
                        },
                        uniforms: {
                            inputBuffer: new oo(null),
                            depthBuffer: new oo(null),
                            resolution: new oo(new Z),
                            texelSize: new oo(new Z),
                            cameraNear: new oo(.3),
                            cameraFar: new oo(1e3),
                            aspect: new oo(1),
                            time: new oo(0)
                        },
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        dithering: s
                    }), this.toneMapped = !1, e && this.setShaderParts(e), n && this.setDefines(n), i && this.setUniforms(i), this.adoptCameraSettings(r)
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                get depthBuffer() {
                    return this.uniforms.depthBuffer.value
                }
                set depthBuffer(e) {
                    this.uniforms.depthBuffer.value = e
                }
                get depthPacking() {
                    return Number(this.defines.DEPTH_PACKING)
                }
                set depthPacking(e) {
                    this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                }
                setDepthBuffer(e, t = 3200) {
                    this.depthBuffer = e, this.depthPacking = t
                }
                setShaderData(e) {
                    this.setShaderParts(e.shaderParts), this.setDefines(e.defines), this.setUniforms(e.uniforms), this.setExtensions(e.extensions)
                }
                setShaderParts(e) {
                    // Fragment Shader
                    this.fragmentShader = `
                        #include <common>
                        #include <packing>
                        #include <dithering_pars_fragment>
                        #define packFloatToRGBA(v) packDepthToRGBA(v)
                        #define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
                
                        // ... (other uniform declarations)
                
                        FRAGMENT_HEAD
                        void main() {
                            FRAGMENT_MAIN_UV
                            vec4 color0 = texture2D(inputBuffer, UV);
                            vec4 color1 = vec4(0.0);
                            FRAGMENT_MAIN_IMAGE
                            gl_FragColor = color0;
                
                            #ifdef ENCODE_OUTPUT
                                #include <encodings_fragment>
                            #endif
                
                            #include <dithering_fragment>
                        }`.replace(Nl.FRAGMENT_HEAD, e.get(Nl.FRAGMENT_HEAD) ?? "")
                           .replace(Nl.FRAGMENT_MAIN_UV, e.get(Nl.FRAGMENT_MAIN_UV) ?? "")
                           .replace(Nl.FRAGMENT_MAIN_IMAGE, e.get(Nl.FRAGMENT_MAIN_IMAGE) ?? "");
                
                    // Vertex Shader
                    this.vertexShader = `
                        uniform vec2 resolution;
                        uniform vec2 texelSize;
                        uniform float cameraNear;
                        uniform float cameraFar;
                        uniform float aspect;
                        uniform float time;
                        varying vec2 vUv;
                
                        VERTEX_HEAD
                        void main() {
                            vUv = position.xy * 0.5 + 0.5;
                            VERTEX_MAIN_SUPPORT
                            gl_Position = vec4(position.xy, 1.0, 1.0);
                        }`.replace(Nl.VERTEX_HEAD, e.get(Nl.VERTEX_HEAD) ?? "")
                           .replace(Nl.VERTEX_MAIN_SUPPORT, e.get(Nl.VERTEX_MAIN_SUPPORT) ?? "");
                
                    this.needsUpdate = true;
                    // ... (other statements if needed)
                }
                

                setDefines(e) {
                    for (const t of e.entries()) this.defines[t[0]] = t[1];
                    return this.needsUpdate = !0, this
                }
                setUniforms(e) {
                    for (const t of e.entries()) this.uniforms[t[0]] = t[1];
                    return this
                }
                setExtensions(e) {
                    this.extensions = {};
                    for (const t of e) this.extensions[t] = !0;
                    return this
                }
                get encodeOutput() {
                    return void 0 !== this.defines.ENCODE_OUTPUT
                }
                set encodeOutput(e) {
                    this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
                }
                isOutputEncodingEnabled(e) {
                    return this.encodeOutput
                }
                setOutputEncodingEnabled(e) {
                    this.encodeOutput = e
                }
                get time() {
                    return this.uniforms.time.value
                }
                set time(e) {
                    this.uniforms.time.value = e
                }
                setDeltaTime(e) {
                    this.uniforms.time.value += e
                }
                adoptCameraSettings(e) {
                    e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof Tn ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                }
                setSize(e, t) {
                    const n = this.uniforms;
                    n.resolution.value.set(e, t), n.texelSize.value.set(1 / e, 1 / t), n.aspect.value = e / t
                }
                static get Section() {
                    return Nl
                }
            },
            Vl = class extends Sn {
                constructor(e = new Z, t = new Z) {
                    super({
                        name: "SMAAWeightsMaterial",
                        defines: {
                            MAX_SEARCH_STEPS_INT: "16",
                            MAX_SEARCH_STEPS_FLOAT: "16.0",
                            MAX_SEARCH_STEPS_DIAG_INT: "8",
                            MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                            CORNER_ROUNDING: "25",
                            CORNER_ROUNDING_NORM: "0.25",
                            AREATEX_MAX_DISTANCE: "16.0",
                            AREATEX_MAX_DISTANCE_DIAG: "20.0",
                            AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                            AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                            SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                            SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                        },
                        uniforms: {
                            inputBuffer: new oo(null),
                            searchTexture: new oo(null),
                            areaTexture: new oo(null),
                            resolution: new oo(t),
                            texelSize: new oo(e)
                        },
                        blending: 0,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
                        vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.toneMapped = !1
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                get searchTexture() {
                    return this.uniforms.searchTexture.value
                }
                set searchTexture(e) {
                    this.uniforms.searchTexture.value = e
                }
                get areaTexture() {
                    return this.uniforms.areaTexture.value
                }
                set areaTexture(e) {
                    this.uniforms.areaTexture.value = e
                }
                setLookupTextures(e, t) {
                    this.searchTexture = e, this.areaTexture = t
                }
                get orthogonalSearchSteps() {
                    return Number(this.defines.MAX_SEARCH_STEPS_INT)
                }
                set orthogonalSearchSteps(e) {
                    const t = Math.min(Math.max(e, 0), 112);
                    this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = !0
                }
                setOrthogonalSearchSteps(e) {
                    this.orthogonalSearchSteps = e
                }
                get diagonalSearchSteps() {
                    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
                }
                set diagonalSearchSteps(e) {
                    const t = Math.min(Math.max(e, 0), 20);
                    this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = !0
                }
                setDiagonalSearchSteps(e) {
                    this.diagonalSearchSteps = e
                }
                get diagonalDetection() {
                    return void 0 === this.defines.DISABLE_DIAG_DETECTION
                }
                set diagonalDetection(e) {
                    e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0
                }
                isDiagonalDetectionEnabled() {
                    return this.diagonalDetection
                }
                setDiagonalDetectionEnabled(e) {
                    this.diagonalDetection = e
                }
                get cornerRounding() {
                    return Number(this.defines.CORNER_ROUNDING)
                }
                set cornerRounding(e) {
                    const t = Math.min(Math.max(e, 0), 100);
                    this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = !0
                }
                setCornerRounding(e) {
                    this.cornerRounding = e
                }
                get cornerDetection() {
                    return void 0 === this.defines.DISABLE_CORNER_DETECTION
                }
                set cornerDetection(e) {
                    e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0
                }
                isCornerRoundingEnabled() {
                    return this.cornerDetection
                }
                setCornerRoundingEnabled(e) {
                    this.cornerDetection = e
                }
                setSize(e, t) {
                    const n = this.uniforms;
                    n.texelSize.value.set(1 / e, 1 / t), n.resolution.value.set(e, t)
                }
            },
            Hl = new En,
            Gl = null,
            Wl = class {
                constructor(e = "Pass", t = new vs, n = Hl) {
                    this.name = e, this.renderer = null, this.scene = t, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
                }
                get renderToScreen() {
                    return !this.rtt
                }
                set renderToScreen(e) {
                    if (this.rtt === e) {
                        const t = this.getFullscreenMaterial();
                        null !== t && (t.needsUpdate = !0), this.rtt = !e
                    }
                }
                setRenderer(e) {
                    this.renderer = e
                }
                isEnabled() {
                    return this.enabled
                }
                setEnabled(e) {
                    this.enabled = e
                }
                get fullscreenMaterial() {
                    return null !== this.screen ? this.screen.material : null
                }
                set fullscreenMaterial(e) {
                    let t = this.screen;
                    null !== t ? t.material = e : (t = new wn(function() {
                        if (null === Gl) {
                            const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                                t = new Float32Array([0, 0, 2, 0, 0, 2]);
                            void 0 !== (Gl = new en).setAttribute ? (Gl.setAttribute("position", new Gt(e, 3)), Gl.setAttribute("uv", new Gt(t, 2))) : (Gl.addAttribute("position", new Gt(e, 3)), Gl.addAttribute("uv", new Gt(t, 2)))
                        }
                        return Gl
                    }(), e), t.frustumCulled = !1, null === this.scene && (this.scene = new vs), this.scene.add(t), this.screen = t)
                }
                getFullscreenMaterial() {
                    return this.fullscreenMaterial
                }
                setFullscreenMaterial(e) {
                    this.fullscreenMaterial = e
                }
                getDepthTexture() {
                    return null
                }
                setDepthTexture(e, t = 3200) {}
                render(e, t, n, i, r) {
                    throw new Error("Render method not implemented!")
                }
                setSize(e, t) {}
                initialize(e, t, n) {}
                dispose() {
                    for (const e of Object.keys(this)) {
                        const t = this[e];
                        if (null !== t && "function" == typeof t.dispose) {
                            if (t instanceof vs || t === this.renderer) continue;
                            this[e].dispose()
                        }
                    }
                }
            },
            jl = class extends Wl {
                constructor(e, t = !0) {
                    super("CopyPass"), this.fullscreenMaterial = new Fl, this.needsSwap = !1, this.renderTarget = e, void 0 === e && (this.renderTarget = new we(1, 1, {
                        minFilter: p,
                        magFilter: p,
                        stencilBuffer: !1,
                        depthBuffer: !1
                    }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = t
                }
                get resize() {
                    return this.autoResize
                }
                set resize(e) {
                    this.autoResize = e
                }
                get texture() {
                    return this.renderTarget.texture
                }
                getTexture() {
                    return this.renderTarget.texture
                }
                setAutoResizeEnabled(e) {
                    this.autoResize = e
                }
                render(e, t, n, i, r) {
                    this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                }
                setSize(e, t) {
                    this.autoResize && this.renderTarget.setSize(e, t)
                }
                initialize(e, t, n) {
                    void 0 !== n && (this.renderTarget.texture.type = n, n !== m ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : e.outputEncoding === R && (this.renderTarget.texture.encoding = R))
                }
            },
            Yl = class extends Wl {
                constructor() {
                    super("ClearMaskPass", null, null), this.needsSwap = !1
                }
                render(e, t, n, i, r) {
                    const s = e.state.buffers.stencil;
                    s.setLocked(!1), s.setTest(!1)
                }
            },
            Xl = new ue,
            Ql = class extends Wl {
                constructor(e = !0, t = !0, n = !1) {
                    super("ClearPass", null, null), this.needsSwap = !1, this.color = e, this.depth = t, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1
                }
                setClearFlags(e, t, n) {
                    this.color = e, this.depth = t, this.stencil = n
                }
                getOverrideClearColor() {
                    return this.overrideClearColor
                }
                setOverrideClearColor(e) {
                    this.overrideClearColor = e
                }
                getOverrideClearAlpha() {
                    return this.overrideClearAlpha
                }
                setOverrideClearAlpha(e) {
                    this.overrideClearAlpha = e
                }
                render(e, t, n, i, r) {
                    const s = this.overrideClearColor,
                        a = this.overrideClearAlpha,
                        o = e.getClearAlpha(),
                        l = null !== s,
                        c = a >= 0;
                    l ? (Xl.copy(e.getClearColor(Xl)), e.setClearColor(s, c ? a : o)) : c && e.setClearAlpha(a), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(Xl, o) : c && e.setClearAlpha(o)
                }
            },
            ql = -1,
            Kl = class extends F {
                constructor(e, t = -1, n = -1, i = 1) {
                    super(), this.resizable = e, this.base = new Z(1, 1), this.preferred = new Z(t, n), this.target = this.preferred, this.s = i
                }
                get width() {
                    const {
                        base: e,
                        preferred: t,
                        scale: n
                    } = this;
                    let i;
                    return i = t.width !== ql ? t.width : t.height !== ql ? Math.round(t.height * (e.width / Math.max(e.height, 1))) : Math.round(e.width * n), i
                }
                set width(e) {
                    this.preferredWidth = e
                }
                get height() {
                    const {
                        base: e,
                        preferred: t,
                        scale: n
                    } = this;
                    let i;
                    return i = t.height !== ql ? t.height : t.width !== ql ? Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : Math.round(e.height * n), i
                }
                set height(e) {
                    this.preferredHeight = e
                }
                getWidth() {
                    return this.width
                }
                getHeight() {
                    return this.height
                }
                get scale() {
                    return this.s
                }
                set scale(e) {
                    this.s !== e && (this.s = e, this.preferred.setScalar(ql), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                getScale() {
                    return this.scale
                }
                setScale(e) {
                    this.scale = e
                }
                get baseWidth() {
                    return this.base.width
                }
                set baseWidth(e) {
                    this.base.width !== e && (this.base.width = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                getBaseWidth() {
                    return this.base.width
                }
                setBaseWidth(e) {
                    this.base.width !== e && (this.base.width = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                get baseHeight() {
                    return this.base.height
                }
                set baseHeight(e) {
                    this.base.height !== e && (this.base.height = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                getBaseHeight() {
                    return this.baseHeight
                }
                setBaseHeight(e) {
                    this.baseHeight = e
                }
                setBaseSize(e, t) {
                    this.base.width === e && this.base.height === t || (this.base.set(e, t), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                get preferredWidth() {
                    return this.preferred.width
                }
                set preferredWidth(e) {
                    this.preferred.width !== e && (this.preferred.width = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                getPreferredWidth() {
                    return this.preferredWidth
                }
                setPreferredWidth(e) {
                    this.preferredWidth = e
                }
                get preferredHeight() {
                    return this.preferred.height
                }
                set preferredHeight(e) {
                    this.preferred.height !== e && (this.preferred.height = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                getPreferredHeight() {
                    return this.preferredHeight
                }
                setPreferredHeight(e) {
                    this.preferredHeight = e
                }
                setPreferredSize(e, t) {
                    this.preferred.width === e && this.preferred.height === t || (this.preferred.set(e, t), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height))
                }
                copy(e) {
                    this.s = e.scale, this.base.set(e.getBaseWidth(), e.getBaseHeight()), this.preferred.set(e.getPreferredWidth(), e.getPreferredHeight()), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.base.width, this.base.height)
                }
                static get AUTO_SIZE() {
                    return ql
                }
            },
            Zl = !1,
            Jl = class {
                constructor(e = null) {
                    this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(e), this.meshCount = 0, this.replaceMaterial = e => {
                        if (e.isMesh) {
                            let t;
                            if (e.material.flatShading) switch (e.material.side) {
                                case 2:
                                    t = this.materialsFlatShadedDoubleSide;
                                    break;
                                case 1:
                                    t = this.materialsFlatShadedBackSide;
                                    break;
                                default:
                                    t = this.materialsFlatShaded
                            } else switch (e.material.side) {
                                case 2:
                                    t = this.materialsDoubleSide;
                                    break;
                                case 1:
                                    t = this.materialsBackSide;
                                    break;
                                default:
                                    t = this.materials
                            }
                            this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount
                        }
                    }
                }
                setMaterial(e) {
                    if (this.disposeMaterials(), this.material = e, null !== e) {
                        const t = this.materials = [e.clone(), e.clone(), e.clone()];
                        for (const n of t) n.uniforms = Object.assign({}, e.uniforms), n.side = 0;
                        t[2].skinning = !0, this.materialsBackSide = t.map((t => {
                            const n = t.clone();
                            return n.uniforms = Object.assign({}, e.uniforms), n.side = 1, n
                        })), this.materialsDoubleSide = t.map((t => {
                            const n = t.clone();
                            return n.uniforms = Object.assign({}, e.uniforms), n.side = 2, n
                        })), this.materialsFlatShaded = t.map((t => {
                            const n = t.clone();
                            return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n
                        })), this.materialsFlatShadedBackSide = t.map((t => {
                            const n = t.clone();
                            return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n.side = 1, n
                        })), this.materialsFlatShadedDoubleSide = t.map((t => {
                            const n = t.clone();
                            return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n.side = 2, n
                        }))
                    }
                }
                render(e, t, n) {
                    const i = e.shadowMap.enabled;
                    if (e.shadowMap.enabled = !1, Zl) {
                        const i = this.originalMaterials;
                        this.meshCount = 0, t.traverse(this.replaceMaterial), e.render(t, n);
                        for (const e of i) e[0].material = e[1];
                        this.meshCount !== i.size && i.clear()
                    } else {
                        const i = t.overrideMaterial;
                        t.overrideMaterial = this.material, e.render(t, n), t.overrideMaterial = i
                    }
                    e.shadowMap.enabled = i
                }
                disposeMaterials() {
                    if (null !== this.material) {
                        const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                        for (const t of e) t.dispose()
                    }
                }
                dispose() {
                    this.originalMaterials.clear(), this.disposeMaterials()
                }
                static get workaroundEnabled() {
                    return Zl
                }
                static set workaroundEnabled(e) {
                    Zl = e
                }
            },
            $l = class extends Wl {
                constructor(e, t, n = null) {
                    super("RenderPass", e, t), this.needsSwap = !1, this.clearPass = new Ql, this.overrideMaterialManager = null === n ? null : new Jl(n), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
                }
                get renderToScreen() {
                    return super.renderToScreen
                }
                set renderToScreen(e) {
                    super.renderToScreen = e, this.clearPass.renderToScreen = e
                }
                get overrideMaterial() {
                    const e = this.overrideMaterialManager;
                    return null !== e ? e.material : null
                }
                set overrideMaterial(e) {
                    const t = this.overrideMaterialManager;
                    null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new Jl(e) : null !== t && (t.dispose(), this.overrideMaterialManager = null)
                }
                getOverrideMaterial() {
                    return this.overrideMaterial
                }
                setOverrideMaterial(e) {
                    this.overrideMaterial = e
                }
                get clear() {
                    return this.clearPass.enabled
                }
                set clear(e) {
                    this.clearPass.enabled = e
                }
                getSelection() {
                    return this.selection
                }
                setSelection(e) {
                    this.selection = e
                }
                isBackgroundDisabled() {
                    return this.ignoreBackground
                }
                setBackgroundDisabled(e) {
                    this.ignoreBackground = e
                }
                isShadowMapDisabled() {
                    return this.skipShadowMapUpdate
                }
                setShadowMapDisabled(e) {
                    this.skipShadowMapUpdate = e
                }
                getClearPass() {
                    return this.clearPass
                }
                render(e, t, n, i, r) {
                    const s = this.scene,
                        a = this.camera,
                        o = this.selection,
                        l = a.layers.mask,
                        c = s.background,
                        h = e.shadowMap.autoUpdate,
                        u = this.renderToScreen ? null : t;
                    null !== o && a.layers.set(o.getLayer()), this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (s.background = null), this.clearPass.enabled && this.clearPass.render(e, t), e.setRenderTarget(u), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, s, a) : e.render(s, a), a.layers.mask = l, s.background = c, e.shadowMap.autoUpdate = h
                }
            },
            ec = class extends Wl {
                constructor(e, t, {
                    renderTarget: n,
                    resolutionScale: i = 1,
                    width: r = Kl.AUTO_SIZE,
                    height: s = Kl.AUTO_SIZE,
                    resolutionX: a = r,
                    resolutionY: o = s
                } = {}) {
                    super("DepthPass"), this.needsSwap = !1, this.renderPass = new $l(e, t, new is({
                        depthPacking: 3201
                    }));
                    const l = this.renderPass;
                    l.skipShadowMapUpdate = !0, l.ignoreBackground = !0;
                    const c = l.getClearPass();
                    c.overrideClearColor = new ue(16777215), c.overrideClearAlpha = 1, this.renderTarget = n, void 0 === this.renderTarget && (this.renderTarget = new we(1, 1, {
                        minFilter: h,
                        magFilter: h
                    }), this.renderTarget.texture.name = "DepthPass.Target");
                    const u = this.resolution = new Kl(this, a, o, i);
                    u.addEventListener("change", (e => this.setSize(u.baseWidth, u.baseHeight)))
                }
                get texture() {
                    return this.renderTarget.texture
                }
                getTexture() {
                    return this.renderTarget.texture
                }
                getResolution() {
                    return this.resolution
                }
                getResolutionScale() {
                    return this.resolution.scale
                }
                setResolutionScale(e) {
                    this.resolution.scale = e
                }
                render(e, t, n, i, r) {
                    const s = this.renderToScreen ? null : this.renderTarget;
                    this.renderPass.render(e, s)
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height)
                }
            };

        function tc(e, t, n) {
            for (const i of t) {
                const t = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1),
                    r = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
                for (const e of n.entries()) null !== e[1] && n.set(e[0], e[1].replace(r, t))
            }
        }

        function nc(e, t, n) {
            let i = t.getFragmentShader(),
                r = t.getVertexShader();
            const s = void 0 !== i && /mainImage/.test(i),
                a = void 0 !== i && /mainUv/.test(i);
            if (n.attributes |= t.getAttributes(), void 0 === i) throw new Error(`Missing fragment shader (${t.name})`);
            if (a && 0 != (2 & n.attributes)) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
            if (!s && !a) throw new Error(`Could not find mainImage or mainUv function (${t.name})`); {
                const o = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
                    l = n.shaderParts;
                    let c = l.get(Nl.FRAGMENT_HEAD) ? "" : "";
                    let h = l.get(Nl.FRAGMENT_MAIN_UV) ? "" : "";
                    let u = l.get(Nl.FRAGMENT_MAIN_IMAGE) ? "" : "";
                    let d = l.get(Nl.VERTEX_HEAD) ? "" : "";
                    let p = l.get(Nl.VERTEX_MAIN_SUPPORT) ? "" : "";
                    
                    const f = new Set();
                    const m = new Set();
                    
                if (a && (h += `\t${e}MainUv(UV);\n`, n.uvTransformation = !0), null !== r && /mainSupport/.test(r)) {
                    const t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r);
                    p += `\t${e}MainSupport(`, p += t ? "vUv);\n" : ");\n";
                    for (const e of r.matchAll(/(?:varying\s+\w+\s+(\w*))/g)) n.varyings.add(e[1]), f.add(e[1]), m.add(e[1]);
                    for (const e of r.matchAll(o)) m.add(e[1])
                }
                for (const e of i.matchAll(o)) m.add(e[1]);
                for (const e of t.defines.keys()) m.add(e.replace(/\([\w\s,]*\)/g, ""));
                for (const e of t.uniforms.keys()) m.add(e);
                m.delete("while"), m.delete("for"), m.delete("if"), t.uniforms.forEach(((t, i) => n.uniforms.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))), t.defines.forEach(((t, i) => n.defines.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)));
                const g = new Map([
                    ["fragment", i],
                    ["vertex", r]
                ]);
                tc(e, m, n.defines), tc(e, m, g), i = g.get("fragment"), r = g.get("vertex");
                const v = t.blendMode;
                if (n.blendModes.set(v.blendFunction, v), s) {
                    null !== t.inputColorSpace && t.inputColorSpace !== n.colorSpace && (u += t.inputColorSpace === R ? "color0 = LinearTosRGB(color0);\n\t" : "color0 = sRGBToLinear(color0);\n\t"), null !== t.outputColorSpace ? n.colorSpace = t.outputColorSpace : null !== t.inputColorSpace && (n.colorSpace = t.inputColorSpace);
                    const r = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                    u += `${e}MainImage(color0, UV, `, 0 != (1 & n.attributes) && r.test(i) && (u += "depth, ", n.readDepth = !0), u += "color1);\n\t";
                    const s = e + "BlendOpacity";
                    n.uniforms.set(s, v.opacity), u += `color0 = blend${v.blendFunction}(color0, color1, ${s});\n\n\t`, c += `uniform float ${s};\n\n`
                }
                if (c += i + "\n", null !== r && (d += r + "\n"), l.set(Nl.FRAGMENT_HEAD, c), l.set(Nl.FRAGMENT_MAIN_UV, h), l.set(Nl.FRAGMENT_MAIN_IMAGE, u), l.set(Nl.VERTEX_HEAD, d), l.set(Nl.VERTEX_MAIN_SUPPORT, p), null !== t.extensions)
                    for (const e of t.extensions) n.extensions.add(e)
            }
        }
        new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]);
        var ic = class extends Wl {
                constructor(e, t) {
                    super("MaskPass", e, t), this.needsSwap = !1, this.clearPass = new Ql(!1, !1, !0), this.inverse = !1
                }
                get inverted() {
                    return this.inverse
                }
                set inverted(e) {
                    this.inverse = e
                }
                get clear() {
                    return this.clearPass.enabled
                }
                set clear(e) {
                    this.clearPass.enabled = e
                }
                getClearPass() {
                    return this.clearPass
                }
                isInverted() {
                    return this.inverted
                }
                setInverted(e) {
                    this.inverted = e
                }
                render(e, t, n, i, r) {
                    const s = e.getContext(),
                        a = e.state.buffers,
                        o = this.scene,
                        l = this.camera,
                        c = this.clearPass,
                        h = this.inverted ? 0 : 1,
                        u = 1 - h;
                    a.color.setMask(!1), a.depth.setMask(!1), a.color.setLocked(!0), a.depth.setLocked(!0), a.stencil.setTest(!0), a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.stencil.setFunc(s.ALWAYS, h, 4294967295), a.stencil.setClear(u), a.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(e, null) : (c.render(e, t), c.render(e, n))), this.renderToScreen ? (e.setRenderTarget(null), e.render(o, l)) : (e.setRenderTarget(t), e.render(o, l), e.setRenderTarget(n), e.render(o, l)), a.color.setLocked(!1), a.depth.setLocked(!1), a.stencil.setLocked(!1), a.stencil.setFunc(s.EQUAL, 1, 4294967295), a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.stencil.setLocked(!0)
                }
            },
            rc = class extends Wl {
                constructor(e, t = "inputBuffer") {
                    super("ShaderPass"), this.fullscreenMaterial = e, this.input = t
                }
                setInput(e) {}
                render(e, t, n, i, r) {
                    const s = this.fullscreenMaterial.uniforms;
                    null !== t && void 0 !== s && void 0 !== s[this.input] && (s[this.input].value = t.texture), e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                }
                initialize(e, t, n) {
                    void 0 !== n && n !== m && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                }
            },
            sc = .001,
            ac = class extends Set {
                constructor(e, t = 10) {
                    super(), this.l = t, this.exclusive = !1, void 0 !== e && this.set(e)
                }
                get layer() {
                    return this.l
                }
                set layer(e) {
                    const t = this.l;
                    for (const n of this) n.layers.disable(t), n.layers.enable(e);
                    this.l = e
                }
                getLayer() {
                    return this.layer
                }
                setLayer(e) {
                    this.layer = e
                }
                isExclusive() {
                    return this.exclusive
                }
                setExclusive(e) {
                    this.exclusive = e
                }
                clear() {
                    const e = this.layer;
                    for (const t of this) t.layers.disable(e);
                    return super.clear()
                }
                set(e) {
                    this.clear();
                    for (const t of e) this.add(t);
                    return this
                }
                indexOf(e) {
                    return this.has(e) ? 0 : -1
                }
                add(e) {
                    return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer), super.add(e)
                }
                delete(e) {
                    return this.has(e) && e.layers.disable(this.layer), super.delete(e)
                }
                toggle(e) {
                    let t;
                    return this.has(e) ? (this.delete(e), t = !1) : (this.add(e), t = !0), t
                }
                setVisible(e) {
                    for (const t of this) e ? t.layers.enable(0) : t.layers.disable(0);
                    return this
                }
            },
            oc = new Map([
                [0, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"],
                [1, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"],
                [2, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"],
                [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [4, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"],
                [5, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"],
                [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"],
                [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"],
                [8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"],
                [9, null],
                [10, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"],
                [11, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*x*y,1.0-2.0*(1.0-x)*(1.0-y),step(0.5,y));return mix(x,z,opacity);}"],
                [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"],
                [13, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [14, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"],
                [15, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"],
                [16, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"],
                [17, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"],
                [18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"],
                [19, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"],
                [20, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [21, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"],
                [22, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"],
                [23, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"],
                [24, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"],
                [25, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"],
                [26, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y)),opacity);}"],
                [27, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [28, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-x*y,opacity);}"],
                [29, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"],
                [30, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"],
                [31, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"],
                [32, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(vec4(0.0),1.0-min(vec4(1.0),(1.0-x)/(2.0*y))),min(vec4(1.0),x/(2.0*(1.0-y))),step(0.5,y));return mix(x,z,opacity);}"]
            ]),
            lc = class extends F {
                constructor(e, t = 1) {
                    super(), this._blendFunction = e, this.opacity = new oo(t)
                }
                getOpacity() {
                    return this.opacity.value
                }
                setOpacity(e) {
                    this.opacity.value = e
                }
                get blendFunction() {
                    return this._blendFunction
                }
                set blendFunction(e) {
                    this._blendFunction = e, this.dispatchEvent({
                        type: "change"
                    })
                }
                getBlendFunction() {
                    return this.blendFunction
                }
                setBlendFunction(e) {
                    this.blendFunction = e
                }
                getShaderCode() {
                    return oc.get(this.blendFunction)
                }
            },
            cc = class extends F {
                constructor(e, t, {
                    attributes: n = 0,
                    blendFunction: i = 23,
                    defines: r = new Map,
                    uniforms: s = new Map,
                    extensions: a = null,
                    vertexShader: o = null
                } = {}) {
                    super(), this.name = e, this.renderer = null, this.attributes = n, this.fragmentShader = t, this.vertexShader = o, this.defines = r, this.uniforms = s, this.extensions = a, this.blendMode = new lc(i), this.blendMode.addEventListener("change", (e => this.setChanged())), this._inputColorSpace = P, this._outputColorSpace = null
                }
                get inputColorSpace() {
                    return this._inputColorSpace
                }
                set inputColorSpace(e) {
                    this._inputColorSpace = e, this.setChanged()
                }
                get outputColorSpace() {
                    return this._outputColorSpace
                }
                set outputColorSpace(e) {
                    this._outputColorSpace = e, this.setChanged()
                }
                getName() {
                    return this.name
                }
                setRenderer(e) {
                    this.renderer = e
                }
                getDefines() {
                    return this.defines
                }
                getUniforms() {
                    return this.uniforms
                }
                getExtensions() {
                    return this.extensions
                }
                getBlendMode() {
                    return this.blendMode
                }
                getAttributes() {
                    return this.attributes
                }
                setAttributes(e) {
                    this.attributes = e, this.setChanged()
                }
                getFragmentShader() {
                    return this.fragmentShader
                }
                setFragmentShader(e) {
                    this.fragmentShader = e, this.setChanged()
                }
                getVertexShader() {
                    return this.vertexShader
                }
                setVertexShader(e) {
                    this.vertexShader = e, this.setChanged()
                }
                setChanged() {
                    this.dispatchEvent({
                        type: "change"
                    })
                }
                setDepthTexture(e, t = 3200) {}
                update(e, t, n) {}
                setSize(e, t) {}
                initialize(e, t, n) {}
                dispose() {
                    for (const e of Object.keys(this)) {
                        const t = this[e];
                        if (null !== t && "function" == typeof t.dispose) {
                            if (t instanceof vs || t === this.renderer) continue;
                            this[e].dispose()
                        }
                    }
                }
            };

        function hc(e, t, n) {
            return e + (t - e) * n
        }

        function uc(e, t, n, i) {
            const r = hc(e, t, .75),
                s = hc(n, i, .75);
            return hc(r, s, .875)
        }
        new Me, new tt, new ue, new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array(2), new Float32Array(2), new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]), uc(0, 0, 0, 0), new Float32Array([0, 0, 0, 0]), uc(0, 0, 0, 1), new Float32Array([0, 0, 0, 1]), uc(0, 0, 1, 0), new Float32Array([0, 0, 1, 0]), uc(0, 0, 1, 1), new Float32Array([0, 0, 1, 1]), uc(0, 1, 0, 0), new Float32Array([0, 1, 0, 0]), uc(0, 1, 0, 1), new Float32Array([0, 1, 0, 1]), uc(0, 1, 1, 0), new Float32Array([0, 1, 1, 0]), uc(0, 1, 1, 1), new Float32Array([0, 1, 1, 1]), uc(1, 0, 0, 0), new Float32Array([1, 0, 0, 0]), uc(1, 0, 0, 1), new Float32Array([1, 0, 0, 1]), uc(1, 0, 1, 0), new Float32Array([1, 0, 1, 0]), uc(1, 0, 1, 1), new Float32Array([1, 0, 1, 1]), uc(1, 1, 0, 0), new Float32Array([1, 1, 0, 0]), uc(1, 1, 0, 1), new Float32Array([1, 1, 0, 1]), uc(1, 1, 1, 0), new Float32Array([1, 1, 1, 0]), uc(1, 1, 1, 1), new Float32Array([1, 1, 1, 1]), Math.PI, new Me, new Me;
        var dc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
            pc = "data:image/png;base64,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";

        function fc() {
            return fc = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            }, fc.apply(this, arguments)
        }
        var mc = "#define GLSLIFY 1\nvec3 getViewPosition(const float depth){float clipW=_projectionMatrix[2][3]*depth+_projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(_inverseProjectionMatrix*clipPosition).xyz;}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=_inverseProjectionMatrix*ndc;vec4 view=cameraMatrixWorld*(clip/clip.w);return view.xyz;}\n#define Scale (vec3(0.8, 0.8, 0.8))\n#define K (19.19)\nvec3 hash(vec3 a){a=fract(a*Scale);a+=dot(a,a.yxz+K);return fract((a.xxy+a.yxx)*a.zyx);}float fresnel_dielectric_cos(float cosi,float eta){float c=abs(cosi);float g=eta*eta-1.0+c*c;float result;if(g>0.0){g=sqrt(g);float A=(g-c)/(g+c);float B=(c*(g+c)-1.0)/(c*(g-c)+1.0);result=0.5*A*A*(1.0+B*B);}else{result=1.0;}return result;}float fresnel_dielectric(vec3 Incoming,vec3 Normal,float eta){float cosine=dot(Incoming,Normal);return min(1.0,5.0*fresnel_dielectric_cos(cosine,eta));}float czm_luminance(vec3 rgb){const vec3 W=vec3(0.2125,0.7154,0.0721);return dot(rgb,W);}";
        class gc extends Sn {
            constructor() {
                super({
                    type: "MRTMaterial",
                    defines: {
                        USE_UV: "",
                        TEMPORAL_RESOLVE: ""
                    },
                    uniforms: {
                        opacity: new oo(1),
                        normalMap: new oo(null),
                        normalScale: new oo(new Z(1, 1)),
                        uvTransform: new oo(new J),
                        roughness: new oo(1),
                        roughnessMap: new oo(null)
                    },
                    vertexShader: "\n                 #ifdef USE_MRT\n                out vec2 vHighPrecisionZW;\n                #endif\n                #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <common>\n                #include <uv_pars_vertex>\n                #include <displacementmap_pars_vertex>\n                #include <normal_pars_vertex>\n                #include <morphtarget_pars_vertex>\n                #include <skinning_pars_vertex>\n                #include <logdepthbuf_pars_vertex>\n                #include <clipping_planes_pars_vertex>\n                void main() {\n                    #include <uv_vertex>\n                    #include <beginnormal_vertex>\n                    #include <morphnormal_vertex>\n                    #include <skinbase_vertex>\n                    #include <skinnormal_vertex>\n                    #include <defaultnormal_vertex>\n                    #include <normal_vertex>\n                    #include <begin_vertex>\n                    #include <morphtarget_vertex>\n                    #include <skinning_vertex>\n                    #include <displacementmap_vertex>\n                    #include <project_vertex>\n                    #include <logdepthbuf_vertex>\n                    #include <clipping_planes_vertex>\n                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                        vViewPosition = - mvPosition.xyz;\n                    #endif\n                    #ifdef USE_MRT\n                        vHighPrecisionZW = gl_Position.zw;\n                    #endif \n                    #ifdef USE_UV\n                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n                    #endif\n                }\n            ",
                    fragmentShader: "\n                 #define NORMAL\n                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n                    varying vec3 vViewPosition;\n                #endif\n                #include <packing>\n                #include <uv_pars_fragment>\n                #include <normal_pars_fragment>\n                #include <bumpmap_pars_fragment>\n                #include <normalmap_pars_fragment>\n                #include <logdepthbuf_pars_fragment>\n                #include <clipping_planes_pars_fragment>\n                #include <roughnessmap_pars_fragment>\n                \n                #ifdef USE_MRT\n                layout(location = 0) out vec4 gNormal;\n                layout(location = 1) out vec4 gDepth;\n                \n                in vec2 vHighPrecisionZW;\n                #endif\n                uniform float roughness;\n                void main() {\n                    #include <clipping_planes_fragment>\n                    #include <logdepthbuf_fragment>\n                    #include <normal_fragment_begin>\n                    #include <normal_fragment_maps>\n\n                    float roughnessFactor = roughness;\n                    \n                    if(roughness > 10.0e9){\n                        roughnessFactor = 1.;\n                    }else{\n                        #ifdef USE_ROUGHNESSMAP\n                            vec4 texelRoughness = texture2D( roughnessMap, vUv );\n                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n                            roughnessFactor *= texelRoughness.g;\n                        #endif\n                    }\n\n                    vec3 normalColor = packNormalToRGB( normal );\n                    #ifdef USE_MRT\n                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n                        vec4 depthColor = packDepthToRGBA( fragCoordZ );\n                        gNormal = vec4( normalColor, roughnessFactor );\n                        gDepth = depthColor;\n                    #else\n                        gl_FragColor = vec4(normalColor, roughnessFactor);\n                    #endif\n                }\n            ",
                    toneMapped: !1
                }), this.normalMapType = 0, this.normalScale = new Z(1, 1), Object.defineProperty(this, "glslVersion", {
                    get() {
                        return "USE_MRT" in this.defines ? k : null
                    },
                    set(e) {}
                })
            }
        }
        var vc = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
        class xc extends Sn {
            constructor() {
                super({
                    type: "ReflectionsMaterial",
                    uniforms: {
                        inputTexture: new oo(null),
                        accumulatedTexture: new oo(null),
                        normalTexture: new oo(null),
                        depthTexture: new oo(null),
                        _projectionMatrix: new oo(new tt),
                        _inverseProjectionMatrix: new oo(new tt),
                        cameraMatrixWorld: new oo(new tt),
                        cameraNear: new oo(0),
                        cameraFar: new oo(0),
                        rayDistance: new oo(0),
                        intensity: new oo(0),
                        roughnessFadeOut: new oo(0),
                        rayFadeOut: new oo(0),
                        thickness: new oo(0),
                        ior: new oo(0),
                        maxDepthDifference: new oo(0),
                        jitter: new oo(0),
                        jitterRough: new oo(0),
                        jitterSpread: new oo(0),
                        maxRoughness: new oo(0),
                        samples: new oo(0)
                    },
                    defines: {
                        MAX_STEPS: 20,
                        NUM_BINARY_SEARCH_STEPS: 5
                    },
                    fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform mat4 _projectionMatrix;uniform mat4 _inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float rayDistance;uniform float intensity;uniform float maxDepthDifference;uniform float roughnessFadeOut;uniform float maxRoughness;uniform float rayFadeOut;uniform float thickness;uniform float ior;uniform float samples;uniform float jitter;uniform float jitterRough;uniform float jitterSpread;\n#define FLOAT_EPSILON 0.00001\n#define EARLY_OUT_COLOR vec4(0., 0., 0., 1.)\nconst vec2 INVALID_RAY_COORDS=vec2(-1.);float _maxDepthDifference;float nearMinusFar;float nearMulFar;float farMinusNear;\n#include <packing>\n#include <helperFunctions>\nvec2 BinarySearch(inout vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);float fastGetViewZ(const in float depth);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.);if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON){gl_FragColor=EARLY_OUT_COLOR;return;}float unpackedDepth=unpackRGBAToDepth(depthTexel);vec4 normalTexel=textureLod(normalTexture,vUv,0.);float roughness=normalTexel.a;if(roughness>maxRoughness||(roughness>1.-FLOAT_EPSILON&&roughnessFadeOut>1.-FLOAT_EPSILON)){gl_FragColor=EARLY_OUT_COLOR;return;}float specular=1.-roughness;_maxDepthDifference=maxDepthDifference*0.01;nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;normalTexel.rgb=unpackRGBToNormal(normalTexel.rgb);float depth=fastGetViewZ(unpackedDepth);vec3 viewNormal=normalTexel.xyz;vec3 viewPos=getViewPosition(depth);vec3 worldPos=screenSpaceToWorldSpace(vUv,unpackedDepth);vec3 jitt=vec3(0.);if(jitterSpread!=0.&&(jitterRough!=0.||jitter==0.)){vec3 randomJitter=hash(5.*(samples*worldPos))-0.5;float spread=((2.-specular)+roughness*jitterRough)*jitterSpread;float jitterMix=jitter+jitterRough*roughness;if(jitterMix>1.)jitterMix=1.;jitt=mix(vec3(0.),randomJitter*spread,jitterMix);}viewNormal+=jitt;vec3 reflected=reflect(normalize(viewPos),normalize(viewNormal));vec3 rayDir=reflected*-viewPos.z;vec3 hitPos=viewPos;float rayHitDepthDifference;vec2 coords=RayMarch(rayDir,hitPos,rayHitDepthDifference);if(coords.x==-1.){gl_FragColor=EARLY_OUT_COLOR;return;}vec2 coordsNDC=(coords*2.0-1.0);float screenFade=0.1;float maxDimension=min(1.0,max(abs(coordsNDC.x),abs(coordsNDC.y)));float screenEdgefactor=1.0-(max(0.0,maxDimension-screenFade)/(1.0-screenFade));screenEdgefactor=max(0.,screenEdgefactor);vec4 SSRTexel=textureLod(inputTexture,coords.xy,0.);vec4 SSRTexelReflected=textureLod(accumulatedTexture,coords.xy,0.);vec3 SSR=SSRTexel.rgb+SSRTexelReflected.rgb;float roughnessFactor=mix(specular,1.,max(0.,1.-roughnessFadeOut));vec3 finalSSR=SSR*screenEdgefactor*roughnessFactor;if(rayFadeOut!=0.){vec3 hitWorldPos=screenSpaceToWorldSpace(coords,rayHitDepthDifference);float reflectionDistance=distance(hitWorldPos,worldPos);reflectionDistance+=1.;float opacity=1./(reflectionDistance*rayFadeOut*0.1);if(opacity>1.)opacity=1.;finalSSR*=opacity;}float fresnelFactor=fresnel_dielectric(normalize(viewPos),viewNormal,ior);finalSSR=finalSSR*fresnelFactor*intensity;finalSSR=min(vec3(1.),finalSSR);float alpha=hitPos.z==1. ? SSRTexel.a : SSRTexelReflected.a;gl_FragColor=vec4(finalSSR,alpha);}vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){dir=normalize(dir);dir*=rayDistance/float(MAX_STEPS);float depth;vec4 projectedCoord;vec4 lastProjectedCoord;float unpackedDepth;float stepMultiplier=1.;vec4 depthTexel;for(int i=0;i<MAX_STEPS;i++){hitPos+=dir*stepMultiplier;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;if(projectedCoord.x>1.||projectedCoord.y>1.){hitPos-=dir*stepMultiplier;stepMultiplier*=0.5;}else{depthTexel=textureLod(depthTexture,projectedCoord.xy,0.);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.&&rayHitDepthDifference<thickness){\n#if NUM_BINARY_SEARCH_STEPS == 0\nif(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;\n#else\nreturn BinarySearch(dir,hitPos,rayHitDepthDifference);\n#endif\n}lastProjectedCoord=projectedCoord;}}\n#ifndef ALLOW_MISSED_RAYS\nreturn INVALID_RAY_COORDS;\n#endif\nrayHitDepthDifference=unpackedDepth;hitPos.z=1.;return projectedCoord.xy;}vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){float depth;vec4 projectedCoord;vec2 lastMinProjectedCoordXY;float unpackedDepth;vec4 depthTexel;for(int i=0;i<NUM_BINARY_SEARCH_STEPS;i++){projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;if((lastMinProjectedCoordXY.x>1.||lastMinProjectedCoordXY.y>1.)&&(projectedCoord.x>1.||projectedCoord.y>1.))return INVALID_RAY_COORDS;depthTexel=textureLod(depthTexture,projectedCoord.xy,0.);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;if(rayHitDepthDifference>0.0){hitPos-=dir;}else{hitPos+=dir;lastMinProjectedCoordXY=projectedCoord.xy;}}if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;if(abs(rayHitDepthDifference)>_maxDepthDifference)return INVALID_RAY_COORDS;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;rayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}float fastGetViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}".replace("#include <helperFunctions>", mc),
                    vertexShader: vc,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1
                })
            }
        }
        const wc = e => {
            const t = [e],
                n = [];
            for (; 0 !== t.length;) {
                const e = t.shift();
                e.material && n.push(e);
                for (const n of e.children) n.visible && t.push(n)
            }
            return n
        };
        class bc extends Wl {
            constructor(e, t = {}) {
                super("ReflectionsPass"), this.ssrEffect = void 0, this.cachedMaterials = new WeakMap, this.USE_MRT = !1, this.webgl1DepthPass = null, this.visibleMeshes = [], this.ssrEffect = e, this._scene = e._scene, this._camera = e._camera, this.fullscreenMaterial = new xc, e._camera.isPerspectiveCamera && (this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "");
                const n = t.width || "undefined" != typeof window ? window.innerWidth : 2e3,
                    i = t.height || "undefined" != typeof window ? window.innerHeight : 1e3;
                this.renderTarget = new we(n, i, {
                    minFilter: p,
                    magFilter: p,
                    depthBuffer: !1
                }), this.renderPass = new $l(this._scene, this._camera), this.USE_MRT = t.USE_MRT && (() => {
                    try {
                        const e = document.createElement("canvas");
                        return !(!window.WebGL2RenderingContext || !e.getContext("webgl2"))
                    } catch (e) {
                        return !1
                    }
                })(), this.USE_MRT ? (this.gBuffersRenderTarget = new ye(n, i, 2, {
                    minFilter: p,
                    magFilter: p
                }), this.normalTexture = this.gBuffersRenderTarget.texture[0], this.depthTexture = this.gBuffersRenderTarget.texture[1]) : (this.webgl1DepthPass = new ec(this._scene, this._camera), this.webgl1DepthPass.renderTarget.minFilter = p, this.webgl1DepthPass.renderTarget.magFilter = p, this.webgl1DepthPass.renderTarget.texture.minFilter = p, this.webgl1DepthPass.renderTarget.texture.magFilter = p, this.webgl1DepthPass.setSize("undefined" != typeof window ? window.innerWidth : 2e3, "undefined" != typeof window ? window.innerHeight : 1e3), this.gBuffersRenderTarget = new we(n, i, {
                    minFilter: p,
                    magFilter: p
                }), this.normalTexture = this.gBuffersRenderTarget.texture, this.depthTexture = this.webgl1DepthPass.texture), this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture, this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture, this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture, this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld, this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix, this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse
            }
            setSize(e, t) {
                this.renderTarget.setSize(e * this.ssrEffect.resolutionScale, t * this.ssrEffect.resolutionScale), this.gBuffersRenderTarget.setSize(e * this.ssrEffect.resolutionScale, t * this.ssrEffect.resolutionScale), this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture, this.fullscreenMaterial.needsUpdate = !0
            }
            dispose() {
                this.renderTarget.dispose(), this.gBuffersRenderTarget.dispose(), this.renderPass.dispose(), this.USE_MRT || this.webgl1DepthPass.dispose(), this.fullscreenMaterial.dispose(), this.normalTexture = null, this.depthTexture = null, this.velocityTexture = null
            }
            keepMaterialMapUpdated(e, t, n, i) {
                this.ssrEffect[i] ? t[n] !== e[n] && (e[n] = t[n], e.uniforms[n].value = t[n], t[n] ? e.defines[i] = "" : delete e.defines[i], e.needsUpdate = !0) : void 0 !== e[n] && (e[n] = void 0, e.uniforms[n].value = void 0, delete e.defines[i], e.needsUpdate = !0)
            }
            setMRTMaterialInScene() {
                this.visibleMeshes = wc(this._scene);
                for (const e of this.visibleMeshes)
                    if (e.material) {
                        const t = e.material;
                        let [n, i] = this.cachedMaterials.get(e) || [];
                        if (t !== n) {
                            i && i.dispose(), i = new gc, this.USE_MRT && (i.defines.USE_MRT = ""), i.normalScale = t.normalScale, i.uniforms.normalScale.value = t.normalScale;
                            const n = t.map || t.normalMap || t.roughnessMap || t.metalnessMap;
                            n && (i.uniforms.uvTransform.value = n.matrix), this.cachedMaterials.set(e, [t, i])
                        }
                        this.keepMaterialMapUpdated(i, t, "normalMap", "USE_NORMALMAP"), this.keepMaterialMapUpdated(i, t, "roughnessMap", "USE_ROUGHNESSMAP"), i.uniforms.roughness.value = 0 === this.ssrEffect.selection.size || this.ssrEffect.selection.has(e) ? t.roughness || 0 : 1e11, e.material = i
                    }
            }
            unsetMRTMaterialInScene() {
                for (const t of this.visibleMeshes) {
                    var e;
                    if ("MRTMaterial" === (null == (e = t.material) ? void 0 : e.type)) {
                        t.visible = !0;
                        const [e] = this.cachedMaterials.get(t);
                        t.material = e
                    }
                }
            }
            render(e, t) {
                this.setMRTMaterialInScene(), e.setRenderTarget(this.gBuffersRenderTarget), this.renderPass.render(e, this.gBuffersRenderTarget), this.unsetMRTMaterialInScene(), this.USE_MRT || this.webgl1DepthPass.renderPass.render(e, this.webgl1DepthPass.renderTarget), this.fullscreenMaterial.uniforms.inputTexture.value = t.texture, this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.samples, this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near, this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far, e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera)
            }
        }
        const _c = {
            temporalResolve: !0,
            temporalResolveMix: .9,
            temporalResolveCorrection: 1,
            resolutionScale: 1,
            velocityResolutionScale: 1,
            width: "undefined" != typeof window ? window.innerWidth : 1e3,
            height: "undefined" != typeof window ? window.innerHeight : 1e3,
            blurMix: .5,
            blurSharpness: 10,
            blurKernelSize: 1,
            rayDistance: 10,
            intensity: 1,
            colorExponent: 1,
            maxRoughness: 1,
            jitter: 0,
            jitterSpread: 0,
            jitterRough: 0,
            roughnessFadeOut: 1,
            rayFadeOut: 0,
            MAX_STEPS: 20,
            NUM_BINARY_SEARCH_STEPS: 5,
            maxDepthDifference: 10,
            thickness: 10,
            ior: 1.45,
            CLAMP_RADIUS: 1,
            ALLOW_MISSED_RAYS: !0,
            USE_MRT: !0,
            USE_NORMALMAP: !0,
            USE_ROUGHNESSMAP: !0
        };
        var yc = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D velocityTexture;uniform sampler2D lastVelocityTexture;uniform float temporalResolveCorrection;uniform vec2 invTexSize;uniform float colorExponent;varying vec2 vUv;\n#include <packing>\n#ifdef DILATION\nvec4 getDilatedTexture(sampler2D tex,vec2 uv,vec2 invTexSize){float closestDepth=0.;vec2 closestNeighborUv;vec2 neighborUv;float neighborDepth;for(int x=-1;x<=1;x++){for(int y=-1;y<=1;y++){neighborUv=vUv+vec2(x,y)*invTexSize;neighborDepth=textureLod(tex,neighborUv,0.).b;if(neighborDepth>closestDepth){closestNeighborUv=neighborUv;closestDepth=neighborDepth;}}}return textureLod(tex,closestNeighborUv,0.);}\n#endif\nvec3 transformColorExponent;vec3 undoColorTransformExponent;vec3 transformColor(vec3 color){if(colorExponent==1.)return color;return pow(color,transformColorExponent);}vec3 undoColorTransform(vec3 color){if(colorExponent==1.)return color;return pow(color,undoColorTransformExponent);}void main(){transformColorExponent=vec3(1./colorExponent);undoColorTransformExponent=vec3(colorExponent);vec4 inputTexel=textureLod(inputTexture,vUv,0.);vec3 inputColor=transformColor(inputTexel.rgb);vec3 accumulatedColor;vec3 outputColor;vec4 velocity;vec2 lastVelUv;\n#ifdef DILATION\nvelocity=getDilatedTexture(velocityTexture,vUv,invTexSize);\n#else\nvelocity=textureLod(velocityTexture,vUv,0.);\n#endif\nvec2 velUv=velocity.xy;vec2 reprojectedUv=vUv-velUv;float velocityLength=length(lastVelUv-velUv);\n#ifdef DILATION\nlastVelUv=getDilatedTexture(lastVelocityTexture,reprojectedUv,invTexSize).xy;\n#else\nlastVelUv=textureLod(lastVelocityTexture,reprojectedUv,0.).xy;\n#endif\nfloat velocityDisocclusion=(velocityLength-0.000005)*10.;velocityDisocclusion*=velocityDisocclusion;bool canReproject=reprojectedUv.x>=0.&&reprojectedUv.x<=1.&&reprojectedUv.y>=0.&&reprojectedUv.y<=1.;float movement=length(velUv)*100.;bool isMoving=velocityDisocclusion>0.001||movement>0.001;float alpha=inputTexel.a;if(isMoving){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;vec2 neighborUv;vec3 col;vec3 boxBlurredColor;for(int x=-CLAMP_RADIUS;x<=CLAMP_RADIUS;x++){for(int y=-CLAMP_RADIUS;y<=CLAMP_RADIUS;y++){if(x!=0||y!=0){neighborUv=vUv+vec2(x,y)*invTexSize;col=textureLod(inputTexture,neighborUv,0.).xyz;col=transformColor(col);if(canReproject){minNeighborColor=min(col,minNeighborColor);maxNeighborColor=max(col,maxNeighborColor);}else{boxBlurredColor+=col;}}}}if(canReproject){vec4 accumulatedTexel=textureLod(accumulatedTexture,reprojectedUv,0.);accumulatedColor=transformColor(accumulatedTexel.rgb);vec3 clampedColor=clamp(accumulatedColor,minNeighborColor,maxNeighborColor);float mixFactor=temporalResolveCorrection*(1.+movement);mixFactor=min(mixFactor,1.);accumulatedColor=mix(accumulatedColor,clampedColor,mixFactor);}else{float pxRadius=pow(float(CLAMP_RADIUS*2+1),2.);accumulatedColor=boxBlurredColor/pxRadius;}}else{accumulatedColor=transformColor(textureLod(accumulatedTexture,vUv,0.).rgb);}if(velocity.r>1.-FLOAT_EPSILON&&velocity.g>1.-FLOAT_EPSILON){alpha=0.;velocityDisocclusion=10.0e10;movement=10.0e10;}\n#include <custom_compose_shader>\ngl_FragColor=vec4(undoColorTransform(outputColor),1.);}";
        const Ac = `\n\t\tvec3 transformed;\n\n\t\t// Get the normal\n\t\t${Hn.skinbase_vertex}\n\t\t${Hn.beginnormal_vertex}\n\t\t${Hn.skinnormal_vertex}\n\t\t${Hn.defaultnormal_vertex}\n\n\t\t// Get the current vertex position\n\t\ttransformed = vec3( position );\n\t\t${Hn.skinning_vertex}\n\t\tnewPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n\t\t// Get the previous vertex position\n\t\ttransformed = vec3( position );\n\t\t${Hn.skinbase_vertex.replace(/mat4 /g,"").replace(/getBoneMatrix/g,"getPrevBoneMatrix")}\n\t\t${Hn.skinning_vertex.replace(/vec4 /g,"")}\n\t\tprevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\n\t\tgl_Position = newPosition;\n`;
        class Mc extends Sn {
            constructor() {
                super({
                    uniforms: {
                        prevVelocityMatrix: {
                            value: new tt
                        },
                        velocityMatrix: {
                            value: new tt
                        },
                        prevBoneTexture: {
                            value: null
                        },
                        interpolateGeometry: {
                            value: 0
                        },
                        intensity: {
                            value: 1
                        },
                        boneTexture: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: `\n                    #define MAX_BONES 1024\n                    \n                    ${Hn.skinning_pars_vertex}\n                    \n\t\t#ifdef USE_SKINNING\n\t\t#ifdef BONE_TEXTURE\n\t\t\tuniform sampler2D prevBoneTexture;\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tfloat j = i * 4.0;\n\t\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\t\ty = dy * ( y + 0.5 );\n\t\t\t\tvec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\t\tvec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\t\tvec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\t\tvec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#else\n\t\t\tuniform mat4 prevBoneMatrices[ MAX_BONES ];\n\t\t\tmat4 getPrevBoneMatrix( const in float i ) {\n\t\t\t\tmat4 bone = prevBoneMatrices[ int(i) ];\n\t\t\t\treturn bone;\n\t\t\t}\n\t\t#endif\n\t\t#endif\n\n        \n                    uniform mat4 velocityMatrix;\n                    uniform mat4 prevVelocityMatrix;\n                    uniform float interpolateGeometry;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n        \n                    void main() {\n        \n                        ${Ac}\n        \n                    }`,
                    fragmentShader: "\n                    uniform float intensity;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n        \n                    void main() {\n\t\t\t\t\t\t#ifdef FULL_MOVEMENT\n\t\t\t\t\t\tgl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\t#endif\n\n                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\n                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n        \n                        vec2 vel = pos1 - pos0;\n                        \n                        gl_FragColor = vec4( vel, 1. - gl_FragCoord.z, 0. );\n        \n                    }"
                }), this.isMeshVelocityMaterial = !0
            }
        }
        const Sc = new ue(0),
            Ec = ["visible", "wireframe", "side"];
        class Tc extends Wl {
            constructor(e, t) {
                var n, i;
                super("VelocityPass"), this.cachedMaterials = new WeakMap, this.lastCameraTransform = {
                    position: new Me,
                    quaternion: new Ae
                }, this.visibleMeshes = [], this.renderedMeshesThisFrame = 0, this.renderedMeshesLastFrame = 0, this._scene = e, this._camera = t, this.renderTarget = new we((null == (n = window) ? void 0 : n.innerWidth) || 1e3, (null == (i = window) ? void 0 : i.innerHeight) || 1e3, {
                    minFilter: p,
                    magFilter: p,
                    type: x
                })
            }
            setVelocityMaterialInScene() {
                this.renderedMeshesThisFrame = 0, this.visibleMeshes = wc(this._scene);
                for (const n of this.visibleMeshes) {
                    var e;
                    const i = n.material;
                    let [r, s] = this.cachedMaterials.get(n) || [];
                    var t;
                    i !== r && (s = new Mc, s.lastMatrixWorld = new tt, null != (t = n.skeleton) && t.boneTexture && this.saveBoneTexture(n), this.cachedMaterials.set(n, [i, s])), s.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, n.modelViewMatrix), n.userData.needsUpdatedReflections || i.map instanceof Ks ? ("FULL_MOVEMENT" in s.defines || (s.needsUpdate = !0), s.defines.FULL_MOVEMENT = "") : "FULL_MOVEMENT" in s.defines && (delete s.defines.FULL_MOVEMENT, s.needsUpdate = !0);
                    const a = !n.matrixWorld.equals(s.lastMatrixWorld);
                    if (n.visible = this.cameraMovedThisFrame || a || n.skeleton || "FULL_MOVEMENT" in s.defines, n.material = s, n.visible) {
                        this.renderedMeshesThisFrame++;
                        for (const e of Ec) s[e] = i[e];
                        null != (e = n.skeleton) && e.boneTexture && (s.defines.USE_SKINNING = "", s.defines.BONE_TEXTURE = "", s.uniforms.boneTexture.value = n.skeleton.boneTexture)
                    }
                }
            }
            saveBoneTexture(e) {
                let t = e.material.uniforms.prevBoneTexture.value;
                if (t && t.image.width === e.skeleton.boneTexture.width) t = e.material.uniforms.prevBoneTexture.value, t.image.data.set(e.skeleton.boneTexture.image.data);
                else {
                    var n;
                    null == (n = t) || n.dispose();
                    const i = e.skeleton.boneTexture.image.data.slice(),
                        r = e.skeleton.boneTexture.image.width;
                    t = new Cs(i, r, r, b, v), e.material.uniforms.prevBoneTexture.value = t, t.needsUpdate = !0
                }
            }
            unsetVelocityMaterialInScene() {
                for (const t of this.visibleMeshes) {
                    var e;
                    t.material.isMeshVelocityMaterial && (t.visible = !0, t.material.lastMatrixWorld.copy(t.matrixWorld), t.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, t.modelViewMatrix), null != (e = t.skeleton) && e.boneTexture && this.saveBoneTexture(t), t.material = this.cachedMaterials.get(t)[0])
                }
            }
            setSize(e, t) {
                this.renderTarget.setSize(e, t)
            }
            renderVelocity(e) {
                if (e.setRenderTarget(this.renderTarget), this.renderedMeshesThisFrame > 0) {
                    const {
                        background: t
                    } = this._scene;
                    this._scene.background = Sc, e.render(this._scene, this._camera), this._scene.background = t
                } else e.clearColor()
            }
            checkCameraMoved() {
                const e = this.lastCameraTransform.position.distanceToSquared(this._camera.position),
                    t = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));
                return (e > 1e-6 || t > 1e-6) && (this.lastCameraTransform.position.copy(this._camera.position), this.lastCameraTransform.quaternion.copy(this._camera.quaternion), !0)
            }
            render(e) {
                this.cameraMovedThisFrame = this.checkCameraMoved(), this.setVelocityMaterialInScene(), (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) && this.renderVelocity(e), this.unsetVelocityMaterialInScene(), this.renderedMeshesLastFrame = this.renderedMeshesThisFrame
            }
        }
        const Cc = new Z;
        class Dc extends Wl {
            constructor(e, t, n, i = {}) {
                super("TemporalResolvePass"), this.velocityPass = null, this.velocityResolutionScale = 1, this._scene = e;
                const r = i.width || "undefined" != typeof window ? window.innerWidth : 2e3,
                    s = i.height || "undefined" != typeof window ? window.innerHeight : 1e3;
                this.renderTarget = new we(r, s, {
                    minFilter: p,
                    magFilter: p,
                    type: x,
                    depthBuffer: !1
                }), this.velocityPass = new Tc(e, t);
                const a = yc.replace("#include <custom_compose_shader>", n);
                this.fullscreenMaterial = new Sn({
                    type: "TemporalResolveMaterial",
                    uniforms: {
                        inputTexture: new oo(null),
                        accumulatedTexture: new oo(null),
                        velocityTexture: new oo(this.velocityPass.renderTarget.texture),
                        lastVelocityTexture: new oo(null),
                        depthTexture: new oo(null),
                        temporalResolveMix: new oo(0),
                        temporalResolveCorrection: new oo(0),
                        colorExponent: new oo(1),
                        invTexSize: new oo(new Z)
                    },
                    defines: {
                        CLAMP_RADIUS: 1
                    },
                    vertexShader: vc,
                    fragmentShader: a
                }), this.fullscreenMaterial.defines.DILATION = "", e.userData.velocityTexture || (e.userData.velocityTexture = this.velocityPass.renderTarget.texture), this.setupAccumulatedTexture(r, s)
            }
            dispose() {
                this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture && delete this._scene.userData.velocityTexture, this.renderTarget.dispose(), this.accumulatedTexture.dispose(), this.fullscreenMaterial.dispose(), this.velocityPass.dispose()
            }
            setSize(e, t) {
                this.renderTarget.setSize(e, t), this.velocityPass.setSize(e * this.velocityResolutionScale, t * this.velocityResolutionScale), this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / e, 1 / t), this.setupAccumulatedTexture(e, t)
            }
            setupAccumulatedTexture(e, t) {
                this.accumulatedTexture && this.accumulatedTexture.dispose(), this.lastVelocityTexture && this.lastVelocityTexture.dispose(), this.accumulatedTexture = new Zs(e, t, b), this.accumulatedTexture.minFilter = p, this.accumulatedTexture.magFilter = p, this.accumulatedTexture.type = x, this.lastVelocityTexture = new Zs(e * this.velocityResolutionScale, t * this.velocityResolutionScale, b), this.lastVelocityTexture.minFilter = p, this.lastVelocityTexture.magFilter = p, this.lastVelocityTexture.type = x, this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture, this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture, this.fullscreenMaterial.needsUpdate = !0
            }
            render(e) {
                this.velocityPass.render(e), e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera), e.copyFramebufferToTexture(Cc, this.accumulatedTexture), e.setRenderTarget(this.velocityPass.renderTarget), e.copyFramebufferToTexture(Cc, this.lastVelocityTexture)
            }
        }
        const Pc = "#define GLSLIFY 1\n#define MODE_DEFAULT 0\n#define MODE_REFLECTIONS 1\n#define MODE_RAW_REFLECTION 2\n#define MODE_BLURRED_REFLECTIONS 3\n#define MODE_INPUT 4\n#define MODE_BLUR_MIX 5\n#define FLOAT_EPSILON 0.00001\nuniform sampler2D inputTexture;uniform sampler2D reflectionsTexture;uniform float samples;\n#include <boxBlur>\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 reflectionsTexel=texture2D(reflectionsTexture,vUv);vec3 reflectionClr=reflectionsTexel.xyz;if(blurMix>FLOAT_EPSILON){ivec2 size=textureSize(reflectionsTexture,0);vec2 pxSize=vec2(float(size.x),float(size.y));vec3 blurredReflectionsColor=denoise(reflectionsTexel.rgb,reflectionsTexture,vUv,pxSize);reflectionClr=mix(reflectionClr,blurredReflectionsColor.rgb,blurMix);}\n#if RENDER_MODE == MODE_DEFAULT\noutputColor=vec4(inputColor.rgb+reflectionClr,1.);\n#endif\n#if RENDER_MODE == MODE_REFLECTIONS\noutputColor=vec4(reflectionClr,1.);\n#endif\n#if RENDER_MODE == MODE_RAW_REFLECTION\noutputColor=vec4(reflectionsTexel.xyz,1.);\n#endif\n#if RENDER_MODE == MODE_BLURRED_REFLECTIONS\noutputColor=vec4(blurredReflectionsTexel.xyz,1.);\n#endif\n#if RENDER_MODE == MODE_INPUT\noutputColor=vec4(inputColor.xyz,1.);\n#endif\n#if RENDER_MODE == MODE_BLUR_MIX\noutputColor=vec4(vec3(blurMix),1.);\n#endif\n}".replace("#include <helperFunctions>", mc).replace("#include <boxBlur>", "#define GLSLIFY 1\nuniform float blurMix;uniform float blurSharpness;uniform int blurKernelSize;vec3 denoise(vec3 center,sampler2D tex,vec2 uv,vec2 texSize){vec3 color;float total;vec3 col;float weight;for(int x=-blurKernelSize;x<=blurKernelSize;x++){for(int y=-blurKernelSize;y<=blurKernelSize;y++){col=textureLod(tex,uv+vec2(x,y)/texSize,0.).rgb;weight=1.0-abs(dot(col-center,vec3(0.25)));weight=pow(weight,blurSharpness);color+=col*weight;total+=weight;}}return color/total;}"),
            Rc = ["blurMix", "blurSharpness", "blurKernelSize"];
        var Lc = {},
            Ic = function(e) {
                return URL.createObjectURL(new Blob([e], {
                    type: "text/javascript"
                }))
            },
            Bc = function(e) {
                return new Worker(e)
            };
        try {
            URL.revokeObjectURL(Ic(""))
        } catch (yl) {
            Ic = function(e) {
                return "data:application/javascript;charset=UTF-8," + encodeURI(e)
            }, Bc = function(e) {
                return new Worker(e, {
                    type: "module"
                })
            }
        }
        var Oc = Uint8Array,
            kc = Uint16Array,
            Nc = Uint32Array,
            Fc = new Oc([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
            Uc = new Oc([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
            zc = new Oc([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            Vc = function(e, t) {
                for (var n = new kc(31), i = 0; i < 31; ++i) n[i] = t += 1 << e[i - 1];
                var r = new Nc(n[30]);
                for (i = 1; i < 30; ++i)
                    for (var s = n[i]; s < n[i + 1]; ++s) r[s] = s - n[i] << 5 | i;
                return [n, r]
            },
            Hc = Vc(Fc, 2),
            Gc = Hc[0],
            Wc = Hc[1];
        Gc[28] = 258, Wc[258] = 28;
        for (var jc = Vc(Uc, 0), Yc = jc[0], Xc = jc[1], Qc = new kc(32768), qc = 0; qc < 32768; ++qc) {
            var Kc = (43690 & qc) >>> 1 | (21845 & qc) << 1;
            Kc = (61680 & (Kc = (52428 & Kc) >>> 2 | (13107 & Kc) << 2)) >>> 4 | (3855 & Kc) << 4, Qc[qc] = ((65280 & Kc) >>> 8 | (255 & Kc) << 8) >>> 1
        }
        var Zc = function(e, t, n) {
                for (var i = e.length, r = 0, s = new kc(t); r < i; ++r) ++s[e[r] - 1];
                var a, o = new kc(t);
                for (r = 0; r < t; ++r) o[r] = o[r - 1] + s[r - 1] << 1;
                if (n) {
                    a = new kc(1 << t);
                    var l = 15 - t;
                    for (r = 0; r < i; ++r)
                        if (e[r])
                            for (var c = r << 4 | e[r], h = t - e[r], u = o[e[r] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u) a[Qc[u] >>> l] = c
                } else
                    for (a = new kc(i), r = 0; r < i; ++r) e[r] && (a[r] = Qc[o[e[r] - 1]++] >>> 15 - e[r]);
                return a
            },
            Jc = new Oc(288);
        for (qc = 0; qc < 144; ++qc) Jc[qc] = 8;
        for (qc = 144; qc < 256; ++qc) Jc[qc] = 9;
        for (qc = 256; qc < 280; ++qc) Jc[qc] = 7;
        for (qc = 280; qc < 288; ++qc) Jc[qc] = 8;
        var $c = new Oc(32);
        for (qc = 0; qc < 32; ++qc) $c[qc] = 5;
        var eh = Zc(Jc, 9, 0),
            th = Zc(Jc, 9, 1),
            nh = Zc($c, 5, 0),
            ih = Zc($c, 5, 1),
            rh = function(e) {
                for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
                return t
            },
            sh = function(e, t, n) {
                var i = t / 8 | 0;
                return (e[i] | e[i + 1] << 8) >> (7 & t) & n
            },
            ah = function(e, t) {
                var n = t / 8 | 0;
                return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
            },
            oh = function(e) {
                return (e / 8 | 0) + (7 & e && 1)
            },
            lh = function(e, t, n) {
                (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
                var i = new(e instanceof kc ? kc : e instanceof Nc ? Nc : Oc)(n - t);
                return i.set(e.subarray(t, n)), i
            },
            ch = function(e, t, n) {
                var i = e.length;
                if (!i || n && !n.l && i < 5) return t || new Oc(0);
                var r = !t || n,
                    s = !n || n.i;
                n || (n = {}), t || (t = new Oc(3 * i));
                var a = function(e) {
                        var n = t.length;
                        if (e > n) {
                            var i = new Oc(Math.max(2 * n, e));
                            i.set(t), t = i
                        }
                    },
                    o = n.f || 0,
                    l = n.p || 0,
                    c = n.b || 0,
                    h = n.l,
                    u = n.d,
                    d = n.m,
                    p = n.n,
                    f = 8 * i;
                do {
                    if (!h) {
                        n.f = o = sh(e, l, 1);
                        var m = sh(e, l + 1, 3);
                        if (l += 3, !m) {
                            var g = e[(T = oh(l) + 4) - 4] | e[T - 3] << 8,
                                v = T + g;
                            if (v > i) {
                                if (s) throw "unexpected EOF";
                                break
                            }
                            r && a(c + g), t.set(e.subarray(T, v), c), n.b = c += g, n.p = l = 8 * v;
                            continue
                        }
                        if (1 == m) h = th, u = ih, d = 9, p = 5;
                        else {
                            if (2 != m) throw "invalid block type";
                            var x = sh(e, l, 31) + 257,
                                w = sh(e, l + 10, 15) + 4,
                                b = x + sh(e, l + 5, 31) + 1;
                            l += 14;
                            for (var _ = new Oc(b), y = new Oc(19), A = 0; A < w; ++A) y[zc[A]] = sh(e, l + 3 * A, 7);
                            l += 3 * w;
                            var M = rh(y),
                                S = (1 << M) - 1,
                                E = Zc(y, M, 1);
                            for (A = 0; A < b;) {
                                var T, C = E[sh(e, l, S)];
                                if (l += 15 & C, (T = C >>> 4) < 16) _[A++] = T;
                                else {
                                    var D = 0,
                                        P = 0;
                                    for (16 == T ? (P = 3 + sh(e, l, 3), l += 2, D = _[A - 1]) : 17 == T ? (P = 3 + sh(e, l, 7), l += 3) : 18 == T && (P = 11 + sh(e, l, 127), l += 7); P--;) _[A++] = D
                                }
                            }
                            var R = _.subarray(0, x),
                                L = _.subarray(x);
                            d = rh(R), p = rh(L), h = Zc(R, d, 1), u = Zc(L, p, 1)
                        }
                        if (l > f) {
                            if (s) throw "unexpected EOF";
                            break
                        }
                    }
                    r && a(c + 131072);
                    for (var I = (1 << d) - 1, B = (1 << p) - 1, O = l;; O = l) {
                        var k = (D = h[ah(e, l) & I]) >>> 4;
                        if ((l += 15 & D) > f) {
                            if (s) throw "unexpected EOF";
                            break
                        }
                        if (!D) throw "invalid length/literal";
                        if (k < 256) t[c++] = k;
                        else {
                            if (256 == k) {
                                O = l, h = null;
                                break
                            }
                            var N = k - 254;
                            if (k > 264) {
                                var F = Fc[A = k - 257];
                                N = sh(e, l, (1 << F) - 1) + Gc[A], l += F
                            }
                            var U = u[ah(e, l) & B],
                                z = U >>> 4;
                            if (!U) throw "invalid distance";
                            if (l += 15 & U, L = Yc[z], z > 3 && (F = Uc[z], L += ah(e, l) & (1 << F) - 1, l += F), l > f) {
                                if (s) throw "unexpected EOF";
                                break
                            }
                            r && a(c + 131072);
                            for (var V = c + N; c < V; c += 4) t[c] = t[c - L], t[c + 1] = t[c + 1 - L], t[c + 2] = t[c + 2 - L], t[c + 3] = t[c + 3 - L];
                            c = V
                        }
                    }
                    n.l = h, n.p = O, n.b = c, h && (o = 1, n.m = d, n.d = u, n.n = p)
                } while (!o);
                return c == t.length ? t : lh(t, 0, c)
            },
            hh = function(e, t, n) {
                n <<= 7 & t;
                var i = t / 8 | 0;
                e[i] |= n, e[i + 1] |= n >>> 8
            },
            uh = function(e, t, n) {
                n <<= 7 & t;
                var i = t / 8 | 0;
                e[i] |= n, e[i + 1] |= n >>> 8, e[i + 2] |= n >>> 16
            },
            dh = function(e, t) {
                for (var n = [], i = 0; i < e.length; ++i) e[i] && n.push({
                    s: i,
                    f: e[i]
                });
                var r = n.length,
                    s = n.slice();
                if (!r) return [wh, 0];
                if (1 == r) {
                    var a = new Oc(n[0].s + 1);
                    return a[n[0].s] = 1, [a, 1]
                }
                n.sort((function(e, t) {
                    return e.f - t.f
                })), n.push({
                    s: -1,
                    f: 25001
                });
                var o = n[0],
                    l = n[1],
                    c = 0,
                    h = 1,
                    u = 2;
                for (n[0] = {
                        s: -1,
                        f: o.f + l.f,
                        l: o,
                        r: l
                    }; h != r - 1;) o = n[n[c].f < n[u].f ? c++ : u++], l = n[c != h && n[c].f < n[u].f ? c++ : u++], n[h++] = {
                    s: -1,
                    f: o.f + l.f,
                    l: o,
                    r: l
                };
                var d = s[0].s;
                for (i = 1; i < r; ++i) s[i].s > d && (d = s[i].s);
                var p = new kc(d + 1),
                    f = ph(n[h - 1], p, 0);
                if (f > t) {
                    i = 0;
                    var m = 0,
                        g = f - t,
                        v = 1 << g;
                    for (s.sort((function(e, t) {
                            return p[t.s] - p[e.s] || e.f - t.f
                        })); i < r; ++i) {
                        var x = s[i].s;
                        if (!(p[x] > t)) break;
                        m += v - (1 << f - p[x]), p[x] = t
                    }
                    for (m >>>= g; m > 0;) {
                        var w = s[i].s;
                        p[w] < t ? m -= 1 << t - p[w]++ - 1 : ++i
                    }
                    for (; i >= 0 && m; --i) {
                        var b = s[i].s;
                        p[b] == t && (--p[b], ++m)
                    }
                    f = t
                }
                return [new Oc(p), f]
            },
            ph = function(e, t, n) {
                return -1 == e.s ? Math.max(ph(e.l, t, n + 1), ph(e.r, t, n + 1)) : t[e.s] = n
            },
            fh = function(e) {
                for (var t = e.length; t && !e[--t];);
                for (var n = new kc(++t), i = 0, r = e[0], s = 1, a = function(e) {
                        n[i++] = e
                    }, o = 1; o <= t; ++o)
                    if (e[o] == r && o != t) ++s;
                    else {
                        if (!r && s > 2) {
                            for (; s > 138; s -= 138) a(32754);
                            s > 2 && (a(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0)
                        } else if (s > 3) {
                            for (a(r), --s; s > 6; s -= 6) a(8304);
                            s > 2 && (a(s - 3 << 5 | 8208), s = 0)
                        }
                        for (; s--;) a(r);
                        s = 1, r = e[o]
                    }
                return [n.subarray(0, i), t]
            },
            mh = function(e, t) {
                for (var n = 0, i = 0; i < t.length; ++i) n += e[i] * t[i];
                return n
            },
            gh = function(e, t, n) {
                var i = n.length,
                    r = oh(t + 2);
                e[r] = 255 & i, e[r + 1] = i >>> 8, e[r + 2] = 255 ^ e[r], e[r + 3] = 255 ^ e[r + 1];
                for (var s = 0; s < i; ++s) e[r + s + 4] = n[s];
                return 8 * (r + 4 + i)
            },
            vh = function(e, t, n, i, r, s, a, o, l, c, h) {
                hh(t, h++, n), ++r[256];
                for (var u = dh(r, 15), d = u[0], p = u[1], f = dh(s, 15), m = f[0], g = f[1], v = fh(d), x = v[0], w = v[1], b = fh(m), _ = b[0], y = b[1], A = new kc(19), M = 0; M < x.length; ++M) A[31 & x[M]]++;
                for (M = 0; M < _.length; ++M) A[31 & _[M]]++;
                for (var S = dh(A, 7), E = S[0], T = S[1], C = 19; C > 4 && !E[zc[C - 1]]; --C);
                var D, P, R, L, I = c + 5 << 3,
                    B = mh(r, Jc) + mh(s, $c) + a,
                    O = mh(r, d) + mh(s, m) + a + 14 + 3 * C + mh(A, E) + (2 * A[16] + 3 * A[17] + 7 * A[18]);
                if (I <= B && I <= O) return gh(t, h, e.subarray(l, l + c));
                if (hh(t, h, 1 + (O < B)), h += 2, O < B) {
                    D = Zc(d, p, 0), P = d, R = Zc(m, g, 0), L = m;
                    var k = Zc(E, T, 0);
                    for (hh(t, h, w - 257), hh(t, h + 5, y - 1), hh(t, h + 10, C - 4), h += 14, M = 0; M < C; ++M) hh(t, h + 3 * M, E[zc[M]]);
                    h += 3 * C;
                    for (var N = [x, _], F = 0; F < 2; ++F) {
                        var U = N[F];
                        for (M = 0; M < U.length; ++M) {
                            var z = 31 & U[M];
                            hh(t, h, k[z]), h += E[z], z > 15 && (hh(t, h, U[M] >>> 5 & 127), h += U[M] >>> 12)
                        }
                    }
                } else D = eh, P = Jc, R = nh, L = $c;
                for (M = 0; M < o; ++M)
                    if (i[M] > 255) {
                        z = i[M] >>> 18 & 31, uh(t, h, D[z + 257]), h += P[z + 257], z > 7 && (hh(t, h, i[M] >>> 23 & 31), h += Fc[z]);
                        var V = 31 & i[M];
                        uh(t, h, R[V]), h += L[V], V > 3 && (uh(t, h, i[M] >>> 5 & 8191), h += Uc[V])
                    } else uh(t, h, D[i[M]]), h += P[i[M]];
                return uh(t, h, D[256]), h + P[256]
            },
            xh = new Nc([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
            wh = new Oc(0),
            bh = function(e, t, n, i, r, s) {
                var a = e.length,
                    o = new Oc(i + a + 5 * (1 + Math.ceil(a / 7e3)) + r),
                    l = o.subarray(i, o.length - r),
                    c = 0;
                if (!t || a < 8)
                    for (var h = 0; h <= a; h += 65535) {
                        var u = h + 65535;
                        u < a ? c = gh(l, c, e.subarray(h, u)) : (l[h] = s, c = gh(l, c, e.subarray(h, a)))
                    } else {
                        for (var d = xh[t - 1], p = d >>> 13, f = 8191 & d, m = (1 << n) - 1, g = new kc(32768), v = new kc(m + 1), x = Math.ceil(n / 3), w = 2 * x, b = function(t) {
                                return (e[t] ^ e[t + 1] << x ^ e[t + 2] << w) & m
                            }, _ = new Nc(25e3), y = new kc(288), A = new kc(32), M = 0, S = 0, E = (h = 0, 0), T = 0, C = 0; h < a; ++h) {
                            var D = b(h),
                                P = 32767 & h,
                                R = v[D];
                            if (g[P] = R, v[D] = P, T <= h) {
                                var L = a - h;
                                if ((M > 7e3 || E > 24576) && L > 423) {
                                    c = vh(e, l, 0, _, y, A, S, E, C, h - C, c), E = M = S = 0, C = h;
                                    for (var I = 0; I < 286; ++I) y[I] = 0;
                                    for (I = 0; I < 30; ++I) A[I] = 0
                                }
                                var B = 2,
                                    O = 0,
                                    k = f,
                                    N = P - R & 32767;
                                if (L > 2 && D == b(h - N))
                                    for (var F = Math.min(p, L) - 1, U = Math.min(32767, h), z = Math.min(258, L); N <= U && --k && P != R;) {
                                        if (e[h + B] == e[h + B - N]) {
                                            for (var V = 0; V < z && e[h + V] == e[h + V - N]; ++V);
                                            if (V > B) {
                                                if (B = V, O = N, V > F) break;
                                                var H = Math.min(N, V - 2),
                                                    G = 0;
                                                for (I = 0; I < H; ++I) {
                                                    var W = h - N + I + 32768 & 32767,
                                                        j = W - g[W] + 32768 & 32767;
                                                    j > G && (G = j, R = W)
                                                }
                                            }
                                        }
                                        N += (P = R) - (R = g[P]) + 32768 & 32767
                                    }
                                if (O) {
                                    _[E++] = 268435456 | Wc[B] << 18 | Xc[O];
                                    var Y = 31 & Wc[B],
                                        X = 31 & Xc[O];
                                    S += Fc[Y] + Uc[X], ++y[257 + Y], ++A[X], T = h + B, ++M
                                } else _[E++] = e[h], ++y[e[h]]
                            }
                        }
                        c = vh(e, l, s, _, y, A, S, E, C, h - C, c), !s && 7 & c && (c = gh(l, c + 1, wh))
                    }
                return lh(o, 0, i + oh(c) + r)
            },
            _h = function() {
                for (var e = new Nc(256), t = 0; t < 256; ++t) {
                    for (var n = t, i = 9; --i;) n = (1 & n && 3988292384) ^ n >>> 1;
                    e[t] = n
                }
                return e
            }(),
            yh = function() {
                var e = -1;
                return {
                    p: function(t) {
                        for (var n = e, i = 0; i < t.length; ++i) n = _h[255 & n ^ t[i]] ^ n >>> 8;
                        e = n
                    },
                    d: function() {
                        return ~e
                    }
                }
            },
            Ah = function() {
                var e = 1,
                    t = 0;
                return {
                    p: function(n) {
                        for (var i = e, r = t, s = n.length, a = 0; a != s;) {
                            for (var o = Math.min(a + 2655, s); a < o; ++a) r += i += n[a];
                            i = (65535 & i) + 15 * (i >> 16), r = (65535 & r) + 15 * (r >> 16)
                        }
                        e = i, t = r
                    },
                    d: function() {
                        return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8
                    }
                }
            },
            Mh = function(e, t, n, i, r) {
                return bh(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, i, !r)
            },
            Sh = function(e, t) {
                var n = {};
                for (var i in e) n[i] = e[i];
                for (var i in t) n[i] = t[i];
                return n
            },
            Eh = function(e, t, n) {
                for (var i = e(), r = e.toString(), s = r.slice(r.indexOf("[") + 1, r.lastIndexOf("]")).replace(/ /g, "").split(","), a = 0; a < i.length; ++a) {
                    var o = i[a],
                        l = s[a];
                    if ("function" == typeof o) {
                        t += ";" + l + "=";
                        var c = o.toString();
                        if (o.prototype)
                            if (-1 != c.indexOf("[native code]")) {
                                var h = c.indexOf(" ", 8) + 1;
                                t += c.slice(h, c.indexOf("(", h))
                            } else
                                for (var u in t += c, o.prototype) t += ";" + l + ".prototype." + u + "=" + o.prototype[u].toString();
                        else t += c
                    } else n[l] = o
                }
                return [t, n]
            },
            Th = [],
            Ch = function(e, t, n, i) {
                var r;
                if (!Th[n]) {
                    for (var s = "", a = {}, o = e.length - 1, l = 0; l < o; ++l) s = (r = Eh(e[l], s, a))[0], a = r[1];
                    Th[n] = Eh(e[o], s, a)
                }
                var c = Sh({}, Th[n][1]);
                return function(e, t, n, i, r) {
                    var s = Bc(Lc[t] || (Lc[t] = Ic(e)));
                    return s.onerror = function(e) {
                        return r(e.error, null)
                    }, s.onmessage = function(e) {
                        return r(null, e.data)
                    }, s.postMessage(n, i), s
                }(Th[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function(e) {
                    var t = [];
                    for (var n in e)(e[n] instanceof Oc || e[n] instanceof kc || e[n] instanceof Nc) && t.push((e[n] = new e[n].constructor(e[n])).buffer);
                    return t
                }(c), i)
            },
            Dh = function() {
                return [Oc, kc, Nc, Fc, Uc, zc, Gc, Yc, th, ih, Qc, Zc, rh, sh, ah, oh, lh, ch, ru, Oh, kh]
            },
            Ph = function() {
                return [Oc, kc, Nc, Fc, Uc, zc, Wc, Xc, eh, Jc, nh, $c, Qc, xh, wh, Zc, hh, uh, dh, ph, fh, mh, gh, vh, oh, lh, bh, Mh, eu, Oh]
            },
            Rh = function() {
                return [Wh, Xh, Gh, yh, _h]
            },
            Lh = function() {
                return [jh, Yh]
            },
            Ih = function() {
                return [Qh, Gh, Ah]
            },
            Bh = function() {
                return [qh]
            },
            Oh = function(e) {
                return postMessage(e, [e.buffer])
            },
            kh = function(e) {
                return e && e.size && new Oc(e.size)
            },
            Nh = function(e, t, n, i, r, s) {
                var a = Ch(n, i, r, (function(e, t) {
                    a.terminate(), s(e, t)
                }));
                return a.postMessage([e, t], t.consume ? [e.buffer] : []),
                    function() {
                        a.terminate()
                    }
            },
            Fh = function(e) {
                return e.ondata = function(e, t) {
                        return postMessage([e, t], [e.buffer])
                    },
                    function(t) {
                        return e.push(t.data[0], t.data[1])
                    }
            },
            Uh = function(e, t, n, i, r) {
                var s, a = Ch(e, i, r, (function(e, n) {
                    e ? (a.terminate(), t.ondata.call(t, e)) : (n[1] && a.terminate(), t.ondata.call(t, e, n[0], n[1]))
                }));
                a.postMessage(n), t.push = function(e, n) {
                    if (s) throw "stream finished";
                    if (!t.ondata) throw "no stream handler";
                    a.postMessage([e, s = n], [e.buffer])
                }, t.terminate = function() {
                    a.terminate()
                }
            },
            zh = function(e, t) {
                return e[t] | e[t + 1] << 8
            },
            Vh = function(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0
            },
            Hh = function(e, t) {
                return Vh(e, t) + 4294967296 * Vh(e, t + 4)
            },
            Gh = function(e, t, n) {
                for (; n; ++t) e[t] = n, n >>>= 8
            },
            Wh = function(e, t) {
                var n = t.filename;
                if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Gh(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
                    e[3] = 8;
                    for (var i = 0; i <= n.length; ++i) e[i + 10] = n.charCodeAt(i)
                }
            },
            jh = function(e) {
                if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
                var t = e[3],
                    n = 10;
                4 & t && (n += e[10] | 2 + (e[11] << 8));
                for (var i = (t >> 3 & 1) + (t >> 4 & 1); i > 0; i -= !e[n++]);
                return n + (2 & t)
            },
            Yh = function(e) {
                var t = e.length;
                return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0
            },
            Xh = function(e) {
                return 10 + (e.filename && e.filename.length + 1 || 0)
            },
            Qh = function(e, t) {
                var n = t.level,
                    i = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
                e[0] = 120, e[1] = i << 6 | (i ? 32 - 2 * i : 1)
            },
            qh = function(e) {
                if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
                if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported"
            };

        function Kh(e, t) {
            return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e
        }
        var Zh = function() {
                function e(e, t) {
                    t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {}
                }
                return e.prototype.p = function(e, t) {
                    this.ondata(Mh(e, this.o, 0, 0, !t), t)
                }, e.prototype.push = function(e, t) {
                    if (this.d) throw "stream finished";
                    if (!this.ondata) throw "no stream handler";
                    this.d = t, this.p(e, t || !1)
                }, e
            }(),
            Jh = function() {
                return function(e, t) {
                    Uh([Ph, function() {
                        return [Fh, Zh]
                    }], this, Kh.call(this, e, t), (function(e) {
                        var t = new Zh(e.data);
                        onmessage = Fh(t)
                    }), 6)
                }
            }();

        function $h(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return Nh(e, t, [Ph], (function(e) {
                return Oh(eu(e.data[0], e.data[1]))
            }), 0, n)
        }

        function eu(e, t) {
            return Mh(e, t || {}, 0, 0)
        }
        var tu = function() {
                function e(e) {
                    this.s = {}, this.p = new Oc(0), this.ondata = e
                }
                return e.prototype.e = function(e) {
                    if (this.d) throw "stream finished";
                    if (!this.ondata) throw "no stream handler";
                    var t = this.p.length,
                        n = new Oc(t + e.length);
                    n.set(this.p), n.set(e, t), this.p = n
                }, e.prototype.c = function(e) {
                    this.d = this.s.i = e || !1;
                    var t = this.s.b,
                        n = ch(this.p, this.o, this.s);
                    this.ondata(lh(n, t, this.s.b), this.d), this.o = lh(n, this.s.b - 32768), this.s.b = this.o.length, this.p = lh(this.p, this.s.p / 8 | 0), this.s.p &= 7
                }, e.prototype.push = function(e, t) {
                    this.e(e), this.c(t)
                }, e
            }(),
            nu = function() {
                return function(e) {
                    this.ondata = e, Uh([Dh, function() {
                        return [Fh, tu]
                    }], this, 0, (function() {
                        var e = new tu;
                        onmessage = Fh(e)
                    }), 7)
                }
            }();

        function iu(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return Nh(e, t, [Dh], (function(e) {
                return Oh(ru(e.data[0], kh(e.data[1])))
            }), 1, n)
        }

        function ru(e, t) {
            return ch(e, t)
        }
        var su = function() {
                function e(e, t) {
                    this.c = yh(), this.l = 0, this.v = 1, Zh.call(this, e, t)
                }
                return e.prototype.push = function(e, t) {
                    Zh.prototype.push.call(this, e, t)
                }, e.prototype.p = function(e, t) {
                    this.c.p(e), this.l += e.length;
                    var n = Mh(e, this.o, this.v && Xh(this.o), t && 8, !t);
                    this.v && (Wh(n, this.o), this.v = 0), t && (Gh(n, n.length - 8, this.c.d()), Gh(n, n.length - 4, this.l)), this.ondata(n, t)
                }, e
            }(),
            au = function() {
                return function(e, t) {
                    Uh([Ph, Rh, function() {
                        return [Fh, Zh, su]
                    }], this, Kh.call(this, e, t), (function(e) {
                        var t = new su(e.data);
                        onmessage = Fh(t)
                    }), 8)
                }
            }();

        function ou(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return Nh(e, t, [Ph, Rh, function() {
                return [lu]
            }], (function(e) {
                return Oh(lu(e.data[0], e.data[1]))
            }), 2, n)
        }

        function lu(e, t) {
            t || (t = {});
            var n = yh(),
                i = e.length;
            n.p(e);
            var r = Mh(e, t, Xh(t), 8),
                s = r.length;
            return Wh(r, t), Gh(r, s - 8, n.d()), Gh(r, s - 4, i), r
        }
        var cu = function() {
                function e(e) {
                    this.v = 1, tu.call(this, e)
                }
                return e.prototype.push = function(e, t) {
                    if (tu.prototype.e.call(this, e), this.v) {
                        var n = this.p.length > 3 ? jh(this.p) : 4;
                        if (n >= this.p.length && !t) return;
                        this.p = this.p.subarray(n), this.v = 0
                    }
                    if (t) {
                        if (this.p.length < 8) throw "invalid gzip stream";
                        this.p = this.p.subarray(0, -8)
                    }
                    tu.prototype.c.call(this, t)
                }, e
            }(),
            hu = function() {
                return function(e) {
                    this.ondata = e, Uh([Dh, Lh, function() {
                        return [Fh, tu, cu]
                    }], this, 0, (function() {
                        var e = new cu;
                        onmessage = Fh(e)
                    }), 9)
                }
            }();

        function uu(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return Nh(e, t, [Dh, Lh, function() {
                return [du]
            }], (function(e) {
                return Oh(du(e.data[0]))
            }), 3, n)
        }

        function du(e, t) {
            return ch(e.subarray(jh(e), -8), t || new Oc(Yh(e)))
        }
        var pu = function() {
                function e(e, t) {
                    this.c = Ah(), this.v = 1, Zh.call(this, e, t)
                }
                return e.prototype.push = function(e, t) {
                    Zh.prototype.push.call(this, e, t)
                }, e.prototype.p = function(e, t) {
                    this.c.p(e);
                    var n = Mh(e, this.o, this.v && 2, t && 4, !t);
                    this.v && (Qh(n, this.o), this.v = 0), t && Gh(n, n.length - 4, this.c.d()), this.ondata(n, t)
                }, e
            }(),
            fu = function() {
                return function(e, t) {
                    Uh([Ph, Ih, function() {
                        return [Fh, Zh, pu]
                    }], this, Kh.call(this, e, t), (function(e) {
                        var t = new pu(e.data);
                        onmessage = Fh(t)
                    }), 10)
                }
            }();

        function mu(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return Nh(e, t, [Ph, Ih, function() {
                return [gu]
            }], (function(e) {
                return Oh(gu(e.data[0], e.data[1]))
            }), 4, n)
        }

        function gu(e, t) {
            t || (t = {});
            var n = Ah();
            n.p(e);
            var i = Mh(e, t, 2, 4);
            return Qh(i, t), Gh(i, i.length - 4, n.d()), i
        }
        var vu = function() {
                function e(e) {
                    this.v = 1, tu.call(this, e)
                }
                return e.prototype.push = function(e, t) {
                    if (tu.prototype.e.call(this, e), this.v) {
                        if (this.p.length < 2 && !t) return;
                        this.p = this.p.subarray(2), this.v = 0
                    }
                    if (t) {
                        if (this.p.length < 4) throw "invalid zlib stream";
                        this.p = this.p.subarray(0, -4)
                    }
                    tu.prototype.c.call(this, t)
                }, e
            }(),
            xu = function() {
                return function(e) {
                    this.ondata = e, Uh([Dh, Bh, function() {
                        return [Fh, tu, vu]
                    }], this, 0, (function() {
                        var e = new vu;
                        onmessage = Fh(e)
                    }), 11)
                }
            }();

        function wu(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return Nh(e, t, [Dh, Bh, function() {
                return [bu]
            }], (function(e) {
                return Oh(bu(e.data[0], kh(e.data[1])))
            }), 5, n)
        }

        function bu(e, t) {
            return ch((qh(e), e.subarray(2, -4)), t)
        }
        var _u = function() {
                function e(e) {
                    this.G = cu, this.I = tu, this.Z = vu, this.ondata = e
                }
                return e.prototype.push = function(e, t) {
                    if (!this.ondata) throw "no stream handler";
                    if (this.s) this.s.push(e, t);
                    else {
                        if (this.p && this.p.length) {
                            var n = new Oc(this.p.length + e.length);
                            n.set(this.p), n.set(e, this.p.length)
                        } else this.p = e;
                        if (this.p.length > 2) {
                            var i = this,
                                r = function() {
                                    i.ondata.apply(i, arguments)
                                };
                            this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(r) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(r) : new this.Z(r), this.s.push(this.p, t), this.p = null
                        }
                    }
                }, e
            }(),
            yu = function() {
                function e(e) {
                    this.G = hu, this.I = nu, this.Z = xu, this.ondata = e
                }
                return e.prototype.push = function(e, t) {
                    _u.prototype.push.call(this, e, t)
                }, e
            }();

        function Au(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            return 31 == e[0] && 139 == e[1] && 8 == e[2] ? uu(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? iu(e, t, n) : wu(e, t, n)
        }

        function Mu(e, t) {
            return 31 == e[0] && 139 == e[1] && 8 == e[2] ? du(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? ru(e, t) : bu(e, t)
        }
        var Su = function(e, t, n, i) {
                for (var r in e) {
                    var s = e[r],
                        a = t + r;
                    s instanceof Oc ? n[a] = [s, i] : Array.isArray(s) ? n[a] = [s[0], Sh(i, s[1])] : Su(s, a + "/", n, i)
                }
            },
            Eu = "undefined" != typeof TextEncoder && new TextEncoder,
            Tu = "undefined" != typeof TextDecoder && new TextDecoder,
            Cu = 0;
        try {
            Tu.decode(wh, {
                stream: !0
            }), Cu = 1
        } catch (yl) {}
        var Du = function(e) {
                for (var t = "", n = 0;;) {
                    var i = e[n++],
                        r = (i > 127) + (i > 223) + (i > 239);
                    if (n + r > e.length) return [t, lh(e, n - 1)];
                    r ? 3 == r ? (i = ((15 & i) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i)) : t += 1 & r ? String.fromCharCode((31 & i) << 6 | 63 & e[n++]) : String.fromCharCode((15 & i) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(i)
                }
            },
            Pu = function() {
                function e(e) {
                    this.ondata = e, Cu ? this.t = new TextDecoder : this.p = wh
                }
                return e.prototype.push = function(e, t) {
                    if (!this.ondata) throw "no callback";
                    if (t = !!t, this.t) {
                        if (this.ondata(this.t.decode(e, {
                                stream: !0
                            }), t), t) {
                            if (this.t.decode().length) throw "invalid utf-8 data";
                            this.t = null
                        }
                    } else {
                        if (!this.p) throw "stream finished";
                        var n = new Oc(this.p.length + e.length);
                        n.set(this.p), n.set(e, this.p.length);
                        var i = Du(n),
                            r = i[0],
                            s = i[1];
                        if (t) {
                            if (s.length) throw "invalid utf-8 data";
                            this.p = null
                        } else this.p = s;
                        this.ondata(r, t)
                    }
                }, e
            }(),
            Ru = function() {
                function e(e) {
                    this.ondata = e
                }
                return e.prototype.push = function(e, t) {
                    if (!this.ondata) throw "no callback";
                    if (this.d) throw "stream finished";
                    this.ondata(Lu(e), this.d = t || !1)
                }, e
            }();

        function Lu(e, t) {
            if (t) {
                for (var n = new Oc(e.length), i = 0; i < e.length; ++i) n[i] = e.charCodeAt(i);
                return n
            }
            if (Eu) return Eu.encode(e);
            var r = e.length,
                s = new Oc(e.length + (e.length >> 1)),
                a = 0,
                o = function(e) {
                    s[a++] = e
                };
            for (i = 0; i < r; ++i) {
                if (a + 5 > s.length) {
                    var l = new Oc(a + 8 + (r - i << 1));
                    l.set(s), s = l
                }
                var c = e.charCodeAt(i);
                c < 128 || t ? o(c) : c < 2048 ? (o(192 | c >> 6), o(128 | 63 & c)) : c > 55295 && c < 57344 ? (o(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++i)) >> 18), o(128 | c >> 12 & 63), o(128 | c >> 6 & 63), o(128 | 63 & c)) : (o(224 | c >> 12), o(128 | c >> 6 & 63), o(128 | 63 & c))
            }
            return lh(s, 0, a)
        }

        function Iu(e, t) {
            if (t) {
                for (var n = "", i = 0; i < e.length; i += 16384) n += String.fromCharCode.apply(null, e.subarray(i, i + 16384));
                return n
            }
            if (Tu) return Tu.decode(e);
            var r = Du(e),
                s = r[0];
            if (r[1].length) throw "invalid utf-8 data";
            return s
        }
        var Bu = function(e) {
                return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0
            },
            Ou = function(e, t) {
                return t + 30 + zh(e, t + 26) + zh(e, t + 28)
            },
            ku = function(e, t, n) {
                var i = zh(e, t + 28),
                    r = Iu(e.subarray(t + 46, t + 46 + i), !(2048 & zh(e, t + 8))),
                    s = t + 46 + i,
                    a = Vh(e, t + 20),
                    o = n && 4294967295 == a ? Nu(e, s) : [a, Vh(e, t + 24), Vh(e, t + 42)],
                    l = o[0],
                    c = o[1],
                    h = o[2];
                return [zh(e, t + 10), l, c, r, s + zh(e, t + 30) + zh(e, t + 32), h]
            },
            Nu = function(e, t) {
                for (; 1 != zh(e, t); t += 4 + zh(e, t + 2));
                return [Hh(e, t + 12), Hh(e, t + 4), Hh(e, t + 20)]
            },
            Fu = function(e) {
                var t = 0;
                if (e)
                    for (var n in e) {
                        var i = e[n].length;
                        if (i > 65535) throw "extra field too long";
                        t += i + 4
                    }
                return t
            },
            Uu = function(e, t, n, i, r, s, a, o) {
                var l = i.length,
                    c = n.extra,
                    h = o && o.length,
                    u = Fu(c);
                Gh(e, t, null != a ? 33639248 : 67324752), t += 4, null != a && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = r && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
                var d = new Date(null == n.mtime ? Date.now() : n.mtime),
                    p = d.getFullYear() - 1980;
                if (p < 0 || p > 119) throw "date not in range 1980-2099";
                if (Gh(e, t, p << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), t += 4, null != s && (Gh(e, t, n.crc), Gh(e, t + 4, s), Gh(e, t + 8, n.size)), Gh(e, t + 12, l), Gh(e, t + 14, u), t += 16, null != a && (Gh(e, t, h), Gh(e, t + 6, n.attrs), Gh(e, t + 10, a), t += 14), e.set(i, t), t += l, u)
                    for (var f in c) {
                        var m = c[f],
                            g = m.length;
                        Gh(e, t, +f), Gh(e, t + 2, g), e.set(m, t + 4), t += 4 + g
                    }
                return h && (e.set(o, t), t += h), t
            },
            zu = function(e, t, n, i, r) {
                Gh(e, t, 101010256), Gh(e, t + 8, n), Gh(e, t + 10, n), Gh(e, t + 12, i), Gh(e, t + 16, r)
            },
            Vu = function() {
                function e(e) {
                    this.filename = e, this.c = yh(), this.size = 0, this.compression = 0
                }
                return e.prototype.process = function(e, t) {
                    this.ondata(null, e, t)
                }, e.prototype.push = function(e, t) {
                    if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
                    this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1)
                }, e
            }(),
            Hu = function() {
                function e(e, t) {
                    var n = this;
                    t || (t = {}), Vu.call(this, e), this.d = new Zh(t, (function(e, t) {
                        n.ondata(null, e, t)
                    })), this.compression = 8, this.flag = Bu(t.level)
                }
                return e.prototype.process = function(e, t) {
                    try {
                        this.d.push(e, t)
                    } catch (e) {
                        this.ondata(e, null, t)
                    }
                }, e.prototype.push = function(e, t) {
                    Vu.prototype.push.call(this, e, t)
                }, e
            }(),
            Gu = function() {
                function e(e, t) {
                    var n = this;
                    t || (t = {}), Vu.call(this, e), this.d = new Jh(t, (function(e, t, i) {
                        n.ondata(e, t, i)
                    })), this.compression = 8, this.flag = Bu(t.level), this.terminate = this.d.terminate
                }
                return e.prototype.process = function(e, t) {
                    this.d.push(e, t)
                }, e.prototype.push = function(e, t) {
                    Vu.prototype.push.call(this, e, t)
                }, e
            }(),
            Wu = function() {
                function e(e) {
                    this.ondata = e, this.u = [], this.d = 1
                }
                return e.prototype.add = function(e) {
                    var t = this;
                    if (2 & this.d) throw "stream finished";
                    var n = Lu(e.filename),
                        i = n.length,
                        r = e.comment,
                        s = r && Lu(r),
                        a = i != e.filename.length || s && r.length != s.length,
                        o = i + Fu(e.extra) + 30;
                    if (i > 65535) throw "filename too long";
                    var l = new Oc(o);
                    Uu(l, 0, e, n, a);
                    var c = [l],
                        h = function() {
                            for (var e = 0, n = c; e < n.length; e++) {
                                var i = n[e];
                                t.ondata(null, i, !1)
                            }
                            c = []
                        },
                        u = this.d;
                    this.d = 0;
                    var d = this.u.length,
                        p = Sh(e, {
                            f: n,
                            u: a,
                            o: s,
                            t: function() {
                                e.terminate && e.terminate()
                            },
                            r: function() {
                                if (h(), u) {
                                    var e = t.u[d + 1];
                                    e ? e.r() : t.d = 1
                                }
                                u = 1
                            }
                        }),
                        f = 0;
                    e.ondata = function(n, i, r) {
                        if (n) t.ondata(n, i, r), t.terminate();
                        else if (f += i.length, c.push(i), r) {
                            var s = new Oc(16);
                            Gh(s, 0, 134695760), Gh(s, 4, e.crc), Gh(s, 8, f), Gh(s, 12, e.size), c.push(s), p.c = f, p.b = o + f + 16, p.crc = e.crc, p.size = e.size, u && p.r(), u = 1
                        } else u && h()
                    }, this.u.push(p)
                }, e.prototype.end = function() {
                    var e = this;
                    if (2 & this.d) {
                        if (1 & this.d) throw "stream finishing";
                        throw "stream finished"
                    }
                    this.d ? this.e() : this.u.push({
                        r: function() {
                            1 & e.d && (e.u.splice(-1, 1), e.e())
                        },
                        t: function() {}
                    }), this.d = 3
                }, e.prototype.e = function() {
                    for (var e = 0, t = 0, n = 0, i = 0, r = this.u; i < r.length; i++) n += 46 + (l = r[i]).f.length + Fu(l.extra) + (l.o ? l.o.length : 0);
                    for (var s = new Oc(n + 22), a = 0, o = this.u; a < o.length; a++) {
                        var l = o[a];
                        Uu(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + Fu(l.extra) + (l.o ? l.o.length : 0), t += l.b
                    }
                    zu(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2
                }, e.prototype.terminate = function() {
                    for (var e = 0, t = this.u; e < t.length; e++) t[e].t();
                    this.d = 2
                }, e
            }();

        function ju(e, t, n) {
            if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
            var i = {};
            Su(e, "", i, t);
            var r = Object.keys(i),
                s = r.length,
                a = 0,
                o = 0,
                l = s,
                c = new Array(s),
                h = [],
                u = function() {
                    for (var e = 0; e < h.length; ++e) h[e]()
                },
                d = function() {
                    var e = new Oc(o + 22),
                        t = a,
                        i = o - a;
                    o = 0;
                    for (var r = 0; r < l; ++r) {
                        var s = c[r];
                        try {
                            var h = s.c.length;
                            Uu(e, o, s, s.f, s.u, h);
                            var u = 30 + s.f.length + Fu(s.extra),
                                d = o + u;
                            e.set(s.c, d), Uu(e, a, s, s.f, s.u, h, o, s.m), a += 16 + u + (s.m ? s.m.length : 0), o = d + h
                        } catch (e) {
                            return n(e, null)
                        }
                    }
                    zu(e, a, c.length, i, t), n(null, e)
                };
            s || d();
            for (var p = function(e) {
                    var t = r[e],
                        l = i[t],
                        p = l[0],
                        f = l[1],
                        m = yh(),
                        g = p.length;
                    m.p(p);
                    var v = Lu(t),
                        x = v.length,
                        w = f.comment,
                        b = w && Lu(w),
                        _ = b && b.length,
                        y = Fu(f.extra),
                        A = 0 == f.level ? 0 : 8,
                        M = function(i, r) {
                            if (i) u(), n(i, null);
                            else {
                                var l = r.length;
                                c[e] = Sh(f, {
                                    size: g,
                                    crc: m.d(),
                                    c: r,
                                    f: v,
                                    m: b,
                                    u: x != t.length || b && w.length != _,
                                    compression: A
                                }), a += 30 + x + y + l, o += 76 + 2 * (x + y) + (_ || 0) + l, --s || d()
                            }
                        };
                    if (x > 65535 && M("filename too long", null), A)
                        if (g < 16e4) try {
                            M(null, eu(p, f))
                        } catch (e) {
                            M(e, null)
                        } else h.push($h(p, f, M));
                        else M(null, p)
                }, f = 0; f < l; ++f) p(f);
            return u
        }

        function Yu(e, t) {
            t || (t = {});
            var n = {},
                i = [];
            Su(e, "", n, t);
            var r = 0,
                s = 0;
            for (var a in n) {
                var o = n[a],
                    l = o[0],
                    c = o[1],
                    h = 0 == c.level ? 0 : 8,
                    u = (A = Lu(a)).length,
                    d = c.comment,
                    p = d && Lu(d),
                    f = p && p.length,
                    m = Fu(c.extra);
                if (u > 65535) throw "filename too long";
                var g = h ? eu(l, c) : l,
                    v = g.length,
                    x = yh();
                x.p(l), i.push(Sh(c, {
                    size: l.length,
                    crc: x.d(),
                    c: g,
                    f: A,
                    m: p,
                    u: u != a.length || p && d.length != f,
                    o: r,
                    compression: h
                })), r += 30 + u + m + v, s += 76 + 2 * (u + m) + (f || 0) + v
            }
            for (var w = new Oc(s + 22), b = r, _ = s - r, y = 0; y < i.length; ++y) {
                var A = i[y];
                Uu(w, A.o, A, A.f, A.u, A.c.length);
                var M = 30 + A.f.length + Fu(A.extra);
                w.set(A.c, A.o + M), Uu(w, r, A, A.f, A.u, A.c.length, A.o, A.m), r += 16 + M + (A.m ? A.m.length : 0)
            }
            return zu(w, r, i.length, _, b), w
        }
        var Xu = function() {
                function e() {}
                return e.prototype.push = function(e, t) {
                    this.ondata(null, e, t)
                }, e.compression = 0, e
            }(),
            Qu = function() {
                function e() {
                    var e = this;
                    this.i = new tu((function(t, n) {
                        e.ondata(null, t, n)
                    }))
                }
                return e.prototype.push = function(e, t) {
                    try {
                        this.i.push(e, t)
                    } catch (n) {
                        this.ondata(n, e, t)
                    }
                }, e.compression = 8, e
            }(),
            qu = function() {
                function e(e, t) {
                    var n = this;
                    t < 32e4 ? this.i = new tu((function(e, t) {
                        n.ondata(null, e, t)
                    })) : (this.i = new nu((function(e, t, i) {
                        n.ondata(e, t, i)
                    })), this.terminate = this.i.terminate)
                }
                return e.prototype.push = function(e, t) {
                    this.i.terminate && (e = lh(e, 0)), this.i.push(e, t)
                }, e.compression = 8, e
            }(),
            Ku = function() {
                function e(e) {
                    this.onfile = e, this.k = [], this.o = {
                        0: Xu
                    }, this.p = wh
                }
                return e.prototype.push = function(e, t) {
                    var n = this;
                    if (!this.onfile) throw "no callback";
                    if (!this.p) throw "stream finished";
                    if (this.c > 0) {
                        var i = Math.min(this.c, e.length),
                            r = e.subarray(0, i);
                        if (this.c -= i, this.d ? this.d.push(r, !this.c) : this.k[0].push(r), (e = e.subarray(i)).length) return this.push(e, t)
                    } else {
                        var s = 0,
                            a = 0,
                            o = void 0,
                            l = void 0;
                        this.p.length ? e.length ? ((l = new Oc(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;
                        for (var c = l.length, h = this.c, u = h && this.d, d = function() {
                                var e, t = Vh(l, a);
                                if (67324752 == t) {
                                    s = 1, o = a, p.d = null, p.c = 0;
                                    var i = zh(l, a + 6),
                                        r = zh(l, a + 8),
                                        u = 2048 & i,
                                        d = 8 & i,
                                        f = zh(l, a + 26),
                                        m = zh(l, a + 28);
                                    if (c > a + 30 + f + m) {
                                        var g = [];
                                        p.k.unshift(g), s = 2;
                                        var v, x = Vh(l, a + 18),
                                            w = Vh(l, a + 22),
                                            b = Iu(l.subarray(a + 30, a += 30 + f), !u);
                                        4294967295 == x ? (e = d ? [-2] : Nu(l, a), x = e[0], w = e[1]) : d && (x = -1), a += m, p.c = x;
                                        var _ = {
                                            name: b,
                                            compression: r,
                                            start: function() {
                                                if (!_.ondata) throw "no callback";
                                                if (x) {
                                                    var e = n.o[r];
                                                    if (!e) throw "unknown compression type " + r;
                                                    (v = x < 0 ? new e(b) : new e(b, x, w)).ondata = function(e, t, n) {
                                                        _.ondata(e, t, n)
                                                    };
                                                    for (var t = 0, i = g; t < i.length; t++) {
                                                        var s = i[t];
                                                        v.push(s, !1)
                                                    }
                                                    n.k[0] == g && n.c ? n.d = v : v.push(wh, !0)
                                                } else _.ondata(null, wh, !0)
                                            },
                                            terminate: function() {
                                                v && v.terminate && v.terminate()
                                            }
                                        };
                                        x >= 0 && (_.size = x, _.originalSize = w), p.onfile(_)
                                    }
                                    return "break"
                                }
                                if (h) {
                                    if (134695760 == t) return o = a += 12 + (-2 == h && 8), s = 3, p.c = 0, "break";
                                    if (33639248 == t) return o = a -= 4, s = 3, p.c = 0, "break"
                                }
                            }, p = this; a < c - 4 && "break" !== d(); ++a);
                        if (this.p = wh, h < 0) {
                            var f = s ? l.subarray(0, o - 12 - (-2 == h && 8) - (134695760 == Vh(l, o - 16) && 4)) : l.subarray(0, a);
                            u ? u.push(f, !!s) : this.k[+(2 == s)].push(f)
                        }
                        if (2 & s) return this.push(l.subarray(a), t);
                        this.p = l.subarray(a)
                    }
                    if (t) {
                        if (this.c) throw "invalid zip file";
                        this.p = null
                    }
                }, e.prototype.register = function(e) {
                    this.o[e.compression] = e
                }, e
            }();

        function Zu(e, t) {
            if ("function" != typeof t) throw "no callback";
            for (var n = [], i = function() {
                    for (var e = 0; e < n.length; ++e) n[e]()
                }, r = {}, s = e.length - 22; 101010256 != Vh(e, s); --s)
                if (!s || e.length - s > 65558) return void t("invalid zip file", null);
            var a = zh(e, s + 8);
            a || t(null, {});
            var o = a,
                l = Vh(e, s + 16),
                c = 4294967295 == l;
            if (c) {
                if (s = Vh(e, s - 12), 101075792 != Vh(e, s)) return void t("invalid zip file", null);
                o = a = Vh(e, s + 32), l = Vh(e, s + 48)
            }
            for (var h = function(s) {
                    var o = ku(e, l, c),
                        h = o[0],
                        u = o[1],
                        d = o[2],
                        p = o[3],
                        f = o[4],
                        m = o[5],
                        g = Ou(e, m);
                    l = f;
                    var v = function(e, n) {
                        e ? (i(), t(e, null)) : (r[p] = n, --a || t(null, r))
                    };
                    if (h)
                        if (8 == h) {
                            var x = e.subarray(g, g + u);
                            if (u < 32e4) try {
                                v(null, ru(x, new Oc(d)))
                            } catch (e) {
                                v(e, null)
                            } else n.push(iu(x, {
                                size: d
                            }, v))
                        } else v("unknown compression type " + h, null);
                    else v(null, lh(e, g, g + u))
                }, u = 0; u < o; ++u) h();
            return i
        }

        function Ju(e) {
            for (var t = {}, n = e.length - 22; 101010256 != Vh(e, n); --n)
                if (!n || e.length - n > 65558) throw "invalid zip file";
            var i = zh(e, n + 8);
            if (!i) return {};
            var r = Vh(e, n + 16),
                s = 4294967295 == r;
            if (s) {
                if (n = Vh(e, n - 12), 101075792 != Vh(e, n)) throw "invalid zip file";
                i = Vh(e, n + 32), r = Vh(e, n + 48)
            }
            for (var a = 0; a < i; ++a) {
                var o = ku(e, r, s),
                    l = o[0],
                    c = o[1],
                    h = o[2],
                    u = o[3],
                    d = o[4],
                    p = o[5],
                    f = Ou(e, p);
                if (r = d, l) {
                    if (8 != l) throw "unknown compression type " + l;
                    t[u] = ru(e.subarray(f, f + c), new Oc(h))
                } else t[u] = lh(e, f, f + c)
            }
            return t
        }
        var $u = n(498);
        class ed {
            constructor(e, t = _c) {
                const n = new $u.Pane;
                this.pane = n, n.containerElem_.style.userSelect = "none", n.containerElem_.style.width = "380px", n.on("change", (t => {
                    const {
                        presetKey: n
                    } = t;
                    e[n] = t.value
                }));
                const i = n.addFolder({
                    title: "General"
                });
                i.addInput(t, "resolutionScale", {
                    min: .125,
                    max: 1,
                    step: .125
                }), i.addInput(t, "velocityResolutionScale", {
                    min: .125,
                    max: 1,
                    step: .125
                }), i.addInput(t, "intensity", {
                    min: 0,
                    max: 3,
                    step: .01
                }), i.addInput(t, "colorExponent", {
                    min: .125,
                    max: 4,
                    step: .125
                }), i.addInput(t, "rayDistance", {
                    min: .001,
                    max: 10,
                    step: .1
                }), i.addInput(t, "rayFadeOut", {
                    min: 0,
                    max: 20,
                    step: .01
                }), i.addInput(t, "roughnessFadeOut", {
                    min: 0,
                    max: 1,
                    step: .01
                }), i.addInput(t, "thickness", {
                    min: 0,
                    max: 10,
                    step: .01
                }), i.addInput(t, "ior", {
                    min: 1,
                    max: 2.33333,
                    step: .01
                });
                const r = n.addFolder({
                    title: "Maximum Values"
                });
                r.addInput(t, "maxDepthDifference", {
                    min: 0,
                    max: 100,
                    step: .1
                }), r.addInput(t, "maxRoughness", {
                    min: 0,
                    max: 1,
                    step: .01
                });
                const s = n.addFolder({
                    title: "Temporal Resolve"
                });
                s.addInput(t, "temporalResolve"), s.addInput(t, "temporalResolveMix", {
                    min: 0,
                    max: .975,
                    step: .001
                }), s.addInput(t, "temporalResolveCorrection", {
                    min: 0,
                    max: 1,
                    step: 1e-4
                }), s.addInput(t, "CLAMP_RADIUS", {
                    min: 1,
                    max: 4,
                    step: 1
                });
                const a = n.addFolder({
                    title: "Blur"
                });
                a.addInput(t, "blurMix", {
                    min: 0,
                    max: 1,
                    step: .01
                }), a.addInput(t, "blurSharpness", {
                    min: 0,
                    max: 100,
                    step: 1
                }), a.addInput(t, "blurKernelSize", {
                    min: 0,
                    max: 5,
                    step: 1
                });
                const o = n.addFolder({
                    title: "Jitter"
                });
                o.addInput(t, "jitter", {
                    min: 0,
                    max: .5,
                    step: .01
                }), o.addInput(t, "jitterRough", {
                    min: 0,
                    max: 1.5,
                    step: .01
                }), o.addInput(t, "jitterSpread", {
                    min: 0,
                    max: 5,
                    step: .01
                });
                const l = n.addFolder({
                    title: "Tracing"
                });
                l.addInput(t, "MAX_STEPS", {
                    min: 1,
                    max: 256,
                    step: 1
                }), l.addInput(t, "NUM_BINARY_SEARCH_STEPS", {
                    min: 0,
                    max: 16,
                    step: 1
                }), l.addInput(t, "ALLOW_MISSED_RAYS")
            }
        }
        document.getElementById("containerWebsite"), document.getElementById("btnVoltar"), document.getElementById("mapmode");
        const td = document.getElementById("header"),
            nd = document.getElementById("menu-hamburguer"),
            id = document.querySelector(".intro"),
            rd = (document.getElementById("btnExplorar"), document.getElementById("voltar"), document.querySelector(".loading-bar")),
            sd = (document.getElementById("btn-continue-explore"), document.getElementById("activate-effects"), document.querySelector(".lds-roller")),
            ad = document.getElementById("wrapper--pages");
        let od, ld, cd, hd, ud, dd, pd, fd, md, gd, vd, xd, wd, bd, _d, yd, Ad, Md = new Z,
            Sd = !0,
            Ed = !1,
            Td = !1,
            Cd = !1;
        const Dd = new Ga;
        let Pd, Rd, Ld, Id, Bd = !1,
            Od = "";
        const kd = document.getElementById("video2"),
            Nd = new Ks(kd);
        Nd.flipY = !1;
        let Fd = !0,
            Ud = !1;
        if (window.location.hash) var zd = window.location.hash.substring(1);
        else sd.parentNode.removeChild(sd);
        "debug" == zd && (Ud = !0, Ad = new Bl, window.setTimeout((function() {
            ld = new kl, document.body.appendChild(ld.dom), Gd.remove(ap), dd.target.set(0, 0, -7), dd.autoRotate = !1, dd.enabled = !0, dd.enableRotate = !0, od.lookAt(dd.target), dd.minDistance = 15, dd.maxDistance = 80, dd.zoomSpeed = .2, od.position.set(0, 2, 7), Id = new ed(up, hp), od.fov = 55, od.updateProjectionMatrix()
        }), 200), sd.parentNode.removeChild(sd)), 0 == Ud && (yd = new ga((() => {
            new wl.Tween(rp).to({
                opacity: .3
            }, 700).easing(wl.Easing.Quartic.InOut).start().onComplete((function() {
                td.classList.add("down"), 0 == Ud && (new wl.Tween(rp).to({
                    opacity: 0
                }, 1e3).easing(wl.Easing.Quartic.InOut).start().onComplete((function() {
                    Gd.remove(ap), wl.remove(this)
                })), new wl.Tween(dd.target).to({
                    x: -5.4,
                    y: -1.1,
                    z: -.2
                }, 5200).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                    wl.remove(this)
                })), new wl.Tween(od.position).to({
                    x: 6,
                    y: -.8,
                    z: -12
                }, 5200).easing(wl.Easing.Quadratic.InOut).start().onUpdate((function(e) {
                    od.lookAt(dd.target)
                })).onComplete((function() {
                    od.lookAt(dd.target), Cd = !0, wl.remove(this), id.classList.add("show"), document.getElementById("header").style.pointerEvents = "auto", rd.parentNode.removeChild(rd)
                }))), wl.remove(this)
            })), rd.style.transform = "", rd.classList.add("ended")
        }), ((e, t, n) => {
            const i = t / n;
            rd.style.transform = `scaleX(${i})`
        })));
        const Vd = new class extends xa {
            constructor(e) {
                super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e, this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e, this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e, this
            }
            load(e, t, n, i) {
                const r = new ba(this.manager);
                r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                    const n = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: !1
                    };
                    this.decodeGeometry(e, n).then(t).catch(i)
                }), n, i)
            }
            decodeDracoFile(e, t, n, i) {
                const r = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: i || this.defaultAttributeTypes,
                    useUniqueIDs: !!n
                };
                this.decodeGeometry(e, r).then(t)
            }
            decodeGeometry(e, t) {
                for (const e in t.attributeTypes) {
                    const n = t.attributeTypes[e];
                    void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name)
                }
                const n = JSON.stringify(t);
                if (gl.has(e)) {
                    const t = gl.get(e);
                    if (t.key === n) return t.promise;
                    if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let i;
                const r = this.workerNextTaskID++,
                    s = e.byteLength,
                    a = this._getWorker(r, s).then((n => (i = n, new Promise(((n, s) => {
                        i._callbacks[r] = {
                            resolve: n,
                            reject: s
                        }, i.postMessage({
                            type: "decode",
                            id: r,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }))))).then((e => this._createGeometry(e.geometry)));
                return a.catch((() => !0)).then((() => {
                    i && r && this._releaseTask(i, r)
                })), gl.set(e, {
                    key: n,
                    promise: a
                }), a
            }
            _createGeometry(e) {
                const t = new en;
                e.index && t.setIndex(new Gt(e.index.array, 1));
                for (let n = 0; n < e.attributes.length; n++) {
                    const i = e.attributes[n],
                        r = i.name,
                        s = i.array,
                        a = i.itemSize;
                    t.setAttribute(r, new Gt(s, a))
                }
                return t
            }
            _loadLibrary(e, t) {
                const n = new ba(this.manager);
                return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, i) => {
                    n.load(e, t, void 0, i)
                }))
            }
            preload() {
                return this._initDecoder(), this
            }
            _initDecoder() {
                if (this.decoderPending) return this.decoderPending;
                const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                    t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                    const n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    const i = vl.toString(),
                        r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                })), this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then((() => {
                    if (this.workerPool.length < this.workerLimit) {
                        const e = new Worker(this.workerSourceURL);
                        e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }), e.onmessage = function(t) {
                            const n = t.data;
                            switch (n.type) {
                                case "decode":
                                    e._callbacks[n.id].resolve(n);
                                    break;
                                case "error":
                                    e._callbacks[n.id].reject(n);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }, this.workerPool.push(e)
                    } else this.workerPool.sort((function(e, t) {
                        return e._taskLoad > t._taskLoad ? -1 : 1
                    }));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[e] = t, n._taskLoad += t, n
                }))
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                return this.workerPool.length = 0, this
            }
        };
        Vd.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"), Vd.setDecoderConfig({
            type: "js"
        }), 0 == Ud ? (bd = new Aa(yd), _d = new To(yd), _d.setDRACOLoader(Vd)) : (bd = new Aa, _d = new To, _d.setDRACOLoader(Vd));
        const Hd = document.createElement("div");
        document.body.appendChild(Hd);
        const Gd = new vs;
        Gd.background = new ue(0);
        const Wd = new gs({
            antialias: !1,
            powerPreference: "high-performance",
            stencil: !1
        });
        let jd;
        Wd.autoClear = !1, Wd.setPixelRatio(Math.min(window.devicePixelRatio, 1)), Wd.setSize(window.innerWidth, window.innerHeight), Wd.outputEncoding = R, Wd.toneMapping = 4, Hd.appendChild(Wd.domElement), "low" == zd && (Fd = !1, sd.parentNode.removeChild(sd));
        const Yd = new wn(new _n(2, 2, 2, 1, 1, 1), new class extends Ut {
            constructor(e) {
                super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Z(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
            }
        });

        function Xd() {
            Sd && (jd = new eo(gd), od.add(gd), vd = "./music/music.mp3", xd = new Audio("./music/music.mp3"), wd = new Ha(yd), Sd = !1), Td || ((new Ha).load("./music/music.mp3", (function(e) {
                jd.setBuffer(e), jd.setRefDistance(12), jd.loop = !0, jd.play(), Yd.add(jd)
            })), Td = !0)
        }
        Yd.position.set(0, 1, -8), Yd.rotation.set(0, 0, 0), Gd.add(Yd), Yd.visible = !1, gd = new class extends Et {
            constructor() {
                super(), this.type = "AudioListener", this.context = Va(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Ga
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            }
            getFilter() {
                return this.filter
            }
            setFilter(e) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e);
                const t = this.context.listener,
                    n = this.up;
                if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ja, Ya, Xa), Qa.set(0, 0, -1).applyQuaternion(Ya), t.positionX) {
                    const e = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(ja.x, e), t.positionY.linearRampToValueAtTime(ja.y, e), t.positionZ.linearRampToValueAtTime(ja.z, e), t.forwardX.linearRampToValueAtTime(Qa.x, e), t.forwardY.linearRampToValueAtTime(Qa.y, e), t.forwardZ.linearRampToValueAtTime(Qa.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
                } else t.setPosition(ja.x, ja.y, ja.z), t.setOrientation(Qa.x, Qa.y, Qa.z, n.x, n.y, n.z)
            }
        }, (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) && (Ed = !0);
        let Qd = [];
        Md = new Z, hd = new lo, ud = new lo;
        let qd = null,
            Kd = window.innerWidth,
            Zd = window.innerHeight,
            Jd = !0;

        function $d() {
            Jd = !1, Td && jd.pause()
        }

        function ep() {
            Jd = !0, Td && jd.play()
        }
        document.addEventListener("visibilitychange", (function() {
            document.hidden ? null != xd && $d() : null != xd && ep()
        }));
        const tp = new hs;
        Gd.add(tp), od = new Tn(55, window.innerWidth / window.innerHeight, .1, 80), od.position.set(9, 7, 7), tp.add(od), dd = new class extends Eo {
            constructor(e, t) {
                super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = 2, this.mouseButtons.RIGHT = 0, this.touches.ONE = 1, this.touches.TWO = 3
            }
        }(od, Wd.domElement), dd.target.set(-16, 3, 9), dd.enabled = !1, cd = new Oa(12626781, 1.2, 35), cd.position.set(3, 12, -11), cd.rotation.set(0, 0, -Math.PI / 2), Gd.add(cd);
        const np = new si(Wd);
        let ip;
        np.compileEquirectangularShader(), new class extends ya {
            constructor(e) {
                super(e), this.type = x
            }
            parse(t) {
                const n = 65536,
                    i = 14,
                    r = 65537,
                    s = Math.pow(2.7182818, 2.2),
                    a = {
                        l: 0,
                        c: 0,
                        lc: 0
                    };

                function o(e, t, n, i, r) {
                    for (; n < e;) t = t << 8 | H(i, r), n += 8;
                    n -= e, a.l = t >> n & (1 << e) - 1, a.c = t, a.lc = n
                }
                const l = new Array(59);

                function c(e) {
                    return 63 & e
                }

                function h(e) {
                    return e >> 6
                }
                const u = {
                    c: 0,
                    lc: 0
                };

                function d(e, t, n, i) {
                    e = e << 8 | H(n, i), t += 8, u.c = e, u.lc = t
                }
                const p = {
                    c: 0,
                    lc: 0
                };

                function f(e, t, n, i, r, s, a, o, l) {
                    if (e == t) {
                        i < 8 && (d(n, i, r, s), n = u.c, i = u.lc);
                        let e = n >> (i -= 8);
                        if (e = new Uint8Array([e])[0], o.value + e > l) return !1;
                        const t = a[o.value - 1];
                        for (; e-- > 0;) a[o.value++] = t
                    } else {
                        if (!(o.value < l)) return !1;
                        a[o.value++] = e
                    }
                    p.c = n, p.lc = i
                }

                function m(e) {
                    return 65535 & e
                }

                function g(e) {
                    const t = m(e);
                    return t > 32767 ? t - 65536 : t
                }
                const w = {
                    a: 0,
                    b: 0
                };

                function _(e, t) {
                    const n = g(e),
                        i = g(t),
                        r = n + (1 & i) + (i >> 1),
                        s = r,
                        a = r - i;
                    w.a = s, w.b = a
                }

                function y(e, t) {
                    const n = m(e),
                        i = m(t),
                        r = n - (i >> 1) & 65535,
                        s = i + r - 32768 & 65535;
                    w.a = s, w.b = r
                }

                function A(e, t, n, i, r, s, a) {
                    const o = a < 16384,
                        l = n > r ? r : n;
                    let c, h, u = 1;
                    for (; u <= l;) u <<= 1;
                    for (u >>= 1, c = u, u >>= 1; u >= 1;) {
                        h = 0;
                        const a = h + s * (r - c),
                            l = s * u,
                            d = s * c,
                            p = i * u,
                            f = i * c;
                        let m, g, v, x;
                        for (; h <= a; h += d) {
                            let r = h;
                            const s = h + i * (n - c);
                            for (; r <= s; r += f) {
                                const n = r + p,
                                    i = r + l,
                                    s = i + p;
                                o ? (_(e[r + t], e[i + t]), m = w.a, v = w.b, _(e[n + t], e[s + t]), g = w.a, x = w.b, _(m, g), e[r + t] = w.a, e[n + t] = w.b, _(v, x), e[i + t] = w.a, e[s + t] = w.b) : (y(e[r + t], e[i + t]), m = w.a, v = w.b, y(e[n + t], e[s + t]), g = w.a, x = w.b, y(m, g), e[r + t] = w.a, e[n + t] = w.b, y(v, x), e[i + t] = w.a, e[s + t] = w.b)
                            }
                            if (n & u) {
                                const n = r + l;
                                o ? _(e[r + t], e[n + t]) : y(e[r + t], e[n + t]), m = w.a, e[n + t] = w.b, e[r + t] = m
                            }
                        }
                        if (r & u) {
                            let r = h;
                            const s = h + i * (n - c);
                            for (; r <= s; r += f) {
                                const n = r + p;
                                o ? _(e[r + t], e[n + t]) : y(e[r + t], e[n + t]), m = w.a, e[n + t] = w.b, e[r + t] = m
                            }
                        }
                        c = u, u >>= 1
                    }
                    return h
                }

                function M(e, t, n, s, m, g) {
                    const v = n.value,
                        x = V(t, n),
                        w = V(t, n);
                    n.value += 4;
                    const b = V(t, n);
                    if (n.value += 4, x < 0 || x >= r || w < 0 || w >= r) throw new Error("Something wrong with HUF_ENCSIZE");
                    const _ = new Array(r),
                        y = new Array(16384);
                    if (function(e) {
                            for (let t = 0; t < 16384; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null
                        }(y), function(e, t, n, i, s, c) {
                            const h = t;
                            let u = 0,
                                d = 0;
                            for (; i <= s; i++) {
                                if (h.value - t.value > n) return !1;
                                o(6, u, d, e, h);
                                const r = a.l;
                                if (u = a.c, d = a.lc, c[i] = r, 63 == r) {
                                    if (h.value - t.value > n) throw new Error("Something wrong with hufUnpackEncTable");
                                    o(8, u, d, e, h);
                                    let r = a.l + 6;
                                    if (u = a.c, d = a.lc, i + r > s + 1) throw new Error("Something wrong with hufUnpackEncTable");
                                    for (; r--;) c[i++] = 0;
                                    i--
                                } else if (r >= 59) {
                                    let e = r - 59 + 2;
                                    if (i + e > s + 1) throw new Error("Something wrong with hufUnpackEncTable");
                                    for (; e--;) c[i++] = 0;
                                    i--
                                }
                            }! function(e) {
                                for (let e = 0; e <= 58; ++e) l[e] = 0;
                                for (let t = 0; t < r; ++t) l[e[t]] += 1;
                                let t = 0;
                                for (let e = 58; e > 0; --e) {
                                    const n = t + l[e] >> 1;
                                    l[e] = t, t = n
                                }
                                for (let t = 0; t < r; ++t) {
                                    const n = e[t];
                                    n > 0 && (e[t] = n | l[n]++ << 6)
                                }
                            }(c)
                        }(e, n, s - (n.value - v), x, w, _), b > 8 * (s - (n.value - v))) throw new Error("Something wrong with hufUncompress");
                    ! function(e, t, n, r) {
                        for (; t <= n; t++) {
                            const n = h(e[t]),
                                s = c(e[t]);
                            if (n >> s) throw new Error("Invalid table entry");
                            if (s > i) {
                                const e = r[n >> s - i];
                                if (e.len) throw new Error("Invalid table entry");
                                if (e.lit++, e.p) {
                                    const t = e.p;
                                    e.p = new Array(e.lit);
                                    for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n]
                                } else e.p = new Array(1);
                                e.p[e.lit - 1] = t
                            } else if (s) {
                                let e = 0;
                                for (let a = 1 << i - s; a > 0; a--) {
                                    const a = r[(n << i - s) + e];
                                    if (a.len || a.p) throw new Error("Invalid table entry");
                                    a.len = s, a.lit = t, e++
                                }
                            }
                        }
                    }(_, x, w, y),
                    function(e, t, n, r, s, a, o, l, m) {
                        let g = 0,
                            v = 0;
                        const x = o,
                            w = Math.trunc(r.value + (s + 7) / 8);
                        for (; r.value < w;)
                            for (d(g, v, n, r), g = u.c, v = u.lc; v >= i;) {
                                const s = t[g >> v - i & 16383];
                                if (s.len) v -= s.len, f(s.lit, a, g, v, n, r, l, m, x), g = p.c, v = p.lc;
                                else {
                                    if (!s.p) throw new Error("hufDecode issues");
                                    let t;
                                    for (t = 0; t < s.lit; t++) {
                                        const i = c(e[s.p[t]]);
                                        for (; v < i && r.value < w;) d(g, v, n, r), g = u.c, v = u.lc;
                                        if (v >= i && h(e[s.p[t]]) == (g >> v - i & (1 << i) - 1)) {
                                            v -= i, f(s.p[t], a, g, v, n, r, l, m, x), g = p.c, v = p.lc;
                                            break
                                        }
                                    }
                                    if (t == s.lit) throw new Error("hufDecode issues")
                                }
                            }
                        const b = 8 - s & 7;
                        for (g >>= b, v -= b; v > 0;) {
                            const e = t[g << i - v & 16383];
                            if (!e.len) throw new Error("hufDecode issues");
                            v -= e.len, f(e.lit, a, g, v, n, r, l, m, x), g = p.c, v = p.lc
                        }
                    }(_, y, e, n, b, w, g, m, {
                        value: 0
                    })
                }

                function S(e) {
                    for (let t = 1; t < e.length; t++) {
                        const n = e[t - 1] + e[t] - 128;
                        e[t] = n
                    }
                }

                function E(e, t) {
                    let n = 0,
                        i = Math.floor((e.length + 1) / 2),
                        r = 0;
                    const s = e.length - 1;
                    for (; !(r > s || (t[r++] = e[n++], r > s));) t[r++] = e[i++]
                }

                function T(e) {
                    let t = e.byteLength;
                    const n = new Array;
                    let i = 0;
                    const r = new DataView(e);
                    for (; t > 0;) {
                        const e = r.getInt8(i++);
                        if (e < 0) {
                            const s = -e;
                            t -= s + 1;
                            for (let e = 0; e < s; e++) n.push(r.getUint8(i++))
                        } else {
                            const s = e;
                            t -= 2;
                            const a = r.getUint8(i++);
                            for (let e = 0; e < s + 1; e++) n.push(a)
                        }
                    }
                    return n
                }

                function C(e, t, n) {
                    let i, r = 1;
                    for (; r < 64;) i = t[e.value], 65280 == i ? r = 64 : i >> 8 == 255 ? r += 255 & i : (n[r] = i, r++), e.value++
                }

                function D(e) {
                    const t = .5 * Math.cos(.7853975),
                        n = .5 * Math.cos(3.14159 / 16),
                        i = .5 * Math.cos(3.14159 / 8),
                        r = .5 * Math.cos(3 * 3.14159 / 16),
                        s = .5 * Math.cos(.981746875),
                        a = .5 * Math.cos(3 * 3.14159 / 8),
                        o = .5 * Math.cos(1.374445625),
                        l = new Array(4),
                        c = new Array(4),
                        h = new Array(4),
                        u = new Array(4);
                    for (let d = 0; d < 8; ++d) {
                        const p = 8 * d;
                        l[0] = i * e[p + 2], l[1] = a * e[p + 2], l[2] = i * e[p + 6], l[3] = a * e[p + 6], c[0] = n * e[p + 1] + r * e[p + 3] + s * e[p + 5] + o * e[p + 7], c[1] = r * e[p + 1] - o * e[p + 3] - n * e[p + 5] - s * e[p + 7], c[2] = s * e[p + 1] - n * e[p + 3] + o * e[p + 5] + r * e[p + 7], c[3] = o * e[p + 1] - s * e[p + 3] + r * e[p + 5] - n * e[p + 7], h[0] = t * (e[p + 0] + e[p + 4]), h[3] = t * (e[p + 0] - e[p + 4]), h[1] = l[0] + l[3], h[2] = l[1] - l[2], u[0] = h[0] + h[1], u[1] = h[3] + h[2], u[2] = h[3] - h[2], u[3] = h[0] - h[1], e[p + 0] = u[0] + c[0], e[p + 1] = u[1] + c[1], e[p + 2] = u[2] + c[2], e[p + 3] = u[3] + c[3], e[p + 4] = u[3] - c[3], e[p + 5] = u[2] - c[2], e[p + 6] = u[1] - c[1], e[p + 7] = u[0] - c[0]
                    }
                    for (let d = 0; d < 8; ++d) l[0] = i * e[16 + d], l[1] = a * e[16 + d], l[2] = i * e[48 + d], l[3] = a * e[48 + d], c[0] = n * e[8 + d] + r * e[24 + d] + s * e[40 + d] + o * e[56 + d], c[1] = r * e[8 + d] - o * e[24 + d] - n * e[40 + d] - s * e[56 + d], c[2] = s * e[8 + d] - n * e[24 + d] + o * e[40 + d] + r * e[56 + d], c[3] = o * e[8 + d] - s * e[24 + d] + r * e[40 + d] - n * e[56 + d], h[0] = t * (e[d] + e[32 + d]), h[3] = t * (e[d] - e[32 + d]), h[1] = l[0] + l[3], h[2] = l[1] - l[2], u[0] = h[0] + h[1], u[1] = h[3] + h[2], u[2] = h[3] - h[2], u[3] = h[0] - h[1], e[0 + d] = u[0] + c[0], e[8 + d] = u[1] + c[1], e[16 + d] = u[2] + c[2], e[24 + d] = u[3] + c[3], e[32 + d] = u[3] - c[3], e[40 + d] = u[2] - c[2], e[48 + d] = u[1] - c[1], e[56 + d] = u[0] - c[0]
                }

                function R(e) {
                    for (let t = 0; t < 64; ++t) {
                        const n = e[0][t],
                            i = e[1][t],
                            r = e[2][t];
                        e[0][t] = n + 1.5747 * r, e[1][t] = n - .1873 * i - .4682 * r, e[2][t] = n + 1.8556 * i
                    }
                }

                function L(e, t, n) {
                    for (let r = 0; r < 64; ++r) t[n + r] = _o.toHalfFloat((i = e[r]) <= 1 ? Math.sign(i) * Math.pow(Math.abs(i), 2.2) : Math.sign(i) * Math.pow(s, Math.abs(i) - 1));
                    var i
                }

                function I(e) {
                    return new DataView(e.array.buffer, e.offset.value, e.size)
                }

                function B(e) {
                    const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
                        n = new Uint8Array(T(t)),
                        i = new Uint8Array(n.length);
                    return S(n), E(n, i), new DataView(i.buffer)
                }

                function O(t) {
                    const n = t.array.slice(t.offset.value, t.offset.value + t.size);
                    void 0 === e && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                    const i = bu(n),
                        r = new Uint8Array(i.length);
                    return S(i), E(i, r), new DataView(r.buffer)
                }

                function k(e) {
                    const t = e.viewer,
                        i = {
                            value: e.offset.value
                        },
                        r = new Uint16Array(e.width * e.scanlineBlockSize * (e.channels * e.type)),
                        s = new Uint8Array(8192);
                    let a = 0;
                    const o = new Array(e.channels);
                    for (let t = 0; t < e.channels; t++) o[t] = {}, o[t].start = a, o[t].end = o[t].start, o[t].nx = e.width, o[t].ny = e.lines, o[t].size = e.type, a += o[t].nx * o[t].ny * o[t].size;
                    const l = Q(t, i),
                        c = Q(t, i);
                    if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
                    if (l <= c)
                        for (let e = 0; e < c - l + 1; e++) s[e + l] = G(t, i);
                    const h = new Uint16Array(n),
                        u = function(e, t) {
                            let i = 0;
                            for (let r = 0; r < n; ++r)(0 == r || e[r >> 3] & 1 << (7 & r)) && (t[i++] = r);
                            const r = i - 1;
                            for (; i < n;) t[i++] = 0;
                            return r
                        }(s, h),
                        d = V(t, i);
                    M(e.array, t, i, d, r, a);
                    for (let t = 0; t < e.channels; ++t) {
                        const e = o[t];
                        for (let n = 0; n < o[t].size; ++n) A(r, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, u)
                    }! function(e, t, n) {
                        for (let i = 0; i < n; ++i) t[i] = e[t[i]]
                    }(h, r, a);
                    let p = 0;
                    const f = new Uint8Array(r.buffer.byteLength);
                    for (let t = 0; t < e.lines; t++)
                        for (let t = 0; t < e.channels; t++) {
                            const e = o[t],
                                n = e.nx * e.size,
                                i = new Uint8Array(r.buffer, 2 * e.end, 2 * n);
                            f.set(i, p), p += 2 * n, e.end += n
                        }
                    return new DataView(f.buffer)
                }

                function N(t) {
                    const n = t.array.slice(t.offset.value, t.offset.value + t.size);
                    void 0 === e && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                    const i = bu(n),
                        r = t.lines * t.channels * t.width,
                        s = 1 == t.type ? new Uint16Array(r) : new Uint32Array(r);
                    let a = 0,
                        o = 0;
                    const l = new Array(4);
                    for (let e = 0; e < t.lines; e++)
                        for (let e = 0; e < t.channels; e++) {
                            let e = 0;
                            switch (t.type) {
                                case 1:
                                    l[0] = a, l[1] = l[0] + t.width, a = l[1] + t.width;
                                    for (let n = 0; n < t.width; ++n) e += i[l[0]++] << 8 | i[l[1]++], s[o] = e, o++;
                                    break;
                                case 2:
                                    l[0] = a, l[1] = l[0] + t.width, l[2] = l[1] + t.width, a = l[2] + t.width;
                                    for (let n = 0; n < t.width; ++n) e += i[l[0]++] << 24 | i[l[1]++] << 16 | i[l[2]++] << 8, s[o] = e, o++
                            }
                        }
                    return new DataView(s.buffer)
                }

                function F(e) {
                    const t = e.viewer,
                        n = {
                            value: e.offset.value
                        },
                        i = new Uint8Array(e.width * e.lines * (e.channels * e.type * 2)),
                        r = {
                            version: W(t, n),
                            unknownUncompressedSize: W(t, n),
                            unknownCompressedSize: W(t, n),
                            acCompressedSize: W(t, n),
                            dcCompressedSize: W(t, n),
                            rleCompressedSize: W(t, n),
                            rleUncompressedSize: W(t, n),
                            rleRawSize: W(t, n),
                            totalAcUncompressedCount: W(t, n),
                            totalDcUncompressedCount: W(t, n),
                            acCompression: W(t, n)
                        };
                    if (r.version < 2) throw new Error("EXRLoader.parse: " + ee.compression + " version " + r.version + " is unsupported");
                    const s = new Array;
                    let a = Q(t, n) - 2;
                    for (; a > 0;) {
                        const e = U(t.buffer, n),
                            i = G(t, n),
                            r = i >> 2 & 3,
                            o = new Int8Array([(i >> 4) - 1])[0],
                            l = G(t, n);
                        s.push({
                            name: e,
                            index: o,
                            type: l,
                            compression: r
                        }), a -= e.length + 3
                    }
                    const o = ee.channels,
                        l = new Array(e.channels);
                    for (let t = 0; t < e.channels; ++t) {
                        const n = l[t] = {},
                            i = o[t];
                        n.name = i.name, n.compression = 0, n.decoded = !1, n.type = i.pixelType, n.pLinear = i.pLinear, n.width = e.width, n.height = e.lines
                    }
                    const c = {
                        idx: new Array(3)
                    };
                    for (let t = 0; t < e.channels; ++t) {
                        const e = l[t];
                        for (let n = 0; n < s.length; ++n) {
                            const i = s[n];
                            e.name == i.name && (e.compression = i.compression, i.index >= 0 && (c.idx[i.index] = t), e.offset = t)
                        }
                    }
                    let h, u, d;
                    if (r.acCompressedSize > 0) switch (r.acCompression) {
                        case 0:
                            h = new Uint16Array(r.totalAcUncompressedCount), M(e.array, t, n, r.acCompressedSize, h, r.totalAcUncompressedCount);
                            break;
                        case 1:
                            const i = bu(e.array.slice(n.value, n.value + r.totalAcUncompressedCount));
                            h = new Uint16Array(i.buffer), n.value += r.totalAcUncompressedCount
                    }
                    if (r.dcCompressedSize > 0) {
                        const t = {
                            array: e.array,
                            offset: n,
                            size: r.dcCompressedSize
                        };
                        u = new Uint16Array(O(t).buffer), n.value += r.dcCompressedSize
                    }
                    r.rleRawSize > 0 && (d = T(bu(e.array.slice(n.value, n.value + r.rleCompressedSize)).buffer), n.value += r.rleCompressedSize);
                    let p = 0;
                    const f = new Array(l.length);
                    for (let e = 0; e < f.length; ++e) f[e] = new Array;
                    for (let t = 0; t < e.lines; ++t)
                        for (let t = 0; t < l.length; ++t) f[t].push(p), p += l[t].width * e.type * 2;
                    ! function(e, t, n, i, r, s) {
                        let a = new DataView(s.buffer);
                        const o = n[e.idx[0]].width,
                            l = n[e.idx[0]].height,
                            c = Math.floor(o / 8),
                            h = Math.ceil(o / 8),
                            u = Math.ceil(l / 8),
                            d = o - 8 * (h - 1),
                            p = l - 8 * (u - 1),
                            f = {
                                value: 0
                            },
                            m = new Array(3),
                            g = new Array(3),
                            v = new Array(3),
                            x = new Array(3),
                            w = new Array(3);
                        for (let n = 0; n < 3; ++n) w[n] = t[e.idx[n]], m[n] = n < 1 ? 0 : m[n - 1] + h * u, g[n] = new Float32Array(64), v[n] = new Uint16Array(64), x[n] = new Uint16Array(64 * h);
                        for (let t = 0; t < u; ++t) {
                            let s = 8;
                            t == u - 1 && (s = p);
                            let o = 8;
                            for (let e = 0; e < h; ++e) {
                                e == h - 1 && (o = d);
                                for (let e = 0; e < 3; ++e) v[e].fill(0), v[e][0] = r[m[e]++], C(f, i, v[e]), b = v[e], (_ = g[e])[0] = X(b[0]), _[1] = X(b[1]), _[2] = X(b[5]), _[3] = X(b[6]), _[4] = X(b[14]), _[5] = X(b[15]), _[6] = X(b[27]), _[7] = X(b[28]), _[8] = X(b[2]), _[9] = X(b[4]), _[10] = X(b[7]), _[11] = X(b[13]), _[12] = X(b[16]), _[13] = X(b[26]), _[14] = X(b[29]), _[15] = X(b[42]), _[16] = X(b[3]), _[17] = X(b[8]), _[18] = X(b[12]), _[19] = X(b[17]), _[20] = X(b[25]), _[21] = X(b[30]), _[22] = X(b[41]), _[23] = X(b[43]), _[24] = X(b[9]), _[25] = X(b[11]), _[26] = X(b[18]), _[27] = X(b[24]), _[28] = X(b[31]), _[29] = X(b[40]), _[30] = X(b[44]), _[31] = X(b[53]), _[32] = X(b[10]), _[33] = X(b[19]), _[34] = X(b[23]), _[35] = X(b[32]), _[36] = X(b[39]), _[37] = X(b[45]), _[38] = X(b[52]), _[39] = X(b[54]), _[40] = X(b[20]), _[41] = X(b[22]), _[42] = X(b[33]), _[43] = X(b[38]), _[44] = X(b[46]), _[45] = X(b[51]), _[46] = X(b[55]), _[47] = X(b[60]), _[48] = X(b[21]), _[49] = X(b[34]), _[50] = X(b[37]), _[51] = X(b[47]), _[52] = X(b[50]), _[53] = X(b[56]), _[54] = X(b[59]), _[55] = X(b[61]), _[56] = X(b[35]), _[57] = X(b[36]), _[58] = X(b[48]), _[59] = X(b[49]), _[60] = X(b[57]), _[61] = X(b[58]), _[62] = X(b[62]), _[63] = X(b[63]), D(g[e]);
                                R(g);
                                for (let t = 0; t < 3; ++t) L(g[t], x[t], 64 * e)
                            }
                            let l = 0;
                            for (let i = 0; i < 3; ++i) {
                                const r = n[e.idx[i]].type;
                                for (let e = 8 * t; e < 8 * t + s; ++e) {
                                    l = w[i][e];
                                    for (let t = 0; t < c; ++t) {
                                        const n = 64 * t + 8 * (7 & e);
                                        a.setUint16(l + 0 * r, x[i][n + 0], !0), a.setUint16(l + 2 * r, x[i][n + 1], !0), a.setUint16(l + 4 * r, x[i][n + 2], !0), a.setUint16(l + 6 * r, x[i][n + 3], !0), a.setUint16(l + 8 * r, x[i][n + 4], !0), a.setUint16(l + 10 * r, x[i][n + 5], !0), a.setUint16(l + 12 * r, x[i][n + 6], !0), a.setUint16(l + 14 * r, x[i][n + 7], !0), l += 16 * r
                                    }
                                }
                                if (c != h)
                                    for (let e = 8 * t; e < 8 * t + s; ++e) {
                                        const t = w[i][e] + 8 * c * 2 * r,
                                            n = 64 * c + 8 * (7 & e);
                                        for (let e = 0; e < o; ++e) a.setUint16(t + 2 * e * r, x[i][n + e], !0)
                                    }
                            }
                        }
                        var b, _;
                        const y = new Uint16Array(o);
                        a = new DataView(s.buffer);
                        for (let t = 0; t < 3; ++t) {
                            n[e.idx[t]].decoded = !0;
                            const i = n[e.idx[t]].type;
                            if (2 == n[t].type)
                                for (let e = 0; e < l; ++e) {
                                    const n = w[t][e];
                                    for (let e = 0; e < o; ++e) y[e] = a.getUint16(n + 2 * e * i, !0);
                                    for (let e = 0; e < o; ++e) a.setFloat32(n + 2 * e * i, X(y[e]), !0)
                                }
                        }
                    }(c, f, l, h, u, i);
                    for (let t = 0; t < l.length; ++t) {
                        const n = l[t];
                        if (!n.decoded) {
                            if (2 !== n.compression) throw new Error("EXRLoader.parse: unsupported channel compression"); {
                                let r = 0,
                                    s = 0;
                                for (let a = 0; a < e.lines; ++a) {
                                    let e = f[t][r];
                                    for (let t = 0; t < n.width; ++t) {
                                        for (let t = 0; t < 2 * n.type; ++t) i[e++] = d[s + t * n.width * n.height];
                                        s++
                                    }
                                    r++
                                }
                            }
                        }
                    }
                    return new DataView(i.buffer)
                }

                function U(e, t) {
                    const n = new Uint8Array(e);
                    let i = 0;
                    for (; 0 != n[t.value + i];) i += 1;
                    const r = (new TextDecoder).decode(n.slice(t.value, t.value + i));
                    return t.value = t.value + i + 1, r
                }

                function z(e, t) {
                    const n = e.getInt32(t.value, !0);
                    return t.value = t.value + 4, n
                }

                function V(e, t) {
                    const n = e.getUint32(t.value, !0);
                    return t.value = t.value + 4, n
                }

                function H(e, t) {
                    const n = e[t.value];
                    return t.value = t.value + 1, n
                }

                function G(e, t) {
                    const n = e.getUint8(t.value);
                    return t.value = t.value + 1, n
                }
                const W = function(e, t) {
                    const n = Number(e.getBigInt64(t.value, !0));
                    return t.value += 8, n
                };

                function j(e, t) {
                    const n = e.getFloat32(t.value, !0);
                    return t.value += 4, n
                }

                function Y(e, t) {
                    return _o.toHalfFloat(j(e, t))
                }

                function X(e) {
                    const t = (31744 & e) >> 10,
                        n = 1023 & e;
                    return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
                }

                function Q(e, t) {
                    const n = e.getUint16(t.value, !0);
                    return t.value += 2, n
                }

                function q(e, t) {
                    return X(Q(e, t))
                }

                function K(e, t, n, i, r) {
                    return "string" === i || "stringvector" === i || "iccProfile" === i ? function(e, t, n) {
                        const i = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + n));
                        return t.value = t.value + n, i
                    }(t, n, r) : "chlist" === i ? function(e, t, n, i) {
                        const r = n.value,
                            s = [];
                        for (; n.value < r + i - 1;) {
                            const i = U(t, n),
                                r = z(e, n),
                                a = G(e, n);
                            n.value += 3;
                            const o = z(e, n),
                                l = z(e, n);
                            s.push({
                                name: i,
                                pixelType: r,
                                pLinear: a,
                                xSampling: o,
                                ySampling: l
                            })
                        }
                        return n.value += 1, s
                    }(e, t, n, r) : "chromaticities" === i ? function(e, t) {
                        return {
                            redX: j(e, t),
                            redY: j(e, t),
                            greenX: j(e, t),
                            greenY: j(e, t),
                            blueX: j(e, t),
                            blueY: j(e, t),
                            whiteX: j(e, t),
                            whiteY: j(e, t)
                        }
                    }(e, n) : "compression" === i ? function(e, t) {
                        return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][G(e, t)]
                    }(e, n) : "box2i" === i ? function(e, t) {
                        return {
                            xMin: V(e, t),
                            yMin: V(e, t),
                            xMax: V(e, t),
                            yMax: V(e, t)
                        }
                    }(e, n) : "lineOrder" === i ? function(e, t) {
                        return ["INCREASING_Y"][G(e, t)]
                    }(e, n) : "float" === i ? j(e, n) : "v2f" === i ? function(e, t) {
                        return [j(e, t), j(e, t)]
                    }(e, n) : "v3f" === i ? function(e, t) {
                        return [j(e, t), j(e, t), j(e, t)]
                    }(e, n) : "int" === i ? z(e, n) : "rational" === i ? function(e, t) {
                        return [z(e, t), V(e, t)]
                    }(e, n) : "timecode" === i ? function(e, t) {
                        return [V(e, t), V(e, t)]
                    }(e, n) : "preview" === i ? (n.value += r, "skipped") : void(n.value += r)
                }
                const Z = new DataView(t),
                    J = new Uint8Array(t),
                    $ = {
                        value: 0
                    },
                    ee = function(e, t, n) {
                        const i = {};
                        if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
                        i.version = e.getUint8(4);
                        const r = e.getUint8(5);
                        i.spec = {
                            singleTile: !!(2 & r),
                            longName: !!(4 & r),
                            deepFormat: !!(8 & r),
                            multiPart: !!(16 & r)
                        }, n.value = 8;
                        let s = !0;
                        for (; s;) {
                            const r = U(t, n);
                            if (0 == r) s = !1;
                            else {
                                const s = U(t, n),
                                    a = K(e, t, n, s, V(e, n));
                                void 0 === a ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s}'.`) : i[r] = a
                            }
                        }
                        if (0 != (-5 & r)) throw console.error("EXRHeader:", i), new Error("THREE.EXRLoader: provided file is currently unsupported.");
                        return i
                    }(Z, t, $),
                    te = function(e, t, n, i, r) {
                        const s = {
                            size: 0,
                            viewer: t,
                            array: n,
                            offset: i,
                            width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                            height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                            channels: e.channels.length,
                            bytesPerLine: null,
                            lines: null,
                            inputSize: null,
                            type: e.channels[0].pixelType,
                            uncompress: null,
                            getter: null,
                            format: null,
                            encoding: null
                        };
                        switch (e.compression) {
                            case "NO_COMPRESSION":
                                s.lines = 1, s.uncompress = I;
                                break;
                            case "RLE_COMPRESSION":
                                s.lines = 1, s.uncompress = B;
                                break;
                            case "ZIPS_COMPRESSION":
                                s.lines = 1, s.uncompress = O;
                                break;
                            case "ZIP_COMPRESSION":
                                s.lines = 16, s.uncompress = O;
                                break;
                            case "PIZ_COMPRESSION":
                                s.lines = 32, s.uncompress = k;
                                break;
                            case "PXR24_COMPRESSION":
                                s.lines = 16, s.uncompress = N;
                                break;
                            case "DWAA_COMPRESSION":
                                s.lines = 32, s.uncompress = F;
                                break;
                            case "DWAB_COMPRESSION":
                                s.lines = 256, s.uncompress = F;
                                break;
                            default:
                                throw new Error("EXRLoader.parse: " + e.compression + " is unsupported")
                        }
                        if (s.scanlineBlockSize = s.lines, 1 == s.type) switch (r) {
                            case v:
                                s.getter = q, s.inputSize = 2;
                                break;
                            case x:
                                s.getter = Q, s.inputSize = 2
                        } else {
                            if (2 != s.type) throw new Error("EXRLoader.parse: unsupported pixelType " + s.type + " for " + e.compression + ".");
                            switch (r) {
                                case v:
                                    s.getter = j, s.inputSize = 4;
                                    break;
                                case x:
                                    s.getter = Y, s.inputSize = 4
                            }
                        }
                        s.blockCount = (e.dataWindow.yMax + 1) / s.scanlineBlockSize;
                        for (let e = 0; e < s.blockCount; e++) W(t, i);
                        s.outputChannels = 3 == s.channels ? 4 : s.channels;
                        const a = s.width * s.height * s.outputChannels;
                        switch (r) {
                            case v:
                                s.byteArray = new Float32Array(a), s.channels < s.outputChannels && s.byteArray.fill(1, 0, a);
                                break;
                            case x:
                                s.byteArray = new Uint16Array(a), s.channels < s.outputChannels && s.byteArray.fill(15360, 0, a);
                                break;
                            default:
                                console.error("THREE.EXRLoader: unsupported type: ", r)
                        }
                        return s.bytesPerLine = s.width * s.inputSize * s.channels, 4 == s.outputChannels ? (s.format = b, s.encoding = P) : (s.format = 1028, s.encoding = P), s
                    }(ee, Z, J, $, this.type),
                    ne = {
                        value: 0
                    },
                    ie = {
                        R: 0,
                        G: 1,
                        B: 2,
                        A: 3,
                        Y: 0
                    };
                for (let e = 0; e < te.height / te.scanlineBlockSize; e++) {
                    const t = V(Z, $);
                    te.size = V(Z, $), te.lines = t + te.scanlineBlockSize > te.height ? te.height - t : te.scanlineBlockSize;
                    const n = te.size < te.lines * te.bytesPerLine ? te.uncompress(te) : I(te);
                    $.value += te.size;
                    for (let t = 0; t < te.scanlineBlockSize; t++) {
                        const i = t + e * te.scanlineBlockSize;
                        if (i >= te.height) break;
                        for (let e = 0; e < te.channels; e++) {
                            const r = ie[ee.channels[e].name];
                            for (let s = 0; s < te.width; s++) {
                                ne.value = (t * (te.channels * te.width) + e * te.width + s) * te.inputSize;
                                const a = (te.height - 1 - i) * (te.width * te.outputChannels) + s * te.outputChannels + r;
                                te.byteArray[a] = te.getter(n, ne)
                            }
                        }
                    }
                }
                return {
                    header: ee,
                    width: te.width,
                    height: te.height,
                    data: te.byteArray,
                    format: te.format,
                    encoding: te.encoding,
                    type: this.type
                }
            }
            setDataType(e) {
                return this.type = e, this
            }
            load(e, t, n, i) {
                return super.load(e, (function(e, n) {
                    e.encoding = n.encoding, e.minFilter = p, e.magFilter = p, e.generateMipmaps = !1, e.flipY = !1, t && t(e, n)
                }), n, i)
            }
        }(yd).load("textures/pretville_cinema_1k.exr", (function(e) {
            const t = np.fromEquirectangular(e);
            ip = t ? t.texture : null, Gd.environment = ip, e.dispose()
        }));
        const rp = new zt({
                color: 0,
                transparent: !0,
                side: 2
            }),
            sp = new Vn(Kd, Zd, 1, 1),
            ap = new wn(sp, rp);
        let op;
        ap.position.set(od.position.x + 5, od.position.y, od.position.z), ap.lookAt(od.position), ap.rotation.set(0, Math.PI, Math.PI / 2), 0 == Ud && Gd.add(ap), _d.load("models/gltf/scene4.glb", (function(e) {
            e.scene.traverse((e => {
                e.isMesh && (e.frustumCulled = !1, e.castShadow = !0, e.receiveShadow = !0, "screen" == e.material.name && (op = e, e.material.map = Nd, e.material.emissiveMap = Nd, e.material.emissiveIntensity = .7), e.name.match(/^chair_/) && (Qd.push(e), e.material.emissiveIntensity = 0))
            })), Gd.add(e.scene)
        })), document.addEventListener("mousemove", (function(e) {
            if (Dp(e), Md.x = e.clientX / window.innerWidth * 2 - 1, Md.y = -e.clientY / window.innerHeight * 2 + 1, mp.x = e.clientX / window.innerWidth - .5, mp.y = e.clientY / window.innerHeight - .5, fd = e.clientX - window.innerWidth / 2, md = e.clientY - window.innerHeight / 2, hd.setFromCamera(Md, od), pd = hd.intersectObjects(Qd), !Ud)
                if (pd.length > 0 & !fp & dd.enabled) {
                    if (pd[0].object.visible) {
                        qd = pd[0].object;
                        for (const e of Qd) e.material.emissiveIntensity = 0;
                        qd.material.emissiveIntensity = 1, document.body.style.cursor = "pointer", gp()
                    }
                } else {
                    if (dd.enabled) {
                        document.body.style.cursor = fp ? "grabbing" : "grab", gp();
                        for (const e of Qd) e.material.emissiveIntensity = 1
                    }
                    qd = null
                }
        }), !1), document.addEventListener("mousedown", (function() {
            setTimeout((() => {
                fp = !0
            }), 100)
        })), document.addEventListener("mouseup", (function() {
            setTimeout((() => {
                fp = !1
            }), 100)
        })), document.addEventListener("click", (function() {
            fp || qd && (function(e) {
                dd.enabled = !1, xp(), Pd.parentNode.classList.remove("show"), document.querySelector(".seats--main--container").classList.add("hide"), Rd.classList.add("show"), document.getElementById("cart").checked = !1;
                const t = e.name.match(/\_(.*)$/);
                document.querySelector(".chair--name").innerHTML = this != `SEAT ${t[1]}` ? `SEAT ${t[1]}` : "", document.querySelector(".chair--price").innerHTML = this != `PRICE: $${e.userData.price}` ? `PRICE: $${e.userData.price}` : "", new wl.Tween(dd.target).to({
                    x: -.3,
                    y: 0,
                    z: -9
                }, 2e3).easing(wl.Easing.Quadratic.InOut).start().onUpdate((function() {})).onComplete((function() {
                    wl.remove(this)
                }));
                var n = od.position.clone(),
                    i = e.position.clone(),
                    r = n.sub(i),
                    s = r.normalize(),
                    a = r.clone().sub(s.multiplyScalar(15));
                e.position.clone().sub(a), new wl.Tween(od.position).to({
                    x: e.position.x,
                    y: e.position.y + .7,
                    z: e.position.z
                }, 2e3).easing(wl.Easing.Quartic.InOut).start().onUpdate((function() {})).onComplete((function() {
                    wl.remove(this)
                }))
            }(qd), document.body.style.cursor = "default")
        })), window.addEventListener("blur", $d), window.addEventListener("focus", ep), window.addEventListener("resize", (function() {
            Kd = window.innerWidth, Zd = window.innerHeight, od.aspect = Kd / Zd, od.updateProjectionMatrix(), Wd.setSize(Kd, Zd), Wd.setPixelRatio(Math.min(window.devicePixelRatio, 1))
        })), nd.addEventListener("click", (function() {
            document.querySelector('input[name="menu-hamburguer"]:checked')
        })), document.querySelector(".intro--button").addEventListener("click", (() => {
            Sp.classList.remove("arrow"), kd.play(), new wl.Tween(dd.target).to({
                x: 0,
                y: 4,
                z: 0
            }, 3e3).delay(2500).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                wl.remove(this)
            })), new wl.Tween(od.position).to({
                x: 0,
                y: 7.5,
                z: 12
            }, 4e3).delay(300).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                dd.enabled = !0, Xd(), Lp("seats"), vp()
            })), new wl.Tween(od).to({
                fov: 70
            }, 2e3).delay(700).start().onUpdate((() => {
                od.updateProjectionMatrix()
            })), id.classList.remove("show"), td.classList.remove("down")
        })), document.querySelector(".main--menu .home").addEventListener("click", (() => {
            wp(), Ip()
        })), document.querySelector(".main--menu .projects").addEventListener("click", (() => {
            id.classList.remove("show"), document.getElementById("header").style.pointerEvents = "none", document.querySelector(".main--menu .home").classList.remove("active"), document.querySelector(".main--menu .projects").classList.add("active"), new wl.Tween(dd.target).to({
                x: -1.8,
                y: 6.7,
                z: -17
            }, 2e3).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                wl.remove(this)
            })), new wl.Tween(od.position).to({
                x: 4.6,
                y: -.5,
                z: 5.2
            }, 2e3).easing(wl.Easing.Quadratic.InOut).start().onUpdate((function(e) {
                od.lookAt(dd.target)
            })).onComplete((function() {
                od.lookAt(dd.target), op.visible = !0, kd.play(), Lp("season")
            }))
        })), document.querySelector(".main--menu .about").addEventListener("click", (() => {
            document.querySelector(".about--container").style.display = "flex"
        })), document.querySelector(".about--cloose").addEventListener("click", (() => {
            document.querySelector(".about--container").style.display = "none"
        }));
        const lp = new class {
                constructor(e = null, {
                    depthBuffer: t = !0,
                    stencilBuffer: n = !1,
                    multisampling: i = 0,
                    frameBufferType: r
                } = {}) {
                    this.renderer = null, this.inputBuffer = this.createBuffer(t, n, r, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new jl, this.depthTexture = null, this.passes = [], this.timer = new class {
                        constructor() {
                            this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1, this.autoReset = !1
                        }
                        setFixedDeltaEnabled(e) {
                            return this.fixedDeltaEnabled = e, this
                        }
                        isAutoResetEnabled(e) {
                            return this.autoReset
                        }
                        setAutoResetEnabled(e) {
                            return "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this.autoReset = e), this
                        }
                        getDelta() {
                            return this.delta * sc
                        }
                        getFixedDelta() {
                            return this.fixedDelta * sc
                        }
                        setFixedDelta(e) {
                            return this.fixedDelta = 1e3 * e, this
                        }
                        getElapsed() {
                            return this.elapsed * sc
                        }
                        getTimescale() {
                            return this.timescale
                        }
                        setTimescale(e) {
                            return this.timescale = e, this
                        }
                        update(e) {
                            return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = void 0 !== e ? e : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.delta, this
                        }
                        reset() {
                            return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this
                        }
                        handleEvent(e) {
                            document.hidden || (this.currentTime = performance.now())
                        }
                        dispose() {
                            this.setAutoResetEnabled(!1)
                        }
                    }, this.autoRenderToScreen = !0, this.setRenderer(e)
                }
                get multisampling() {
                    return this.inputBuffer.samples || 0
                }
                set multisampling(e) {
                    const t = this.inputBuffer,
                        n = this.multisampling;
                    n > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
                }
                getTimer() {
                    return this.timer
                }
                getRenderer() {
                    return this.renderer
                }
                setRenderer(e) {
                    if (this.renderer = e, null !== e) {
                        const t = e.getSize(new Z),
                            n = e.getContext().getContextAttributes().alpha,
                            i = this.inputBuffer.texture.type;
                        i === m && e.outputEncoding === R && (this.inputBuffer.texture.encoding = R, this.outputBuffer.texture.encoding = R, this.inputBuffer.dispose(), this.outputBuffer.dispose()), e.autoClear = !1, this.setSize(t.width, t.height);
                        for (const t of this.passes) t.initialize(e, n, i)
                    }
                }
                replaceRenderer(e, t = !0) {
                    const n = this.renderer,
                        i = n.domElement.parentNode;
                    return this.setRenderer(e), t && null !== i && (i.removeChild(n.domElement), i.appendChild(e.domElement)), n
                }
                createDepthTexture() {
                    const e = this.depthTexture = new ps;
                    return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = y, e.type = w) : e.type = g, e
                }
                deleteDepthTexture() {
                    if (null !== this.depthTexture) {
                        this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
                        for (const e of this.passes) e.setDepthTexture(null)
                    }
                }
                createBuffer(e, n, i, r) {
                    const s = this.renderer,
                        a = null === s ? new Z : s.getDrawingBufferSize(new Z),
                        o = {
                            minFilter: p,
                            magFilter: p,
                            stencilBuffer: n,
                            depthBuffer: e,
                            type: i
                        };
                    let l;
                    return r > 0 ? (l = Number(t.replace(/\D+/g, "")) < 138 ? new yo(a.width, a.height, o) : new we(a.width, a.height, o), l.ignoreDepthForMultisampleCopy = !1, l.samples = r) : l = new we(a.width, a.height, o), i === m && null !== s && s.outputEncoding === R && (l.texture.encoding = R), l.texture.name = "EffectComposer.Buffer", l.texture.generateMipmaps = !1, l
                }
                addPass(e, t) {
                    const n = this.passes,
                        i = this.renderer,
                        r = i.getDrawingBufferSize(new Z),
                        s = i.getContext().getContextAttributes().alpha,
                        a = this.inputBuffer.texture.type;
                    if (e.setRenderer(i), e.setSize(r.width, r.height), e.initialize(i, s, a), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== t ? n.splice(t, 0, e) : n.push(e), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), e.needsDepthTexture || null !== this.depthTexture)
                        if (null === this.depthTexture) {
                            const t = this.createDepthTexture();
                            for (e of n) e.setDepthTexture(t)
                        } else e.setDepthTexture(this.depthTexture)
                }
                removePass(e) {
                    const t = this.passes,
                        n = t.indexOf(e);
                    if (-1 !== n && t.splice(n, 1).length > 0) {
                        if (null !== this.depthTexture) {
                            const n = (e, t) => e || t.needsDepthTexture;
                            t.reduce(n, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture())
                        }
                        this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                    }
                }
                removeAllPasses() {
                    const e = this.passes;
                    this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = [])
                }
                render(e) {
                    const t = this.renderer,
                        n = this.copyPass;
                    let i, r, s, a = this.inputBuffer,
                        o = this.outputBuffer,
                        l = !1;
                    void 0 === e && (e = this.timer.update().getDelta());
                    for (const c of this.passes) c.enabled && (c.render(t, a, o, e, l), c.needsSwap && (l && (n.renderToScreen = c.renderToScreen, i = t.getContext(), r = t.state.buffers.stencil, r.setFunc(i.NOTEQUAL, 1, 4294967295), n.render(t, a, o, e, l), r.setFunc(i.EQUAL, 1, 4294967295)), s = a, a = o, o = s), c instanceof ic ? l = !0 : c instanceof Yl && (l = !1))
                }
                setSize(e, t, n) {
                    const i = this.renderer;
                    if (void 0 === e || void 0 === t) {
                        const n = i.getSize(new Z);
                        e = n.width, t = n.height
                    }
                    i.setSize(e, t, n);
                    const r = i.getDrawingBufferSize(new Z);
                    this.inputBuffer.setSize(r.width, r.height), this.outputBuffer.setSize(r.width, r.height);
                    for (const e of this.passes) e.setSize(r.width, r.height)
                }
                reset() {
                    const e = this.timer.isAutoResetEnabled();
                    this.dispose(), this.autoRenderToScreen = !0, this.timer.setAutoResetEnabled(e)
                }
                dispose() {
                    for (const e of this.passes) e.dispose();
                    this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose()
                }
            }(Wd),
            cp = new $l(Gd, od);
        lp.addPass(cp);
        const hp = { ..._c,
                enabled: !0,
                resolutionScale: .7,
                velocityResolutionScale: .1,
                CLAMP_RADIUS: 1,
                temporalResolve: !0,
                temporalResolveMix: 1,
                temporalResolveCorrection: .1,
                blurMix: 0,
                blurSharpness: 0,
                blurKernelSize: 0,
                rayDistance: 2,
                intensity: 1,
                colorExponent: 1,
                maxRoughness: 1,
                jitter: 0,
                roughnessFadeOut: .13,
                rayFadeOut: 3.6,
                thickness: 1.7,
                ior: 1.8,
                MAX_STEPS: 10,
                NUM_BINARY_SEARCH_STEPS: 6,
                maxDepthDifference: 55,
                ALLOW_MISSED_RAYS: !1,
                USE_MRT: !0,
                USE_NORMALMAP: !1,
                USE_ROUGHNESSMAP: !0
            },
            up = new class extends cc {
                constructor(e, t, n = _c) {
                    super("SSREffect", Pc, {
                        type: "FinalSSRMaterial",
                        uniforms: new Map([
                            ["inputTexture", new oo(null)],
                            ["reflectionsTexture", new oo(null)],
                            ["samples", new oo(0)],
                            ["blurMix", new oo(0)],
                            ["blurSharpness", new oo(0)],
                            ["blurKernelSize", new oo(0)]
                        ]),
                        defines: new Map([
                            ["RENDER_MODE", "0"]
                        ])
                    }), this.samples = 0, this.selection = new ac, this.lastSize = void 0, this.lastCameraTransform = {
                        position: new Me,
                        quaternion: new Ae
                    }, this._scene = e, this._camera = t, n = fc({}, _c, n), this.temporalResolvePass = new Dc(e, t, "", n), this.temporalResolvePass.fullscreenMaterial.uniforms.samples = new oo(0), this.temporalResolvePass.fullscreenMaterial.uniforms.colorExponent = new oo(1), this.temporalResolvePass.fullscreenMaterial.defines.EULER = 2.718281828459045, this.temporalResolvePass.fullscreenMaterial.defines.FLOAT_EPSILON = 1e-5, this.uniforms.get("reflectionsTexture").value = this.temporalResolvePass.renderTarget.texture, this.reflectionsPass = new bc(this, n), this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture, this.temporalResolvePass.fullscreenMaterial.uniforms.depthTexture.value = this.reflectionsPass.depthTexture, this.lastSize = {
                        width: n.width,
                        height: n.height,
                        resolutionScale: n.resolutionScale,
                        velocityResolutionScale: n.velocityResolutionScale
                    }, this.lastCameraTransform.position.copy(t.position), this.lastCameraTransform.quaternion.copy(t.quaternion), this.setSize(n.width, n.height), this.makeOptionsReactive(n)
                }
                makeOptionsReactive(e) {
                    const t = window.devicePixelRatio;
                    let n = !1;
                    const i = this.reflectionsPass.fullscreenMaterial.uniforms,
                        r = Object.keys(i);
                    for (const s of Object.keys(e)) Object.defineProperty(this, s, {
                        get: () => e[s],
                        set(a) {
                            if (e[s] !== a || !n) switch (e[s] = a, Rc.includes(s) || (this.samples = 0, this.setSize(e.width, e.height, !0)), s) {
                                case "resolutionScale":
                                    this.setSize(e.width, e.height);
                                    break;
                                case "velocityResolutionScale":
                                    this.temporalResolvePass.velocityResolutionScale = a, this.setSize(e.width, e.height, !0);
                                    break;
                                case "width":
                                    if (void 0 === a) return;
                                    this.setSize(a * t, e.height);
                                    break;
                                case "height":
                                    if (void 0 === a) return;
                                    this.setSize(e.width, a * t);
                                    break;
                                case "blurMix":
                                    this.uniforms.get("blurMix").value = a;
                                    break;
                                case "blurSharpness":
                                    this.uniforms.get("blurSharpness").value = a;
                                    break;
                                case "blurKernelSize":
                                    this.uniforms.get("blurKernelSize").value = a;
                                    break;
                                case "MAX_STEPS":
                                    this.reflectionsPass.fullscreenMaterial.defines.MAX_STEPS = parseInt(a), this.reflectionsPass.fullscreenMaterial.needsUpdate = n;
                                    break;
                                case "NUM_BINARY_SEARCH_STEPS":
                                    this.reflectionsPass.fullscreenMaterial.defines.NUM_BINARY_SEARCH_STEPS = parseInt(a), this.reflectionsPass.fullscreenMaterial.needsUpdate = n;
                                    break;
                                case "ALLOW_MISSED_RAYS":
                                    a ? this.reflectionsPass.fullscreenMaterial.defines.ALLOW_MISSED_RAYS = "" : delete this.reflectionsPass.fullscreenMaterial.defines.ALLOW_MISSED_RAYS, this.reflectionsPass.fullscreenMaterial.needsUpdate = n;
                                    break;
                                case "CLAMP_RADIUS":
                                    this.temporalResolvePass.fullscreenMaterial.defines.CLAMP_RADIUS = Math.round(a), this.temporalResolvePass.fullscreenMaterial.needsUpdate = n;
                                    break;
                                case "temporalResolve":
                                    const o = a ? "#define GLSLIFY 1\nalpha=(velocityDisocclusion<FLOAT_EPSILON)?(alpha+0.05):(alpha-0.25);alpha=clamp(alpha,0.,1.);if(!canReproject||(samples>512.&&alpha==1.)||(length(accumulatedColor)>FLOAT_EPSILON&&length(inputColor)==0.)){accumulatedColor=undoColorTransform(accumulatedColor);float alphaVal=canReproject ? alpha : 0.;gl_FragColor=vec4(accumulatedColor,alpha);return;}if(alpha<1.){outputColor=mix(accumulatedColor,inputColor,(1.-alpha*alpha)*temporalResolveCorrection);}else if(1./samples>=1.-temporalResolveMix){outputColor=mix(inputColor,accumulatedColor,temporalResolveMix);}else{float mixVal=(1./samples)/EULER;if(alpha<FLOAT_EPSILON&&samples<15.)mixVal+=0.3;outputColor=mix(accumulatedColor,inputColor,mixVal);}" : "#define GLSLIFY 1\nalpha=samples<2.||movement<FLOAT_EPSILON ?(0.05+alpha): 0.;alpha=clamp(alpha,0.,1.);if(samples>512.&&alpha==1.){outputColor=accumulatedColor;}else{float samplesMultiplier=pow(samples/32.,4.)+1.;if(samples>1.&&alpha>1.-FLOAT_EPSILON){outputColor=accumulatedColor*(1.-1./(samples*samplesMultiplier))+inputColor/(samples*samplesMultiplier);}else{outputColor=inputColor;}}";
                                    let l = yc;
                                    if (!a) {
                                        const e = l.slice(l.indexOf("// REPROJECT_START"), l.indexOf("// REPROJECT_END") + "// REPROJECT_END".length);
                                        l = yc.replace(e, "")
                                    }
                                    l = l.replace("#include <custom_compose_shader>", o), l = "\n\t\t\t\t\t\t\tuniform float samples;\n\t\t\t\t\t\t\tuniform float temporalResolveMix;\n\t\t\t\t\t\t\t" + l, this.temporalResolvePass.fullscreenMaterial.fragmentShader = l, this.temporalResolvePass.fullscreenMaterial.needsUpdate = !0;
                                    break;
                                case "temporalResolveMix":
                                    this.temporalResolvePass.fullscreenMaterial.uniforms.temporalResolveMix.value = a;
                                    break;
                                case "temporalResolveCorrection":
                                    this.temporalResolvePass.fullscreenMaterial.uniforms.temporalResolveCorrection.value = a;
                                    break;
                                case "colorExponent":
                                    this.temporalResolvePass.fullscreenMaterial.uniforms.colorExponent.value = a;
                                    break;
                                default:
                                    r.includes(s) && (i[s].value = a)
                            }
                        }
                    }), this[s] = e[s];
                    n = !0
                }
                setSize(e, t, n = !1) {
                    (n || e !== this.lastSize.width || t !== this.lastSize.height || this.resolutionScale !== this.lastSize.resolutionScale || this.velocityResolutionScale !== this.lastSize.velocityResolutionScale) && (this.temporalResolvePass.setSize(e, t), this.reflectionsPass.setSize(e, t), this.lastSize = {
                        width: e,
                        height: t,
                        resolutionScale: this.resolutionScale,
                        velocityResolutionScale: this.velocityResolutionScale
                    })
                }
                checkNeedsResample() {
                    const e = this.lastCameraTransform.position.distanceToSquared(this._camera.position),
                        t = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));
                    (e > 1e-6 || t > 1e-6) && (this.samples = 1, this.lastCameraTransform.position.copy(this._camera.position), this.lastCameraTransform.quaternion.copy(this._camera.quaternion))
                }
                dispose() {
                    super.dispose(), this.reflectionsPass.dispose(), this.temporalResolvePass.dispose()
                }
                update(e, t) {
                    this.samples++, this.checkNeedsResample(), this.uniforms.get("samples").value = this.samples, this.reflectionsPass.render(e, t), this.temporalResolvePass.fullscreenMaterial.uniforms.samples.value = this.samples, this.temporalResolvePass.render(e)
                }
            }(Gd, od, hp),
            dp = new class extends cc {
                constructor({
                    blendFunction: e,
                    technique: t = 0,
                    eskil: n = !1,
                    offset: i = .5,
                    darkness: r = .5
                } = {}) {
                    super("VignetteEffect", "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}", {
                        blendFunction: e,
                        defines: new Map([
                            ["VIGNETTE_TECHNIQUE", t.toFixed(0)]
                        ]),
                        uniforms: new Map([
                            ["offset", new oo(i)],
                            ["darkness", new oo(r)]
                        ])
                    })
                }
                get technique() {
                    return Number(this.defines.get("VIGNETTE_TECHNIQUE"))
                }
                set technique(e) {
                    this.technique !== e && (this.defines.set("VIGNETTE_TECHNIQUE", e.toFixed(0)), this.setChanged())
                }
                get eskil() {
                    return 1 === this.technique
                }
                set eskil(e) {
                    this.technique = e ? 1 : 0
                }
                getTechnique() {
                    return this.technique
                }
                setTechnique(e) {
                    this.technique = e
                }
                get offset() {
                    return this.uniforms.get("offset").value
                }
                set offset(e) {
                    this.uniforms.get("offset").value = e
                }
                getOffset() {
                    return this.offset
                }
                setOffset(e) {
                    this.offset = e
                }
                get darkness() {
                    return this.uniforms.get("darkness").value
                }
                set darkness(e) {
                    this.uniforms.get("darkness").value = e
                }
                getDarkness() {
                    return this.darkness
                }
                setDarkness(e) {
                    this.darkness = e
                }
            }({
                darkness: .5675
            }),
            pp = new class extends cc {
                constructor({
                    blendFunction: e = 30,
                    preset: t = 1,
                    edgeDetectionMode: n = 2,
                    predicationMode: i = 0
                } = {}) {
                    let r, s;
                    super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", {
                        vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                        blendFunction: e,
                        attributes: 3,
                        uniforms: new Map([
                            ["weightMap", new oo(null)]
                        ])
                    }), arguments.length > 1 && (r = arguments[0], s = arguments[1], arguments.length > 2 && (t = arguments[2]), arguments.length > 3 && (n = arguments[3])), this.renderTargetEdges = new we(1, 1, {
                        depthBuffer: !1
                    }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new Ql(!0, !1, !1), this.clearPass.overrideClearColor = new ue(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new rc(new Ul), this.edgeDetectionMaterial.edgeDetectionMode = n, this.edgeDetectionMaterial.predicationMode = i, this.weightsPass = new rc(new Vl);
                    const a = new ga;
                    a.onLoad = () => {
                        const e = new ve(r);
                        e.name = "SMAA.Search", e.magFilter = h, e.minFilter = h, e.generateMipmaps = !1, e.needsUpdate = !0, e.flipY = !0, this.weightsMaterial.searchTexture = e;
                        const t = new ve(s);
                        t.name = "SMAA.Area", t.magFilter = p, t.minFilter = p, t.generateMipmaps = !1, t.needsUpdate = !0, t.flipY = !1, this.weightsMaterial.areaTexture = t, this.dispatchEvent({
                            type: "load"
                        })
                    }, a.itemStart("search"), a.itemStart("area"), void 0 !== r && void 0 !== s ? (a.itemEnd("search"), a.itemEnd("area")) : "undefined" != typeof Image && (r = new Image, s = new Image, r.addEventListener("load", (() => a.itemEnd("search"))), s.addEventListener("load", (() => a.itemEnd("area"))), r.src = dc, s.src = pc), this.applyPreset(t)
                }
                get edgesTexture() {
                    return this.renderTargetEdges.texture
                }
                getEdgesTexture() {
                    return this.edgesTexture
                }
                get weightsTexture() {
                    return this.renderTargetWeights.texture
                }
                getWeightsTexture() {
                    return this.weightsTexture
                }
                get edgeDetectionMaterial() {
                    return this.edgeDetectionPass.fullscreenMaterial
                }
                get colorEdgesMaterial() {
                    return this.edgeDetectionMaterial
                }
                getEdgeDetectionMaterial() {
                    return this.edgeDetectionMaterial
                }
                get weightsMaterial() {
                    return this.weightsPass.fullscreenMaterial
                }
                getWeightsMaterial() {
                    return this.weightsMaterial
                }
                setEdgeDetectionThreshold(e) {
                    this.edgeDetectionMaterial.edgeDetectionThreshold = e
                }
                setOrthogonalSearchSteps(e) {
                    this.weightsMaterial.orthogonalSearchSteps = e
                }
                applyPreset(e) {
                    const t = this.edgeDetectionMaterial,
                        n = this.weightsMaterial;
                    switch (e) {
                        case 0:
                            t.edgeDetectionThreshold = .15, n.orthogonalSearchSteps = 4, n.diagonalDetection = !1, n.cornerDetection = !1;
                            break;
                        case 1:
                            t.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 8, n.diagonalDetection = !1, n.cornerDetection = !1;
                            break;
                        case 2:
                            t.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 16, n.diagonalSearchSteps = 8, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0;
                            break;
                        case 3:
                            t.edgeDetectionThreshold = .05, n.orthogonalSearchSteps = 32, n.diagonalSearchSteps = 16, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0
                    }
                }
                setDepthTexture(e, t = 3200) {
                    this.edgeDetectionMaterial.depthBuffer = e, this.edgeDetectionMaterial.depthPacking = t
                }
                update(e, t, n) {
                    this.clearPass.render(e, this.renderTargetEdges), this.edgeDetectionPass.render(e, t, this.renderTargetEdges), this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
                }
                setSize(e, t) {
                    this.edgeDetectionMaterial.setSize(e, t), this.weightsMaterial.setSize(e, t), this.renderTargetEdges.setSize(e, t), this.renderTargetWeights.setSize(e, t)
                }
                dispose() {
                    const {
                        searchTexture: e,
                        areaTexture: t
                    } = this.weightsMaterial;
                    null !== e && null !== t && (e.dispose(), t.dispose()), super.dispose()
                }
                static get searchImageDataURL() {
                    return dc
                }
                static get areaImageDataURL() {
                    return pc
                }
            }({
                preset: 1
            });
        lp.addPass(new class extends Wl {
            constructor(e, ...t) {
                super("EffectPass"), this.fullscreenMaterial = new zl(null, null, null, e), this.listener = e => this.handleEvent(e), this.effects = [], this.setEffects(t), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY
            }
            get encodeOutput() {
                return this.fullscreenMaterial.encodeOutput
            }
            set encodeOutput(e) {
                this.fullscreenMaterial.encodeOutput = e
            }
            get dithering() {
                return this.fullscreenMaterial.dithering
            }
            set dithering(e) {
                const t = this.fullscreenMaterial;
                t.dithering = e, t.needsUpdate = !0
            }
            setEffects(e) {
                for (const e of this.effects) e.removeEventListener("change", this.listener);
                this.effects = e.sort(((e, t) => t.attributes - e.attributes));
                for (const e of this.effects) e.addEventListener("change", this.listener)
            }
            updateMaterial() {
                const e = new class {
                    constructor() {
                        this.shaderParts = new Map([
                            [Nl.FRAGMENT_HEAD, null],
                            [Nl.FRAGMENT_MAIN_UV, null],
                            [Nl.FRAGMENT_MAIN_IMAGE, null],
                            [Nl.VERTEX_HEAD, null],
                            [Nl.VERTEX_MAIN_SUPPORT, null]
                        ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = 0, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = P
                    }
                };
                let t = 0;
                for (const n of this.effects)
                    if (9 === n.blendMode.blendFunction) e.attributes |= 1 & n.getAttributes();
                    else {
                        if (0 != (e.attributes & n.getAttributes() & 2)) throw new Error(`Convolution effects cannot be merged (${n.name})`);
                        nc("e" + t++, n, e)
                    }
                    let fragmentHead = e.shaderParts.get(Nl.FRAGMENT_HEAD),
                    fragmentImage = e.shaderParts.get(Nl.FRAGMENT_MAIN_IMAGE),
                    fragmentUV = e.shaderParts.get(Nl.FRAGMENT_MAIN_UV);
                
                const blendRegex = /\bblend\b/g;
                
                for (const blendMode of e.blendModes.values()) {
                    // Adjust the replacement logic to ensure correct GLSL syntax
                    const replacedCode = blendMode.getShaderCode().replace(blendRegex, `blend${blendMode.blendFunction}`);
                    fragmentHead += replacedCode + "\n";
                }
                
                // Check if attributes include depth reading
                if (0 != (1 & e.attributes)) {
                    if (e.readDepth) {
                        fragmentImage = "float depth = readDepth(UV);\n\n\t" + fragmentImage;
                    }
                    this.needsDepthTexture = null === this.getDepthTexture();
                } else {
                    this.needsDepthTexture = false;
                }
                
                // Check if color space is R
                if (e.colorSpace === R) {
                    fragmentImage += "color0 = sRGBToLinear(color0);\n\t";
                }
                
                // Check if UV transformation is needed
                if (e.uvTransformation) {
                    fragmentUV = "vec2 transformedUv = vUv;\n" + fragmentUV;
                    e.defines.set("UV", "transformedUv");
                } else {
                    e.defines.set("UV", "vUv");
                }
                
                // Update shader parts
                e.shaderParts.set(Nl.FRAGMENT_HEAD, fragmentHead);
                e.shaderParts.set(Nl.FRAGMENT_MAIN_IMAGE, fragmentImage);
                e.shaderParts.set(Nl.FRAGMENT_MAIN_UV, fragmentUV);
                
                // Trim and replace leading '#' in each shader part
                e.shaderParts.forEach((shaderPart, key, map) => map.set(key, shaderPart ? shaderPart.trim().replace(/^#/, "\n#") : ""));
                
                // Update rendering flags
                this.skipRendering = 0 === t;
                this.needsSwap = !this.skipRendering;
                
                // Set shader data for fullscreen material
                this.fullscreenMaterial.setShaderData(e);
                }
            recompile() {
                this.updateMaterial()
            }
            getDepthTexture() {
                return this.fullscreenMaterial.depthBuffer
            }
            setDepthTexture(e, t = 3200) {
                this.fullscreenMaterial.depthBuffer = e, this.fullscreenMaterial.depthPacking = t;
                for (const n of this.effects) n.setDepthTexture(e, t)
            }
            render(e, t, n, i, r) {
                for (const n of this.effects) n.update(e, t, i);
                if (!this.skipRendering || this.renderToScreen) {
                    const r = this.fullscreenMaterial;
                    r.inputBuffer = t.texture, r.time += i, e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                }
            }
            setSize(e, t) {
                this.fullscreenMaterial.setSize(e, t);
                for (const n of this.effects) n.setSize(e, t)
            }
            initialize(e, t, n) {
                this.renderer = e;
                for (const i of this.effects) i.initialize(e, t, n);
                this.updateMaterial(), void 0 !== n && n !== m && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
            }
            dispose() {
                super.dispose();
                for (const e of this.effects) e.removeEventListener("change", this.listener), e.dispose()
            }
            handleEvent(e) {
                "change" === e.type && this.recompile()
            }
        }(od, up, dp, pp));
        let fp = !1;
        const mp = {
            x: 0,
            y: 0
        };

        function gp() {
            if ("seats" == Od)
                if (qd) {
                    const e = qd.name.match(/\_(.*)$/);
                    Pd.innerHTML = this != `SEAT ${e[1]}` ? `SEAT ${e[1]}` : "", Ld.innerHTML = `Price: $${qd.userData.price} - Standard`, Pd.parentNode.classList.add("show")
                } else Pd.parentNode.classList.remove("show")
        }

        function vp() {
            dd.minDistance = 5, dd.maxDistance = 25, dd.maxPolarAngle = Math.PI / 2.1, dd.minPolarAngle = .8, dd.enableDamping = !0, dd.dampingFactor = .1, dd.enableZoom = !1, dd.enablePan = !0, dd.zoomSpeed = .2, dd.screenSpacePanning = !1, dd.autoRotateSpeed = .6;
            var e = new Me(-15, -15, -15),
                t = new Me(15, 15, 15),
                n = new Me;
            dd.addEventListener("change", (function() {
                n.copy(dd.target), dd.target.clamp(e, t), n.sub(dd.target), od.position.sub(n)
            }))
        }

        function xp() {
            dd.minDistance = 0, dd.maxDistance = 60, dd.maxPolarAngle = Math.PI, dd.minPolarAngle = .8
        }

        function wp() {
            document.getElementById("header").style.pointerEvents = "none", document.querySelector(".main--menu .home").classList.add("active"), document.querySelector(".main--menu .projects").classList.remove("active"), dd.minDistance = 0, dd.maxDistance = 45, new wl.Tween(rp).to({
                opacity: 0
            }, 1e3).easing(wl.Easing.Quartic.InOut).start().onComplete((function() {
                wl.remove(this)
            })), new wl.Tween(dd.target).to({
                x: -5.4,
                y: -1.1,
                z: -.2
            }, 1800).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                wl.remove(this)
            })), new wl.Tween(od.position).to({
                x: 6,
                y: -.8,
                z: -12
            }, 1800).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                wl.remove(this), id.classList.add("show"), xp(), dd.enabled = !1, document.getElementById("header").style.pointerEvents = "auto"
            })), new wl.Tween(od).to({
                fov: 55
            }, 2e3).start().onUpdate((() => {
                od.updateProjectionMatrix()
            }))
        }

        function bp() {
            Sp.classList.remove("arrow"), new wl.Tween(dd.target).to({
                x: 0,
                y: 4,
                z: 0
            }, 2e3).delay(300).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                wl.remove(this)
            })), new wl.Tween(od.position).to({
                y: 6
            }, 2e3).delay(300).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                dd.enabled = !0
            }))
        }
        document.getElementById("menu-list").classList.add("invert"), document.getElementById("menu_hamburguer").classList.add("invert");
        var _p = {
            color: cd.color.getHex(),
            color3: Gd.background.getHex()
        };
        const yp = function() {
            var e = new ue(_p.color),
                t = (new ue(_p.color2), new ue(_p.color3));
            cd.color.set(e), Gd.background.set(t)
        };
        if (1 == Ud) {
            const e = Ad.addFolder("Lights"),
                t = Ad.addFolder("Scene config");
            e.add(cd, "intensity").min(0).max(10).step(1e-4).name("Dir intensity"), e.add(cd.position, "y").min(0).max(100).step(1e-5).name("Dir Y pos"), e.add(cd.position, "x").min(-100).max(100).step(1e-5).name("Dir X pos"), e.add(cd.position, "z").min(-100).max(100).step(1e-5).name("Dir Z pos"), e.addColor(_p, "color").name("Main color").onChange(yp), t.addColor(_p, "color3").name("Bg color").onChange(yp), Ad.close()
        }
        let Ap = {
            value: 0
        };
        Ap.target = Ap.value, Ap.easing = .08;
        let Mp = 0;
        const Sp = document.querySelector("#cursor"),
            Ep = Sp.querySelector(".cursor__circle"),
            Tp = {
                x: -100,
                y: -100
            },
            Cp = {
                x: 0,
                y: 0
            },
            Dp = e => {
                Tp.x = e.clientX, Tp.y = e.clientY
            };
        let Pp = document.querySelectorAll("[cursor-class]");

        function Rp() {
            Pp = document.querySelectorAll("[cursor-class]"), Pp.forEach((e => {
                e.addEventListener("mouseenter", (function() {
                    const e = this.getAttribute("cursor-class");
                    Sp.classList.add(e)
                })), e.addEventListener("mouseleave", (function() {
                    const e = this.getAttribute("cursor-class");
                    Sp.classList.remove(e)
                }))
            }))
        }

        function Lp(e) {
            var t = new XMLHttpRequest;
            if (document.body.style.cursor = "wait", document.getElementById("header").style.pointerEvents = "none", ad.style.display = "flex", Bd) {
                const n = {
                    x: 0
                };
                new wl.Tween(n).to({
                    x: 1
                }, 400).easing(wl.Easing.Quadratic.InOut).start().onUpdate((() => {
                    ad.style.opacity = n.x
                })).onComplete((() => {
                    t.open("GET", `${e}.html`, !0), t.send()
                }))
            } else t.open("GET", `${e}.html`, !0), t.send();
            t.onload = function() {
                if (t.status >= 200 && t.status < 400) {
                    var n = t.responseText;
                    ad.innerHTML = n;
                    const e = {
                        x: 50,
                        opacity: 0
                    };
                    new wl.Tween(e).to({
                        x: 0,
                        opacity: 1
                    }, 800).easing(wl.Easing.Quadratic.InOut).start().onUpdate((() => {
                        ad.style.opacity = `${e.opacity}`
                    })).onComplete((() => {
                        document.getElementById("header").style.pointerEvents = "auto", document.body.style.cursor = "default"
                    })), Bd = !0
                }
                "season" == e && (document.querySelector(".btn--aida").addEventListener("click", (() => {
                    Ip("aida"), td.classList.remove("down")
                })), Rp()), "aida" == e && (document.querySelector(".btn--seats").addEventListener("click", (() => {
                    Sp.classList.remove("arrow"), new wl.Tween(dd.target).to({
                        x: 0,
                        y: 4,
                        z: 0
                    }, 2e3).delay(700).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                        wl.remove(this)
                    })), new wl.Tween(od.position).to({
                        x: 0,
                        y: 6,
                        z: 12
                    }, 2e3).delay(700).easing(wl.Easing.Quadratic.InOut).start().onComplete((function() {
                        dd.enabled = !0, Xd(), vp()
                    })), new wl.Tween(od).to({
                        fov: 70
                    }, 2e3).delay(700).start().onUpdate((() => {
                        od.updateProjectionMatrix()
                    })), Ip("seats")
                })), document.querySelector(".back--season").addEventListener("click", (() => {
                    Ip("season"), td.classList.add("down")
                })), Rp()), "seats" == e && (Od = e, Pd = document.querySelector(".sector--name"), Ld = document.querySelector(".chair--price--hover"), Rd = document.querySelector(".selected--chair--component"), ad.style.pointerEvents = "none", document.querySelector(".button--cancel").addEventListener("click", (() => {
                    document.querySelector(".seats--main--container").classList.remove("hide"), Rd.classList.remove("show"), dd.enabled = !0, bp();
                    for (const e of Qd) e.material.emissiveIntensity = 1
                })), document.querySelector(".button--add--cart").addEventListener("click", (() => {
                    Rd.classList.remove("show"), document.querySelector(".seats--main--container").classList.remove("hide"), dd.enabled = !0, bp(), document.getElementById("cart").checked = !0
                })), document.querySelector(".seats .helper").addEventListener("click", (() => {
                    document.querySelector(".seats .helper").parentNode.removeChild(document.querySelector(".seats .helper"))
                })), document.querySelector(".back--sections").addEventListener("click", (() => {
                    Ip(), wp();
                    for (const e of Qd) e.material.emissiveIntensity = 0;
                    td.classList.add("down"), ad.style.pointerEvents = "auto", xp(), dd.enabled = !1, jd.pause(), Td = !1
                })), document.querySelector(".button--payment").addEventListener("click", (() => {
                    document.getElementById("cart").checked = !1, document.querySelector(".about--container").style.display = "flex"
                })), document.querySelector(".continue--shopping").addEventListener("click", (() => {
                    document.getElementById("cart").checked = !1
                })), document.querySelector(".button--close").addEventListener("click", (() => {
                    document.getElementById("cart").checked = !1
                })), document.querySelector(".music--button").addEventListener("click", (() => {
                    document.getElementById("music--toggle").checked ? (document.querySelector(".music--button").innerHTML = '<img width="17px" src="./icons/music_off.svg">MUSIC OFF', jd.pause(), Td = !1) : (document.querySelector(".music--button").innerHTML = '<img width="17px" src="./icons/music_on.svg">MUSIC ON', jd.play(), Td = !0)
                })), Rp())
            }
        }

        function Ip(e) {
            if (Bd) {
                const t = {
                    x: 1
                };
                new wl.Tween(t).to({
                    x: 0
                }, 400).easing(wl.Easing.Quadratic.InOut).start().onUpdate((() => {
                    ad.style.opacity = t.x
                })).onComplete((function() {
                    ad.innerHTML = "", ad.style.display = "none", Bd = !1, null != e && Lp(e)
                }))
            }
        }
        Rp(), Ed && (dd.enableZoom = !0, dd.enableRotate = !0, od.fov = 95, Wd.setPixelRatio(Math.min(window.devicePixelRatio, 2)), Wd.alias = !0, od.updateProjectionMatrix(), Fd = !1, Wd.stencil = !0, Wd.depth = !0),
            function e() {
                ap.lookAt(od.position);
                const t = Dd.getElapsedTime();
                Mp = t, Jd | document.hidden && (dd.update(), wl.update(), Fd ? lp.render() : Wd.render(Gd, od)), (() => {
                    const e = Math.round(Tp.x - Cp.x),
                        t = Math.round(Tp.y - Cp.y);
                    Cp.x += .1 * e, Cp.y += .1 * t;
                    const n = function(e, t) {
                            return 180 * Math.atan2(t, e) / Math.PI
                        }(e, t),
                        i = function(e, t) {
                            const n = Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2));
                            return Math.min(n / 1500, .15)
                        }(e, t),
                        r = "scale(" + (1 + i) + ", " + (1 - i) + ")",
                        s = "rotate(" + n + "deg)",
                        a = "translate3d(" + Cp.x + "px ," + Cp.y + "px, 0)";
                    Sp.style.transform = a, Ep.style.transform = s + r
                })(), Ud && ld && ld.update(), requestAnimationFrame(e)
            }()
    })()
})();